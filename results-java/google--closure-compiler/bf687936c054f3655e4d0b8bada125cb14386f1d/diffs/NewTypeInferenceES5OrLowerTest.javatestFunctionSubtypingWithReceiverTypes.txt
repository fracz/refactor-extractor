public void testFunctionSubtypingWithReceiverTypes() {
    typeCheck(Joiner.on('\n').join("/**", " * @template T", " * @param {function(this:T)} x", " */", "function f(x) {}", "/** @constructor */", "function Foo() {}", "f(/** @this{Foo} */ function () {});"));
    // We don't catch the NOT_UNIQUE_INSTANTIATION warning
    typeCheck(Joiner.on('\n').join("/**", " * @template T", " * @param {T} x", " * @param {function(this:T)} y", " */", "function f(x, y) {}", "/** @constructor */", "function Foo() {}", "/** @constructor */", "function Bar() {}", "f(new Bar, /** @this{Foo} */function () {});"));
    // Sets Bar#p to a number but we don't catch it
    typeCheck(Joiner.on('\n').join("/** @constructor */", "function Foo() {}", "/** @constructor */", "function Bar() {", "  /** @type {string} */ this.p = 'asdf';", "}", "/**", " * @this {Foo}", " * @param {number} x", " */", "function f(x) { this.p = x; }", "/** @param {function(number)} x */", "function g(x) { x.call(new Bar, 123); }", "g(f);"));
}||||||||public void testFunctionSubtypingWithReceiverTypes() {
    typeCheck(Joiner.on('\n').join("/**", " * @template T", " * @param {function(this:T)} x", " */", "function f(x) {}", "/** @constructor */", "function Foo() {}", "f(/** @this{Foo} */ function () {});"));
    typeCheck(Joiner.on('\n').join("/**", " * @template T", " * @param {T} x", " * @param {function(this:T)} y", " */", "function f(x, y) {}", "/** @constructor */", "function Foo() {}", "/** @constructor */", "function Bar() {}", "f(new Bar, /** @this{Foo} */function () {});"), NewTypeInference.NOT_UNIQUE_INSTANTIATION);
    typeCheck(Joiner.on('\n').join("/** @constructor */", "function Foo() {}", "/** @constructor */", "function Bar() {", "  /** @type {string} */ this.p = 'asdf';", "}", "/**", " * @this {Foo}", " * @param {number} x", " */", "function f(x) { this.p = x; }", "/** @param {function(number)} x */", "function g(x) { x.call(new Bar, 123); }", // Passing a fun w/ @this to a context that expects a fun w/out @this.
    "g(f);"), NewTypeInference.INVALID_ARGUMENT_TYPE);
    // Sets Bar#p to a number. We could maybe find this, non trivial though.
    typeCheck(Joiner.on('\n').join("/** @constructor */", "function Foo() {}", "/** @constructor @extends {Foo} */", "function Bar() {", "  /** @type {string} */ this.p = 'asdf';", "}", "/**", " * @this {Foo}", " * @param {number} x", " */", "function f(x) { this.p = x; }", "/** @param {function(number)} x */", "f.call(new Bar, 123);"));
}||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(MethodCallExpr
				(MethodCallExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					SimpleName
					(MethodCallExpr
						(CharLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
				)
				SimpleName
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				(MethodCallExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					SimpleName
					(MethodCallExpr
						(CharLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
				)
				SimpleName
			)
			LineComment
		)
		(ExpressionStmt
			(MethodCallExpr
				(MethodCallExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					SimpleName
					(MethodCallExpr
						(CharLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
				)
				SimpleName
			)
			LineComment
		)
	)
	(VoidType
	)
	SimpleName
)
||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(MethodCallExpr
				(MethodCallExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					SimpleName
					(MethodCallExpr
						(CharLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
				)
				SimpleName
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				(MethodCallExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					SimpleName
					(MethodCallExpr
						(CharLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
				)
				(FieldAccessExpr
					SimpleName
					NameExpr
						SimpleName
				)
				SimpleName
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				(MethodCallExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
						LineComment
					SimpleName
					(MethodCallExpr
						(CharLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
				)
				(FieldAccessExpr
					SimpleName
					NameExpr
						SimpleName
				)
				SimpleName
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				(MethodCallExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					StringLiteralExpr
					SimpleName
					(MethodCallExpr
						(CharLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
				)
				SimpleName
			)
			LineComment
		)
	)
	(VoidType
	)
	SimpleName
)

