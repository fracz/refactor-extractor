/**
 * Unify {@code this}, which may contain free type variables,
 * with {@code other}, a concrete subtype, modifying the supplied
 * {@code typeMultimap} to add any new template variable type bindings.
 * @return Whether unification succeeded
 *
 * This method should only be called outside the newtypes package;
 * classes inside the package should use unifyWithSubtype.
 *
 * Unification algorithm.
 *
 * Say that {@code this} is a potentially generic type G and {@code other} is a concrete type C.
 * 1. If C is not a union:
 * (A) If C is a subtype of G, then unification succeeds and we don't update the type map.
 * E.g., (T|string) unifies with string and we learn nothing about T.
 * (B) If some member of G unifies with C, unification succeeds and we update the type map.
 * (C) If 2+ members of G unify with C, we use each of them to update the type map. This is
 * simpler than depending on the iteration order of the members of G to decide which one
 * to unify with C.
 * E.g., if Foo extends Bar and implements Baz,
 * (Bar(T)|Baz(T)) unifies with Foo(number) and T is number.
 * (Bar(number, T)|Baz(T, string)) doesn't unify with Foo(number,string), but each member
 * unifies with C, and we get a "not unique instantiation" warning.
 *
 * 2. If C is a union:
 * We throw away C's members that are subtypes of G, and for each remaining
 * member we try to individually unify G with it. A single member of G may unify with
 * 2+ members of C.
 * Let SubC be a type that contains all members of C that are left over: they are not subtypes
 * of G and G doesn't unify with them. If G is of the form (T|...), then T is mapped to SubC.
 * E.g., (T|Foo|Bar(U)) unifies with (number|string|Foo|Bar(Baz))
 * SubC is (number|string), T is mapped to (number|string), and U is mapped to Baz.
 */
public final boolean unifyWith(JSType other, List<String> typeParameters, Multimap<String, JSType> typeMultimap) {
    return unifyWithSubtype(other, typeParameters, typeMultimap, SubtypeCache.create());
}||||||||/**
 * Unify {@code this}, which may contain free type variables,
 * with {@code other}, a concrete subtype, modifying the supplied
 * {@code typeMultimap} to add any new template variable type bindings.
 *
 * This method should only be called outside the newtypes package;
 * classes inside the package should use unifyWithSubtype.
 *
 * Unification algorithm.
 *
 * Say that {@code this} is a potentially generic type G and {@code other} is a concrete type C.
 * 1. If C is not a union:
 * (A) If C is a subtype of G, then unification succeeds and we don't update the type map.
 * E.g., (T|string) unifies with string and we learn nothing about T.
 * (B) If some member of G unifies with C, unification succeeds and we update the type map.
 * (C) If 2+ members of G unify with C, we use each of them to update the type map. This is
 * simpler than depending on the iteration order of the members of G to decide which one
 * to unify with C.
 * E.g., if Foo extends Bar and implements Baz,
 * (Bar(T)|Baz(T)) unifies with Foo(number) and T is number.
 * (Bar(number, T)|Baz(T, string)) doesn't unify with Foo(number,string), but each member
 * unifies with C, and we get a "not unique instantiation" warning.
 *
 * 2. If C is a union:
 * We throw away C's members that are subtypes of G, and for each remaining
 * member we try to individually unify G with it. A single member of G may unify with
 * 2+ members of C.
 * Let SubC be a type that contains all members of C that are left over: they are not subtypes
 * of G and G doesn't unify with them. If G is of the form (T|...), then T is mapped to SubC.
 * E.g., (T|Foo|Bar(U)) unifies with (number|string|Foo|Bar(Baz))
 * SubC is (number|string), T is mapped to (number|string), and U is mapped to Baz.
 */
public final void unifyWith(JSType other, List<String> typeParameters, Multimap<String, JSType> typeMultimap) {
    unifyWithSubtype(other, typeParameters, typeMultimap, SubtypeCache.create());
}||||||||(MethodDeclaration
	(BlockStmt
		(ReturnStmt
			(MethodCallExpr
				NameExpr
					SimpleName
				NameExpr
					SimpleName
				NameExpr
					SimpleName
				(MethodCallExpr
					SimpleName
					NameExpr
						SimpleName
				)
				SimpleName
			)
		)
	)
	(PrimitiveType
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(ClassOrInterfaceType
				SimpleName
			)
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(ClassOrInterfaceType
				SimpleName
			)
			(ClassOrInterfaceType
				SimpleName
			)
		)
	)
	(JavadocComment
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(MethodCallExpr
				NameExpr
					SimpleName
				NameExpr
					SimpleName
				NameExpr
					SimpleName
				(MethodCallExpr
					SimpleName
					NameExpr
						SimpleName
				)
				SimpleName
			)
		)
	)
	(VoidType
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(ClassOrInterfaceType
				SimpleName
			)
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(ClassOrInterfaceType
				SimpleName
			)
			(ClassOrInterfaceType
				SimpleName
			)
		)
	)
	(JavadocComment
	)
)

