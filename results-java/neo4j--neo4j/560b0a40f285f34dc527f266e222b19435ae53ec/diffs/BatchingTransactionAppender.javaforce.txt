@Override
public void force() throws IOException {
    // also synchronize on writer.
    synchronized (logFile) {
        writer.emptyBufferIntoChannelAndClearIt();
        writer.force();
    }
}||||||||@Override
public void force() throws IOException {
    // also synchronize on writer.
    synchronized (logFile) {
        writer.emptyBufferIntoChannelAndClearIt();
    }
    // This allows multiple threads forcing at the same time to piggy-back onto one another.
    try {
        writer.force();
    } catch (ClosedChannelException ignored) {
    // This is ok, we were already successful in emptying the buffer, so the channel being closed here means
    // that some other thread is rotating the log and has closed the underlying channel. But since we were
    // successful in emptying the buffer *UNDER THE LOCK* we know that the rotating thread included the changes
    // we emptied into the channel, and thus it is already flushed by that thread.
    }
}||||||||(MethodDeclaration
	(BlockStmt
		(SynchronizedStmt
			(BlockStmt
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
				)
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
			NameExpr
				SimpleName
			LineComment
		)
	)
	(VoidType
	)
	SimpleName
	(ClassOrInterfaceType
		SimpleName
	)
	(MarkerAnnotationExpr
		Name
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(SynchronizedStmt
			(BlockStmt
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
			NameExpr
				SimpleName
			LineComment
		)
		(TryStmt
			(CatchClause
				(BlockStmt
				)
				(Parameter
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
			(BlockStmt
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
			LineComment
		)
	)
	(VoidType
	)
	SimpleName
	(ClassOrInterfaceType
		SimpleName
	)
	(MarkerAnnotationExpr
		Name
	)
)

