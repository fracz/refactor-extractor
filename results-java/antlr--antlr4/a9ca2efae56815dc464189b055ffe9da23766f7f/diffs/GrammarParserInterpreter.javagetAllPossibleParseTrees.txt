/**
 * Given an ambiguous parse information, return the list of ambiguous parse trees.
 * An ambiguity occurs when a specific token sequence can be recognized
 * in more than one way by the grammar. These ambiguities are detected only
 * at decision points.
 *
 * The list of trees includes the actual interpretation (that for
 * the minimum alternative number) and all ambiguous alternatives.
 * The actual interpretation is always first.
 *
 * This method reuses the same physical input token stream used to
 * detect the ambiguity by the original parser in the first place.
 * This method resets/seeks within but does not alter originalParser.
 *
 * The trees are rooted at the node whose start..stop token indices
 * include the start and stop indices of this ambiguity event. That is,
 * the trees returned will always include the complete ambiguous subphrase
 * identified by the ambiguity event.  The subtrees returned will
 * also always contain the node associated with the overridden decision.
 *
 * Be aware that this method does NOT notify error or parse listeners as
 * it would trigger duplicate or otherwise unwanted events.
 *
 * This uses a temporary ParserATNSimulator and a ParserInterpreter
 * so we don't mess up any statistics, event lists, etc...
 * The parse tree constructed while identifying/making ambiguityInfo is
 * not affected by this method as it creates a new parser interp to
 * get the ambiguous interpretations.
 *
 * Nodes in the returned ambig trees are independent of the original parse
 * tree (constructed while identifying/creating ambiguityInfo).
 *
 * @since 4.5.1
 *
 * @param g              From which grammar should we drive alternative
 * numbers and alternative labels.
 *
 * @param originalParser The parser used to create ambiguityInfo; it
 * is not modified by this routine and can be either
 * a generated or interpreted parser. It's token
 * stream *is* reset/seek()'d.
 * @param tokens		  A stream of tokens to use with the temporary parser.
 * This will often be just the token stream within the
 * original parser but here it is for flexibility.
 *
 * @param decision       Which decision to try different alternatives for.
 *
 * @param alts           The set of alternatives to try while re-parsing.
 *
 * @param startIndex	  The index of the first token of the ambiguous
 * input or other input of interest.
 *
 * @param stopIndex      The index of the last token of the ambiguous input.
 * The start and stop indexes are used primarily to
 * identify how much of the resulting parse tree
 * to return.
 *
 * @param startRuleIndex The start rule for the entire grammar, not
 * the ambiguous decision. We re-parse the entire input
 * and so we need the original start rule.
 *
 * @return               The list of all possible interpretations of
 * the input for the decision in ambiguityInfo.
 * The actual interpretation chosen by the parser
 * is always given first because this method
 * retests the input in alternative order and
 * ANTLR always resolves ambiguities by choosing
 * the first alternative that matches the input.
 * The subtree returned
 *
 * @throws RecognitionException Throws upon syntax error while matching
 * ambig input.
 */
public static List<ParserRuleContext> getAllPossibleParseTrees(Grammar g, Parser originalParser, TokenStream tokens, int decision, BitSet alts, int startIndex, int stopIndex, int startRuleIndex) throws RecognitionException {
    List<ParserRuleContext> trees = new ArrayList<ParserRuleContext>();
    // Create a new parser interpreter to parse the ambiguous subphrase
    ParserInterpreter parser;
    if (originalParser instanceof ParserInterpreter) {
        parser = new GrammarParserInterpreter(g, originalParser.getATN(), originalParser.getTokenStream());
    } else {
        // must've been a generated parser
        char[] serializedAtn = ATNSerializer.getSerializedAsChars(originalParser.getATN());
        ATN deserialized = new ATNDeserializer().deserialize(serializedAtn);
        parser = new ParserInterpreter(originalParser.getGrammarFileName(), originalParser.getVocabulary(), Arrays.asList(originalParser.getRuleNames()), deserialized, tokens);
    }
    parser.setInputStream(tokens);
    // Make sure that we don't get any error messages from using this temporary parser
    parser.setErrorHandler(new BailErrorStrategy());
    parser.removeErrorListeners();
    parser.removeParseListeners();
    parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);
    // get ambig trees
    int alt = alts.nextSetBit(0);
    while (alt >= 0) {
        // re-parse entire input for all ambiguous alternatives
        // (don't have to do first as it's been parsed, but do again for simplicity
        // using this temp parser.)
        parser.reset();
        // rewind the input all the way for re-parsing
        parser.getTokenStream().seek(0);
        parser.addDecisionOverride(decision, startIndex, alt);
        ParserRuleContext t = parser.parse(startRuleIndex);
        GrammarInterpreterRuleContext ambigSubTree = (GrammarInterpreterRuleContext) Trees.getRootOfSubtreeEnclosingRegion(t, startIndex, stopIndex);
        // Use higher of overridden decision tree or tree enclosing all tokens
        if (Trees.isAncestorOf(parser.getOverrideDecisionRoot(), ambigSubTree)) {
            ambigSubTree = (GrammarInterpreterRuleContext) parser.getOverrideDecisionRoot();
        }
        trees.add(ambigSubTree);
        alt = alts.nextSetBit(alt + 1);
    }
    return trees;
}||||||||/**
 * Given an ambiguous parse information, return the list of ambiguous parse trees.
 * An ambiguity occurs when a specific token sequence can be recognized
 * in more than one way by the grammar. These ambiguities are detected only
 * at decision points.
 *
 * The list of trees includes the actual interpretation (that for
 * the minimum alternative number) and all ambiguous alternatives.
 * The actual interpretation is always first.
 *
 * This method reuses the same physical input token stream used to
 * detect the ambiguity by the original parser in the first place.
 * This method resets/seeks within but does not alter originalParser.
 *
 * The trees are rooted at the node whose start..stop token indices
 * include the start and stop indices of this ambiguity event. That is,
 * the trees returned will always include the complete ambiguous subphrase
 * identified by the ambiguity event.  The subtrees returned will
 * also always contain the node associated with the overridden decision.
 *
 * Be aware that this method does NOT notify error or parse listeners as
 * it would trigger duplicate or otherwise unwanted events.
 *
 * This uses a temporary ParserATNSimulator and a ParserInterpreter
 * so we don't mess up any statistics, event lists, etc...
 * The parse tree constructed while identifying/making ambiguityInfo is
 * not affected by this method as it creates a new parser interp to
 * get the ambiguous interpretations.
 *
 * Nodes in the returned ambig trees are independent of the original parse
 * tree (constructed while identifying/creating ambiguityInfo).
 *
 * @since 4.5.1
 *
 * @param g              From which grammar should we drive alternative
 * numbers and alternative labels.
 *
 * @param originalParser The parser used to create ambiguityInfo; it
 * is not modified by this routine and can be either
 * a generated or interpreted parser. It's token
 * stream *is* reset/seek()'d.
 * @param tokens		  A stream of tokens to use with the temporary parser.
 * This will often be just the token stream within the
 * original parser but here it is for flexibility.
 *
 * @param decision       Which decision to try different alternatives for.
 *
 * @param alts           The set of alternatives to try while re-parsing.
 *
 * @param startIndex	  The index of the first token of the ambiguous
 * input or other input of interest.
 *
 * @param stopIndex      The index of the last token of the ambiguous input.
 * The start and stop indexes are used primarily to
 * identify how much of the resulting parse tree
 * to return.
 *
 * @param startRuleIndex The start rule for the entire grammar, not
 * the ambiguous decision. We re-parse the entire input
 * and so we need the original start rule.
 *
 * @return               The list of all possible interpretations of
 * the input for the decision in ambiguityInfo.
 * The actual interpretation chosen by the parser
 * is always given first because this method
 * retests the input in alternative order and
 * ANTLR always resolves ambiguities by choosing
 * the first alternative that matches the input.
 * The subtree returned
 *
 * @throws RecognitionException Throws upon syntax error while matching
 * ambig input.
 */
public static List<ParserRuleContext> getAllPossibleParseTrees(Grammar g, Parser originalParser, TokenStream tokens, int decision, BitSet alts, int startIndex, int stopIndex, int startRuleIndex) throws RecognitionException {
    List<ParserRuleContext> trees = new ArrayList<ParserRuleContext>();
    // Create a new parser interpreter to parse the ambiguous subphrase
    ParserInterpreter parser = getAmbuityParserInterpreter(g, originalParser, tokens);
    // get ambig trees
    int alt = alts.nextSetBit(0);
    while (alt >= 0) {
        // re-parse entire input for all ambiguous alternatives
        // (don't have to do first as it's been parsed, but do again for simplicity
        // using this temp parser.)
        parser.reset();
        // rewind the input all the way for re-parsing
        parser.getTokenStream().seek(0);
        parser.addDecisionOverride(decision, startIndex, alt);
        ParserRuleContext t = parser.parse(startRuleIndex);
        GrammarInterpreterRuleContext ambigSubTree = (GrammarInterpreterRuleContext) Trees.getRootOfSubtreeEnclosingRegion(t, startIndex, stopIndex);
        // Use higher of overridden decision tree or tree enclosing all tokens
        if (Trees.isAncestorOf(parser.getOverrideDecisionRoot(), ambigSubTree)) {
            ambigSubTree = (GrammarInterpreterRuleContext) parser.getOverrideDecisionRoot();
        }
        trees.add(ambigSubTree);
        alt = alts.nextSetBit(alt + 1);
    }
    return trees;
}||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(ObjectCreationExpr
						(ClassOrInterfaceType
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
			LineComment
		)
		(IfStmt
			(InstanceOfExpr
				NameExpr
					SimpleName
				(ClassOrInterfaceType
					SimpleName
				)
			)
			(BlockStmt
				(ExpressionStmt
					(VariableDeclarationExpr
						(VariableDeclarator
							(MethodCallExpr
								(MethodCallExpr
									SimpleName
									NameExpr
										SimpleName
								)
								SimpleName
								NameExpr
									SimpleName
							)
							SimpleName
							(ArrayType
								(PrimitiveType
								)
							)
						)
					)
					LineComment
				)
				(ExpressionStmt
					(VariableDeclarationExpr
						(VariableDeclarator
							(MethodCallExpr
								NameExpr
									SimpleName
								SimpleName
								(ObjectCreationExpr
									(ClassOrInterfaceType
										SimpleName
									)
								)
							)
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
				(ExpressionStmt
					(AssignExpr
						NameExpr
							SimpleName
						(ObjectCreationExpr
							(MethodCallExpr
								SimpleName
								NameExpr
									SimpleName
							)
							(MethodCallExpr
								SimpleName
								NameExpr
									SimpleName
							)
							(MethodCallExpr
								(MethodCallExpr
									SimpleName
									NameExpr
										SimpleName
								)
								SimpleName
								NameExpr
									SimpleName
							)
							NameExpr
								SimpleName
							NameExpr
								SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
			)
			(BlockStmt
				(ExpressionStmt
					(AssignExpr
						NameExpr
							SimpleName
						(ObjectCreationExpr
							NameExpr
								SimpleName
							(MethodCallExpr
								SimpleName
								NameExpr
									SimpleName
							)
							(MethodCallExpr
								SimpleName
								NameExpr
									SimpleName
							)
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				NameExpr
					SimpleName
				SimpleName
				NameExpr
					SimpleName
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				(ObjectCreationExpr
					(ClassOrInterfaceType
						SimpleName
					)
				)
				SimpleName
				NameExpr
					SimpleName
			)
			LineComment
		)
		(ExpressionStmt
			(MethodCallExpr
				SimpleName
				NameExpr
					SimpleName
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				SimpleName
				NameExpr
					SimpleName
			)
		)
		(ExpressionStmt
			(MethodCallExpr
				(FieldAccessExpr
					SimpleName
					NameExpr
						SimpleName
				)
				SimpleName
				(MethodCallExpr
					SimpleName
					NameExpr
						SimpleName
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						(IntegerLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
					SimpleName
					(PrimitiveType
					)
				)
			)
			LineComment
		)
		(WhileStmt
			(BlockStmt
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						(IntegerLiteralExpr
						)
						SimpleName
						(MethodCallExpr
							SimpleName
							NameExpr
								SimpleName
						)
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
				(ExpressionStmt
					(VariableDeclarationExpr
						(VariableDeclarator
							(MethodCallExpr
								NameExpr
									SimpleName
								SimpleName
								NameExpr
									SimpleName
							)
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
				(ExpressionStmt
					(VariableDeclarationExpr
						(VariableDeclarator
							(CastExpr
								(MethodCallExpr
									NameExpr
										SimpleName
									NameExpr
										SimpleName
									NameExpr
										SimpleName
									SimpleName
									NameExpr
										SimpleName
								)
								(ClassOrInterfaceType
									SimpleName
								)
							)
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
				(IfStmt
					(MethodCallExpr
						(MethodCallExpr
							SimpleName
							NameExpr
								SimpleName
						)
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
					(BlockStmt
						(ExpressionStmt
							(AssignExpr
								NameExpr
									SimpleName
								(CastExpr
									(MethodCallExpr
										SimpleName
										NameExpr
											SimpleName
									)
									(ClassOrInterfaceType
										SimpleName
									)
								)
							)
						)
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
				(ExpressionStmt
					(AssignExpr
						NameExpr
							SimpleName
						(MethodCallExpr
							(BinaryExpr
								NameExpr
									SimpleName
								(IntegerLiteralExpr
								)
							)
							SimpleName
							NameExpr
								SimpleName
						)
					)
				)
			)
			(BinaryExpr
				NameExpr
					SimpleName
				(IntegerLiteralExpr
				)
			)
		)
		(ReturnStmt
			NameExpr
				SimpleName
		)
	)
	(ClassOrInterfaceType
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	(JavadocComment
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(ObjectCreationExpr
						(ClassOrInterfaceType
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
			LineComment
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						(IntegerLiteralExpr
						)
						SimpleName
						NameExpr
							SimpleName
					)
					SimpleName
					(PrimitiveType
					)
				)
			)
			LineComment
		)
		(WhileStmt
			(BlockStmt
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						(IntegerLiteralExpr
						)
						SimpleName
						(MethodCallExpr
							SimpleName
							NameExpr
								SimpleName
						)
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
				(ExpressionStmt
					(VariableDeclarationExpr
						(VariableDeclarator
							(MethodCallExpr
								NameExpr
									SimpleName
								SimpleName
								NameExpr
									SimpleName
							)
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
				(ExpressionStmt
					(VariableDeclarationExpr
						(VariableDeclarator
							(CastExpr
								(MethodCallExpr
									NameExpr
										SimpleName
									NameExpr
										SimpleName
									NameExpr
										SimpleName
									SimpleName
									NameExpr
										SimpleName
								)
								(ClassOrInterfaceType
									SimpleName
								)
							)
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
				(IfStmt
					(MethodCallExpr
						(MethodCallExpr
							SimpleName
							NameExpr
								SimpleName
						)
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
					(BlockStmt
						(ExpressionStmt
							(AssignExpr
								NameExpr
									SimpleName
								(CastExpr
									(MethodCallExpr
										SimpleName
										NameExpr
											SimpleName
									)
									(ClassOrInterfaceType
										SimpleName
									)
								)
							)
						)
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
				(ExpressionStmt
					(AssignExpr
						NameExpr
							SimpleName
						(MethodCallExpr
							(BinaryExpr
								NameExpr
									SimpleName
								(IntegerLiteralExpr
								)
							)
							SimpleName
							NameExpr
								SimpleName
						)
					)
				)
			)
			(BinaryExpr
				NameExpr
					SimpleName
				(IntegerLiteralExpr
				)
			)
		)
		(ReturnStmt
			NameExpr
				SimpleName
		)
	)
	(ClassOrInterfaceType
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	(JavadocComment
	)
)

