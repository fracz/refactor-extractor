/**
 * Attempt to recover from a single missing or extra token.
 *
 * EXTRA TOKEN
 *
 * LA(1) is not what we are looking for.  If LA(2) has the right token,
 * however, then assume LA(1) is some extra spurious token.  Delete it
 * and LA(2) as if we were doing a normal match(), which advances the
 * input.
 *
 * MISSING TOKEN
 *
 * If current token is consistent with what could come after
 * ttype then it is ok to "insert" the missing token, else throw
 * exception For example, Input "i=(3;" is clearly missing the
 * ')'.  When the parser returns from the nested call to expr, it
 * will have call chain:
 *
 * stat -> expr -> atom
 *
 * and it will be trying to match the ')' at this point in the
 * derivation:
 *
 * => ID '=' '(' INT ')' ('+' atom)* ';'
 * ^
 * match() will see that ';' doesn't match ')' and report a
 * mismatched token error.  To recover, it sees that LA(1)==';'
 * is in the set of tokens that can follow the ')' token
 * reference in rule atom.  It can assume that you forgot the ')'.
 */
@Override
public Object recoverInline(BaseRecognizer recognizer) throws RecognitionException {
    Object currentSymbol = recognizer.getCurrentInputSymbol();
    // SINGLE TOKEN DELETION
    // if next token is what we are looking for then "delete" this token
    int nextTokenType = recognizer.getInputStream().LA(2);
    IntervalSet expecting = getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
        reportUnwantedToken(recognizer);
        /*
			System.err.println("recoverFromMismatchedToken deleting "+
							   ((TokenStream)recognizer.getInputStream()).LT(1)+
							   " since "+((TokenStream)recognizer.getInputStream()).LT(2)+
							   " is what we want");
			*/
        // simply delete extra token
        recognizer.consume();
        // recognizer.getInputStream().consume(); // simply delete extra token
        // we want to return the token we're actually matching
        Object matchedSymbol = recognizer.getCurrentInputSymbol();
        // we know next token is correct
        endErrorCondition(recognizer);
        // move past ttype token as if all were ok
        recognizer.consume();
        // recognizer.getInputStream().consume(); // move past ttype token as if all were ok
        return matchedSymbol;
    }
    // SINGLE TOKEN INSERTION
    // if current token is consistent with what could come after current
    // ATN state, then we know we're missing a token; error recovery
    // is free to conjure up and insert the missing token
    ATNState currentState = recognizer._interp.atn.states.get(recognizer._ctx.s);
    ATNState next = currentState.transition(0).target;
    IntervalSet expectingAtLL2 = recognizer._interp.atn.nextTokens(next, recognizer._ctx);
    // System.out.println("LT(2) set="+expectingAtLL2.toString(recognizer.getTokenNames()));
    if (expectingAtLL2.contains(((Token) currentSymbol).getType())) {
        reportMissingToken(recognizer);
        return getMissingSymbol(recognizer);
    }
    // even that didn't work; must throw the exception
    throw new InputMismatchException(recognizer);
}||||||||/**
 * Attempt to recover from a single missing or extra token.
 *
 * EXTRA TOKEN
 *
 * LA(1) is not what we are looking for.  If LA(2) has the right token,
 * however, then assume LA(1) is some extra spurious token.  Delete it
 * and LA(2) as if we were doing a normal match(), which advances the
 * input.
 *
 * MISSING TOKEN
 *
 * If current token is consistent with what could come after
 * ttype then it is ok to "insert" the missing token, else throw
 * exception For example, Input "i=(3;" is clearly missing the
 * ')'.  When the parser returns from the nested call to expr, it
 * will have call chain:
 *
 * stat -> expr -> atom
 *
 * and it will be trying to match the ')' at this point in the
 * derivation:
 *
 * => ID '=' '(' INT ')' ('+' atom)* ';'
 * ^
 * match() will see that ';' doesn't match ')' and report a
 * mismatched token error.  To recover, it sees that LA(1)==';'
 * is in the set of tokens that can follow the ')' token
 * reference in rule atom.  It can assume that you forgot the ')'.
 */
@Override
public Object recoverInline(BaseRecognizer recognizer) throws RecognitionException {
    // if next token is what we are looking for then "delete" this token
    // int nextTokenType = recognizer.getInputStream().LA(2);
    // IntervalSet expecting = getExpectedTokens(recognizer);
    // if ( expecting.contains(nextTokenType) ) {
    // reportUnwantedToken(recognizer);
    // /*
    // System.err.println("recoverFromMismatchedToken deleting "+
    // ((TokenStream)recognizer.getInputStream()).LT(1)+
    // " since "+((TokenStream)recognizer.getInputStream()).LT(2)+
    // " is what we want");
    // */
    // recognizer.consume(); // simply delete extra token
    // // we want to return the token we're actually matching
    // Object matchedSymbol = recognizer.getCurrentInputSymbol();
    // endErrorCondition(recognizer);  // we know next token is correct
    // recognizer.consume(); // move past ttype token as if all were ok
    // return matchedSymbol;
    // }
    // SINGLE TOKEN DELETION
    Object matchedSymbol = singleTokenDeletion(recognizer);
    if (matchedSymbol != null)
        return matchedSymbol;
    // SINGLE TOKEN INSERTION
    if (singleTokenInsertion(recognizer)) {
        return getMissingSymbol(recognizer);
    }
    // even that didn't work; must throw the exception
    throw new InputMismatchException(recognizer);
}||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						(IntegerLiteralExpr
						)
						SimpleName
						(MethodCallExpr
							SimpleName
							NameExpr
								SimpleName
						)
					)
					SimpleName
					(PrimitiveType
					)
				)
			)
			LineComment
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
		)
		(IfStmt
			(MethodCallExpr
				NameExpr
					SimpleName
				SimpleName
				NameExpr
					SimpleName
			)
			(BlockStmt
				(ExpressionStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
				)
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
					LineComment
				)
				(ExpressionStmt
					(VariableDeclarationExpr
						(VariableDeclarator
							(MethodCallExpr
								SimpleName
								NameExpr
									SimpleName
							)
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
					LineComment
				)
				(ExpressionStmt
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
					LineComment
				)
				(ReturnStmt
					NameExpr
						SimpleName
					LineComment
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						(FieldAccessExpr
							SimpleName
							(FieldAccessExpr
								SimpleName
								NameExpr
									SimpleName
							)
						)
						SimpleName
						(FieldAccessExpr
							SimpleName
							(FieldAccessExpr
								SimpleName
								(FieldAccessExpr
									SimpleName
									NameExpr
										SimpleName
								)
							)
						)
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
			LineComment
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(FieldAccessExpr
						SimpleName
						(MethodCallExpr
							(IntegerLiteralExpr
							)
							SimpleName
							NameExpr
								SimpleName
						)
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						NameExpr
							SimpleName
						(FieldAccessExpr
							SimpleName
							NameExpr
								SimpleName
						)
						SimpleName
						(FieldAccessExpr
							SimpleName
							(FieldAccessExpr
								SimpleName
								NameExpr
									SimpleName
							)
						)
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
		)
		(IfStmt
			(MethodCallExpr
				(MethodCallExpr
					SimpleName
					(EnclosedExpr
						(CastExpr
							NameExpr
								SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
						)
					)
				)
				SimpleName
				NameExpr
					SimpleName
			)
			(BlockStmt
				(ExpressionStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
				)
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
				)
			)
			LineComment
		)
		(ThrowStmt
			(ObjectCreationExpr
				NameExpr
					SimpleName
				(ClassOrInterfaceType
					SimpleName
				)
			)
			LineComment
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	(MarkerAnnotationExpr
		Name
	)
	(JavadocComment
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
			LineComment
		)
		(IfStmt
			(BinaryExpr
				NameExpr
					SimpleName
				NullLiteralExpr
			)
			(ReturnStmt
				NameExpr
					SimpleName
			)
		)
		(IfStmt
			(MethodCallExpr
				NameExpr
					SimpleName
				SimpleName
			)
			(BlockStmt
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
				)
			)
			LineComment
		)
		(ThrowStmt
			(ObjectCreationExpr
				NameExpr
					SimpleName
				(ClassOrInterfaceType
					SimpleName
				)
			)
			LineComment
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	(MarkerAnnotationExpr
		Name
	)
	(JavadocComment
	)
)

