/**
 * Extracts terms and ranges from the provided query. These terms and ranges are stored with the percolator query and
 * used by the percolate query's candidate query as fields to be query by. The candidate query
 * holds the terms from the document to be percolated and allows to the percolate query to ignore
 * percolator queries that we know would otherwise never match.
 *
 * <p>
 * When extracting the terms for the specified query, we can also determine if the percolator query is
 * always going to match. For example if a percolator query just contains a term query or a disjunction
 * query then when the candidate query matches with that, we know the entire percolator query always
 * matches. This allows the percolate query to skip the expensive memory index verification step that
 * it would otherwise have to execute (for example when a percolator query contains a phrase query or a
 * conjunction query).
 *
 * <p>
 * The query analyzer doesn't always extract all terms from the specified query. For example from a
 * boolean query with no should clauses or phrase queries only the longest term are selected,
 * since that those terms are likely to be the rarest. Boolean query's must_not clauses are always ignored.
 *
 * <p>
 * Sometimes the query analyzer can't always extract terms or ranges from a sub query, if that happens then
 * query analysis is stopped and an UnsupportedQueryException is thrown. So that the caller can mark
 * this query in such a way that the PercolatorQuery always verifies if this query with the MemoryIndex.
 */
static Result analyze(Query query, Map<String, Float> boosts) {
    Class queryClass = query.getClass();
    if (queryClass.isAnonymousClass()) {
        // Sometimes queries have anonymous classes in that case we need the direct super class.
        // (for example blended term query)
        queryClass = queryClass.getSuperclass();
    }
    BiFunction<Query, Map<String, Float>, Result> queryProcessor = queryProcessors.get(queryClass);
    if (queryProcessor != null) {
        return queryProcessor.apply(query, boosts);
    } else {
        throw new UnsupportedQueryException(query);
    }
}||||||||/**
 * Extracts terms and ranges from the provided query. These terms and ranges are stored with the percolator query and
 * used by the percolate query's candidate query as fields to be query by. The candidate query
 * holds the terms from the document to be percolated and allows to the percolate query to ignore
 * percolator queries that we know would otherwise never match.
 *
 * <p>
 * When extracting the terms for the specified query, we can also determine if the percolator query is
 * always going to match. For example if a percolator query just contains a term query or a disjunction
 * query then when the candidate query matches with that, we know the entire percolator query always
 * matches. This allows the percolate query to skip the expensive memory index verification step that
 * it would otherwise have to execute (for example when a percolator query contains a phrase query or a
 * conjunction query).
 *
 * <p>
 * The query analyzer doesn't always extract all terms from the specified query. For example from a
 * boolean query with no should clauses or phrase queries only the longest term are selected,
 * since that those terms are likely to be the rarest. Boolean query's must_not clauses are always ignored.
 *
 * <p>
 * Sometimes the query analyzer can't always extract terms or ranges from a sub query, if that happens then
 * query analysis is stopped and an UnsupportedQueryException is thrown. So that the caller can mark
 * this query in such a way that the PercolatorQuery always verifies if this query with the MemoryIndex.
 *
 * @param query         The query to analyze.
 * @param indexVersion  The create version of the index containing the percolator queries.
 */
static Result analyze(Query query, Version indexVersion) {
    Class queryClass = query.getClass();
    if (queryClass.isAnonymousClass()) {
        // Sometimes queries have anonymous classes in that case we need the direct super class.
        // (for example blended term query)
        queryClass = queryClass.getSuperclass();
    }
    BiFunction<Query, Version, Result> queryProcessor = queryProcessors.get(queryClass);
    if (queryProcessor != null) {
        return queryProcessor.apply(query, indexVersion);
    } else {
        throw new UnsupportedQueryException(query);
    }
}||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
		)
		(IfStmt
			(MethodCallExpr
				SimpleName
				NameExpr
					SimpleName
			)
			(BlockStmt
				(ExpressionStmt
					(AssignExpr
						NameExpr
							SimpleName
						(MethodCallExpr
							SimpleName
							NameExpr
								SimpleName
						)
					)
					LineComment
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
						(ClassOrInterfaceType
							SimpleName
							(ClassOrInterfaceType
								SimpleName
							)
							(ClassOrInterfaceType
								SimpleName
							)
						)
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
		)
		(IfStmt
			(BinaryExpr
				NameExpr
					SimpleName
				NullLiteralExpr
			)
			(BlockStmt
				(ThrowStmt
					(ObjectCreationExpr
						NameExpr
							SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
			(BlockStmt
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(ClassOrInterfaceType
				SimpleName
			)
			(ClassOrInterfaceType
				SimpleName
			)
		)
	)
	(JavadocComment
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						SimpleName
						NameExpr
							SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
		)
		(IfStmt
			(MethodCallExpr
				SimpleName
				NameExpr
					SimpleName
			)
			(BlockStmt
				(ExpressionStmt
					(AssignExpr
						NameExpr
							SimpleName
						(MethodCallExpr
							SimpleName
							NameExpr
								SimpleName
						)
					)
					LineComment
				)
			)
		)
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
						(ClassOrInterfaceType
							SimpleName
						)
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
		)
		(IfStmt
			(BinaryExpr
				NameExpr
					SimpleName
				NullLiteralExpr
			)
			(BlockStmt
				(ThrowStmt
					(ObjectCreationExpr
						NameExpr
							SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
			(BlockStmt
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(JavadocComment
	)
)

