/**
 * Builds a map that supports atomic, on-demand computation of values. {@link
 * Map#get} either returns an already-computed value for the given key,
 * atomically computes it using the supplied function, or, if another thread
 * is currently computing the value for this key, simply waits for that thread
 * to finish and returns its computed value. Note that the function may be
 * executed concurrently by multiple threads, but only for distinct keys.
 *
 * <p>If an entry's value has not finished computing yet, query methods
 * besides {@code get} return immediately as if an entry doesn't exist. In
 * other words, an entry isn't externally visible until the value's
 * computation completes.
 *
 * <p>{@link Map#get} on the returned map will never return {@code null}. It
 * may throw:
 *
 * <ul>
 * <li>{@link NullPointerException} if the key is null or the computing
 * function returns null
 * <li>{@link ComputationException} if an exception was thrown by the
 * computing function. If that exception is already of type {@link
 * ComputationException}, it is propagated directly; otherwise it is
 * wrapped.
 * </ul>
 *
 * <p><b>Note:</b> Callers of {@code get} <i>must</i> ensure that the key
 * argument is of type {@code K}. The {@code get} method accepts {@code
 * Object}, so the key type is not checked at compile time. Passing an object
 * of a type other than {@code K} can result in that object being unsafely
 * passed to the computing function as type {@code K}, and unsafely stored in
 * the map.
 *
 * <p>If {@link Map#put} is called before a computation completes, other
 * threads waiting on the computation will wake up and return the stored
 * value. When the computation completes, its new result will overwrite the
 * value that was put in the map manually.
 *
 * <p>This method does not alter the state of this {@code MapMaker} instance,
 * so it can be invoked again to create multiple independent maps.
 */
public <K, V> ConcurrentMap<K, V> makeComputingMap(Function<? super K, ? extends V> computingFunction) {
    return new StrategyImpl<K, V>(this, computingFunction).map;
}||||||||/**
 * Builds a map that supports atomic, on-demand computation of values. {@link
 * Map#get} either returns an already-computed value for the given key,
 * atomically computes it using the supplied function, or, if another thread
 * is currently computing the value for this key, simply waits for that thread
 * to finish and returns its computed value. Note that the function may be
 * executed concurrently by multiple threads, but only for distinct keys.
 *
 * <p>If an entry's value has not finished computing yet, query methods
 * besides {@code get} return immediately as if an entry doesn't exist. In
 * other words, an entry isn't externally visible until the value's
 * computation completes.
 *
 * <p>{@link Map#get} on the returned map will never return {@code null}. It
 * may throw:
 *
 * <ul>
 * <li>{@link NullPointerException} if the key is null or the computing
 * function returns null
 * <li>{@link ComputationException} if an exception was thrown by the
 * computing function. If that exception is already of type {@link
 * ComputationException} it is propagated directly; otherwise it is
 * wrapped.
 * </ul>
 *
 * <p><b>Note:</b> Callers of {@code get} <i>must</i> ensure that the key
 * argument is of type {@code K}. The {@code get} method accepts {@code
 * Object}, so the key type is not checked at compile time. Passing an object
 * of a type other than {@code K} can result in that object being unsafely
 * passed to the computing function as type {@code K}, and unsafely stored in
 * the map.
 *
 * <p>If {@link Map#put} is called before a computation completes, other
 * threads waiting on the computation will wake up and return the stored
 * value. When the computation completes, its new result will overwrite the
 * value that was put in the map manually.
 *
 * <p>This method does not alter the state of this {@code MapMaker} instance,
 * so it can be invoked again to create multiple independent maps.
 */
public <K, V> ConcurrentMap<K, V> makeComputingMap(Function<? super K, ? extends V> computingFunction) {
    Cache<K, V> cache = makeCache(computingFunction);
    return new ComputingMapAdapter<K, V>(cache);
}||||||||(MethodDeclaration
	(BlockStmt
		(ReturnStmt
			(FieldAccessExpr
				SimpleName
				(ObjectCreationExpr
					(ThisExpr
					)
					NameExpr
						SimpleName
					(ClassOrInterfaceType
						SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
		)
	)
	(ClassOrInterfaceType
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
		(ClassOrInterfaceType
			SimpleName
		)
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(WildcardType
				(ClassOrInterfaceType
					SimpleName
				)
			)
			(WildcardType
				(ClassOrInterfaceType
					SimpleName
				)
			)
		)
	)
	(TypeParameter
		SimpleName
	)
	(TypeParameter
		SimpleName
	)
	(JavadocComment
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(ExpressionStmt
			(VariableDeclarationExpr
				(VariableDeclarator
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
					)
					SimpleName
					(ClassOrInterfaceType
						SimpleName
						(ClassOrInterfaceType
							SimpleName
						)
						(ClassOrInterfaceType
							SimpleName
						)
					)
				)
			)
		)
		(ReturnStmt
			(ObjectCreationExpr
				NameExpr
					SimpleName
				(ClassOrInterfaceType
					SimpleName
					(ClassOrInterfaceType
						SimpleName
					)
					(ClassOrInterfaceType
						SimpleName
					)
				)
			)
		)
	)
	(ClassOrInterfaceType
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
		(ClassOrInterfaceType
			SimpleName
		)
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(WildcardType
				(ClassOrInterfaceType
					SimpleName
				)
			)
			(WildcardType
				(ClassOrInterfaceType
					SimpleName
				)
			)
		)
	)
	(TypeParameter
		SimpleName
	)
	(TypeParameter
		SimpleName
	)
	(JavadocComment
	)
)

