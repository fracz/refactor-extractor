// @Override
// public Long getFirstCommittedTxId( long version )
// {
// if ( version == 0 )
// {
// return 1L;
// }
// 
// // First committed tx for version V = last committed tx version V-1 + 1
// Long header = positionCache.getHeader( version - 1 );
// if ( header != null )
// // It existed in cache
// {
// return header + 1;
// }
// 
// // Wasn't cached, go look for it
// synchronized ( this )
// {
// if ( version > logVersion )
// {
// throw new IllegalArgumentException( "Too high version " + version + ", active is " + logVersion );
// }
// else if ( version == logVersion )
// {
// throw new IllegalArgumentException( "Last committed tx for the active log isn't determined yet" );
// }
// else if ( version == logVersion - 1 )
// {
// return previousLogLastCommittedTx;
// }
// else
// {
// File file = getFileName( version );
// if ( fileSystem.fileExists( file ) )
// {
// try
// {
// long[] headerLongs = VersionAwareLogEntryReader.readLogHeader( fileSystem, file );
// return headerLongs[1] + 1;
// }
// catch ( IOException e )
// {
// throw new RuntimeException( e );
// }
// }
// }
// }
// return null;
// }
// 
// 
// @Override
// public Long getFirstStartRecordTimestamp( long version ) throws IOException
// {
// ReadableByteChannel log = null;
// try
// {
// ByteBuffer buffer = LogExtractor.newLogReaderBuffer();
// log = getLogicalLog( version );
// VersionAwareLogEntryReader.readLogHeader( buffer, log, true );
// LogDeserializer deserializer = new LogDeserializer( buffer, commandReaderFactory );
// 
// TimeWrittenConsumer consumer = new TimeWrittenConsumer();
// 
// try ( Cursor<LogEntry, IOException> cursor = deserializer.cursor( log ) )
// {
// while( cursor.next( consumer ) )
// {
// ;
// }
// }
// return consumer.getTimeWritten();
// }
// finally
// {
// if ( log != null )
// {
// log.close();
// }
// }
// }
// 
@Override
public WritableLogChannel getWriter() {
    return writer;
}||||||||// @Override
// public Long getFirstCommittedTxId( long version )
// {
// if ( version == 0 )
// {
// return 1L;
// }
// 
// // First committed tx for version V = last committed tx version V-1 + 1
// Long header = positionCache.getHeader( version - 1 );
// if ( header != null )
// // It existed in cache
// {
// return header + 1;
// }
// 
// // Wasn't cached, go look for it
// synchronized ( this )
// {
// if ( version > logVersion )
// {
// throw new IllegalArgumentException( "Too high version " + version + ", active is " + logVersion );
// }
// else if ( version == logVersion )
// {
// throw new IllegalArgumentException( "Last committed tx for the active log isn't determined yet" );
// }
// else if ( version == logVersion - 1 )
// {
// return previousLogLastCommittedTx;
// }
// else
// {
// File file = getFileName( version );
// if ( fileSystem.fileExists( file ) )
// {
// try
// {
// long[] headerLongs = VersionAwareLogEntryReader.readLogHeader( fileSystem, file );
// return headerLongs[1] + 1;
// }
// catch ( IOException e )
// {
// throw new RuntimeException( e );
// }
// }
// }
// }
// return null;
// }
// 
// 
// @Override
// public Long getFirstStartRecordTimestamp( long version ) throws IOException
// {
// ReadableByteChannel log = null;
// try
// {
// ByteBuffer buffer = LogExtractor.newLogReaderBuffer();
// log = getLogicalLog( version );
// VersionAwareLogEntryReader.readLogHeader( buffer, log, true );
// LogDeserializer deserializer = new LogDeserializer( buffer, commandReaderFactory );
// 
// TimeWrittenConsumer consumer = new TimeWrittenConsumer();
// 
// try ( Cursor<LogEntry, IOException> cursor = deserializer.cursor( log ) )
// {
// while( cursor.next( consumer ) )
// {
// ;
// }
// }
// return consumer.getTimeWritten();
// }
// finally
// {
// if ( log != null )
// {
// log.close();
// }
// }
// }
// 
@Override
public WritableLogChannel getWriter() {
    return writer;
}||||||||(MethodDeclaration
	(BlockStmt
		(ReturnStmt
			NameExpr
				SimpleName
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	SimpleName
	(MarkerAnnotationExpr
		Name
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(ReturnStmt
			NameExpr
				SimpleName
		)
	)
	(ClassOrInterfaceType
		SimpleName
	)
	SimpleName
	(MarkerAnnotationExpr
		Name
	)
	LineComment
)

