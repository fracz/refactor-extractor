/**
 * Returns the same as <code>text.getSpans()</code>, except where
 * <code>start</code> and <code>end</code> are the same and are not
 * at the very beginning of the text, in which case an empty array
 * is returned instead.
 * <p>
 * This is needed because of the special case that <code>getSpans()</code>
 * on an empty range returns the spans adjacent to that range, which is
 * primarily for the sake of <code>TextWatchers</code> so they will get
 * notifications when text goes from empty to non-empty.  But it also
 * has the unfortunate side effect that if the text ends with an empty
 * paragraph, that paragraph accidentally picks up the styles of the
 * preceding paragraph (even though those styles will not be picked up
 * by new text that is inserted into the empty paragraph).
 * <p>
 * The reason it just checks whether <code>start</code> and <code>end</code>
 * is the same is that the only time a line can contain 0 characters
 * is if it is the final paragraph of the Layout; otherwise any line will
 * contain at least one printing or newline character.  The reason for the
 * additional check if <code>start</code> is greater than 0 is that
 * if the empty paragraph is the entire content of the buffer, paragraph
 * styles that are already applied to the buffer will apply to text that
 * is inserted into it.
 */
/* package */
static <T> T[] getParagraphSpans(Spanned text, int start, int end, Class<T> type) {
    if (start == end && start > 0) {
        return ArrayUtils.emptyArray(type);
    }
    return text.getSpans(start, end, type);
}||||||||/**
 * Returns the same as <code>text.getSpans()</code>, except where
 * <code>start</code> and <code>end</code> are the same and are not
 * at the very beginning of the text, in which case an empty array
 * is returned instead.
 * <p>
 * This is needed because of the special case that <code>getSpans()</code>
 * on an empty range returns the spans adjacent to that range, which is
 * primarily for the sake of <code>TextWatchers</code> so they will get
 * notifications when text goes from empty to non-empty.  But it also
 * has the unfortunate side effect that if the text ends with an empty
 * paragraph, that paragraph accidentally picks up the styles of the
 * preceding paragraph (even though those styles will not be picked up
 * by new text that is inserted into the empty paragraph).
 * <p>
 * The reason it just checks whether <code>start</code> and <code>end</code>
 * is the same is that the only time a line can contain 0 characters
 * is if it is the final paragraph of the Layout; otherwise any line will
 * contain at least one printing or newline character.  The reason for the
 * additional check if <code>start</code> is greater than 0 is that
 * if the empty paragraph is the entire content of the buffer, paragraph
 * styles that are already applied to the buffer will apply to text that
 * is inserted into it.
 */
/* package */
static <T> T[] getParagraphSpans(Spanned text, int start, int end, Class<T> type) {
    if (start == end && start > 0) {
        return ArrayUtils.emptyArray(type);
    }
    if (text instanceof SpannableStringBuilder) {
        return ((SpannableStringBuilder) text).getSpans(start, end, type, false);
    } else {
        return text.getSpans(start, end, type);
    }
}||||||||(MethodDeclaration
	(BlockStmt
		(IfStmt
			(BinaryExpr
				(BinaryExpr
					NameExpr
						SimpleName
					NameExpr
						SimpleName
				)
				(BinaryExpr
					NameExpr
						SimpleName
					(IntegerLiteralExpr
					)
				)
			)
			(BlockStmt
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
		)
		(ReturnStmt
			(MethodCallExpr
				NameExpr
					SimpleName
				NameExpr
					SimpleName
				NameExpr
					SimpleName
				SimpleName
				NameExpr
					SimpleName
			)
		)
	)
	(ArrayType
		(ClassOrInterfaceType
			SimpleName
		)
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(ClassOrInterfaceType
				SimpleName
			)
		)
	)
	(TypeParameter
		SimpleName
	)
	(BlockComment
	)
)
||||||||(MethodDeclaration
	(BlockStmt
		(IfStmt
			(BinaryExpr
				(BinaryExpr
					NameExpr
						SimpleName
					NameExpr
						SimpleName
				)
				(BinaryExpr
					NameExpr
						SimpleName
					(IntegerLiteralExpr
					)
				)
			)
			(BlockStmt
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
		)
		(IfStmt
			(InstanceOfExpr
				NameExpr
					SimpleName
				(ClassOrInterfaceType
					SimpleName
				)
			)
			(BlockStmt
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						SimpleName
						NameExpr
							SimpleName
					)
				)
			)
			(BlockStmt
				(ReturnStmt
					(MethodCallExpr
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						NameExpr
							SimpleName
						(BooleanLiteralExpr
						)
						SimpleName
						(EnclosedExpr
							(CastExpr
								NameExpr
									SimpleName
								(ClassOrInterfaceType
									SimpleName
								)
							)
						)
					)
				)
			)
		)
	)
	(ArrayType
		(ClassOrInterfaceType
			SimpleName
		)
	)
	SimpleName
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(PrimitiveType
		)
	)
	(Parameter
		SimpleName
		(ClassOrInterfaceType
			SimpleName
			(ClassOrInterfaceType
				SimpleName
			)
		)
	)
	(TypeParameter
		SimpleName
	)
	(BlockComment
	)
)

