    public function parse()
    {

        /**
         * Last parsed statement.
         * @var Statement
         */
        $lastStatement = null;

        /**
         * Whether a union is parsed or not.
         * @var bool
         */
        $inUnion = true;

        /**
         * The index of the last token from the last statement.
         * @var int
         */
        $prevLastIdx = -1;

        /**
         * The list of tokens.
         * @var TokensList
         */
        $list = &$this->list;

        for (; $list->idx < $list->count; ++$list->idx) {

            /**
             * Token parsed at this moment.
             * @var Token
             */
            $token = $list->tokens[$list->idx];

            // Statements can start with keywords only.
            // Comments, whitespaces, etc. are ignored.
            if ($token->type !== Token::TYPE_KEYWORD) {
                continue;
            }

            if ($token->value === 'UNION') {
                $inUnion = true;
                continue;
            }

            // Checking if it is a known statement that can be parsed.
            if (empty(static::$STATEMENT_PARSERS[$token->value])) {
                $this->error(
                    'Unrecognized statement type "' . $token->value . '".',
                    $token
                );
                // Skipping to the end of this statement.
                $list->getNextOfType(Token::TYPE_DELIMITER);
                //
                $prevLastIdx = $list->idx;
                continue;
            }

            /**
             * The name of the class that is used for parsing.
             * @var string
             */
            $class = static::$STATEMENT_PARSERS[$token->value];

            /**
             * Processed statement.
             * @var Statement
             */
            $stmt = new $class();

            // The first token that is a part of this token is the next token
            // unprocessed by the previous statement.
            // There might be brackets around statements and this shouldn't
            // affect the parser
            $stmt->first = $prevLastIdx + 1;

            // Parsing the actual statement.
            $stmt->parse($this, $this->list);

            // Storing the index of the last token parsed and updating the old
            // index.
            $stmt->last = $list->idx;
            $prevLastIdx = $list->idx;

            // Finally, storing the statement.
            if (($inUnion)
                && ($lastStatement instanceof SelectStatement)
                && ($stmt instanceof SelectStatement)
            ) {
                $lastStatement->union[] = $stmt;
                $inUnion = false;
            } else {
                $this->statements[] = $stmt;
                $lastStatement = $stmt;
            }

        }
    }

    /**
     * Creates a new error log.
     *
     * @param string $msg   The error message.
     * @param Token  $token The token that produced the error.
     * @param int    $code  The code of the error.
     *
     * @return void
     */
||||||||    public function parse()
    {

        /**
         * Last parsed statement.
         * @var Statement
         */
        $lastStatement = null;

        /**
         * Whether a union is parsed or not.
         * @var bool
         */
        $inUnion = true;

        /**
         * The index of the last token from the last statement.
         * @var int
         */
        $prevLastIdx = -1;

        /**
         * The list of tokens.
         * @var TokensList
         */
        $list = &$this->list;

        for (; $list->idx < $list->count; ++$list->idx) {

            /**
             * Token parsed at this moment.
             * @var Token
             */
            $token = $list->tokens[$list->idx];

            // Statements can start with keywords only.
            // Comments, whitespaces, etc. are ignored.
            if ($token->type !== Token::TYPE_KEYWORD) {
                continue;
            }

            if ($token->value === 'UNION') {
                $inUnion = true;
                continue;
            }

            // Checking if it is a known statement that can be parsed.
            if (empty(static::$STATEMENT_PARSERS[$token->value])) {
                $this->error(
                    'Unrecognized statement type "' . $token->value . '".',
                    $token
                );
                // Skipping to the end of this statement.
                $list->getNextOfType(Token::TYPE_DELIMITER);
                //
                $prevLastIdx = $list->idx;
                continue;
            }

            /**
             * The name of the class that is used for parsing.
             * @var string
             */
            $class = static::$STATEMENT_PARSERS[$token->value];

            /**
             * Processed statement.
             * @var Statement
             */
            $stmt = new $class();

            // Parsing the actual statement.
            $stmt->parse($this, $this->list);

            // The first token that is a part of this token is the next token
            // unprocessed by the previous statement.
            // There might be brackets around statements and this shouldn't
            // affect the parser
            $stmt->first = $prevLastIdx + 1;

            // Storing the index of the last token parsed and updating the old
            // index.
            $stmt->last = $list->idx;
            $prevLastIdx = $list->idx;

            // Finally, storing the statement.
            if (($inUnion)
                && ($lastStatement instanceof SelectStatement)
                && ($stmt instanceof SelectStatement)
            ) {
                $lastStatement->union[] = $stmt;
                $inUnion = false;
            } else {
                $this->statements[] = $stmt;
                $lastStatement = $stmt;
            }

        }
    }

    /**
     * Creates a new error log.
     *
     * @param string $msg   The error message.
     * @param Token  $token The token that produced the error.
     * @param int    $code  The code of the error.
     *
     * @return void
     */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONST))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONST))
    (AST_ASSIGN
        (AST_VAR)
        (AST_UNARY_OP
            (SCALAR)))
    (AST_ASSIGN_REF
        (AST_VAR)
        (AST_PROP
            (AST_VAR)))
    (AST_FOR
        (NULL)
        (AST_EXPR_LIST
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (AST_PROP
                    (AST_VAR))))
        (AST_EXPR_LIST
            (AST_PRE_INC
                (AST_PROP
                    (AST_VAR))))
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_PROP
                        (AST_VAR))))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_PROP
                            (AST_VAR))
                        (AST_CLASS_CONST
                            (SCALAR)))
                    (
                        (AST_CONTINUE
                            (NULL)))))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR))
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_CONST))
                        (AST_CONTINUE
                            (NULL)))))
            (AST_IF
                (AST_IF_ELEM
                    (AST_EMPTY
                        (AST_DIM
                            (AST_STATIC_PROP)
                            (AST_PROP
                                (AST_VAR))))
                    (
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (AST_BINARY_OP
                                    (AST_BINARY_OP
                                        (SCALAR)
                                        (AST_PROP
                                            (AST_VAR)))
                                    (SCALAR))
                                (AST_VAR)))
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (AST_CLASS_CONST
                                    (SCALAR))))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_PROP
                                (AST_VAR)))
                        (AST_CONTINUE
                            (NULL)))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_DIM
                    (AST_STATIC_PROP)
                    (AST_PROP
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (AST_VAR)))
            (AST_ASSIGN
                (AST_PROP
                    (AST_VAR))
                (AST_BINARY_OP
                    (AST_VAR)
                    (SCALAR)))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_PROP
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_PROP
                    (AST_VAR))
                (AST_PROP
                    (AST_VAR)))
            (AST_ASSIGN
                (AST_VAR)
                (AST_PROP
                    (AST_VAR)))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_BINARY_OP
                            (AST_VAR)
                            (AST_INSTANCEOF
                                (AST_VAR)))
                        (AST_INSTANCEOF
                            (AST_VAR)))
                    (
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_PROP
                                    (AST_VAR))
                                (NULL))
                            (AST_VAR))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_CONST))))
                (AST_IF_ELEM
                    (NULL)
                    (
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_PROP
                                    (AST_VAR))
                                (NULL))
                            (AST_VAR))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_VAR))))))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONST))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONST))
    (AST_ASSIGN
        (AST_VAR)
        (AST_UNARY_OP
            (SCALAR)))
    (AST_ASSIGN_REF
        (AST_VAR)
        (AST_PROP
            (AST_VAR)))
    (AST_FOR
        (NULL)
        (AST_EXPR_LIST
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (AST_PROP
                    (AST_VAR))))
        (AST_EXPR_LIST
            (AST_PRE_INC
                (AST_PROP
                    (AST_VAR))))
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_PROP
                        (AST_VAR))))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_PROP
                            (AST_VAR))
                        (AST_CLASS_CONST
                            (SCALAR)))
                    (
                        (AST_CONTINUE
                            (NULL)))))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR))
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_CONST))
                        (AST_CONTINUE
                            (NULL)))))
            (AST_IF
                (AST_IF_ELEM
                    (AST_EMPTY
                        (AST_DIM
                            (AST_STATIC_PROP)
                            (AST_PROP
                                (AST_VAR))))
                    (
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (AST_BINARY_OP
                                    (AST_BINARY_OP
                                        (SCALAR)
                                        (AST_PROP
                                            (AST_VAR)))
                                    (SCALAR))
                                (AST_VAR)))
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (AST_CLASS_CONST
                                    (SCALAR))))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_PROP
                                (AST_VAR)))
                        (AST_CONTINUE
                            (NULL)))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_DIM
                    (AST_STATIC_PROP)
                    (AST_PROP
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (AST_VAR)))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_PROP
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_PROP
                    (AST_VAR))
                (AST_BINARY_OP
                    (AST_VAR)
                    (SCALAR)))
            (AST_ASSIGN
                (AST_PROP
                    (AST_VAR))
                (AST_PROP
                    (AST_VAR)))
            (AST_ASSIGN
                (AST_VAR)
                (AST_PROP
                    (AST_VAR)))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_BINARY_OP
                            (AST_VAR)
                            (AST_INSTANCEOF
                                (AST_VAR)))
                        (AST_INSTANCEOF
                            (AST_VAR)))
                    (
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_PROP
                                    (AST_VAR))
                                (NULL))
                            (AST_VAR))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_CONST))))
                (AST_IF_ELEM
                    (NULL)
                    (
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_PROP
                                    (AST_VAR))
                                (NULL))
                            (AST_VAR))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_VAR))))))))