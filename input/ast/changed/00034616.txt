    function _out_key($pretty=false) {
        if($pretty){
            return str_replace(CM_KEYMARKER,"&raquo;",$this->_key);
        }else{
            return str_replace(CM_KEYMARKER,"']['",$this->_key);
        }
    }
  }
}

if (!class_exists('setting_string')) {
  class setting_string extends setting {
    function html(&$plugin, $echo=false) {
        $value = '';
        $disable = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = 'disabled="disabled"';
        } else {
          if ($echo && $this->_error) {
            $value = $this->_input;
          } else {
            $value = is_null($this->_local) ? $this->_default : $this->_local;
          }
        }

        $key = htmlspecialchars($this->_key);
        $value = htmlspecialchars($value);

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';
        $input = '<input id="config___'.$key.'" name="config['.$key.']" type="text" class="edit" value="'.$value.'" '.$disable.'/>';
        return array($label,$input);
    }
  }
}

if (!class_exists('setting_password')) {
  class setting_password extends setting_string {

    var $_code = 'plain';  // mechanism to be used to obscure passwords

    function update($input) {
        if ($this->is_protected()) return false;
        if (!$input) return false;

        if ($this->_pattern && !preg_match($this->_pattern,$input)) {
          $this->_error = true;
          $this->_input = $input;
          return false;
        }

        $this->_local = conf_encodeString($input,$this->_code);
        return true;
    }

    function html(&$plugin, $echo=false) {

        $value = '';
        $disable = $this->is_protected() ? 'disabled="disabled"' : '';

        $key = htmlspecialchars($this->_key);

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';
        $input = '<input id="config___'.$key.'" name="config['.$key.']" autocomplete="off" type="password" class="edit" value="" '.$disable.' />';
        return array($label,$input);
    }
  }
}

if (!class_exists('setting_email')) {
  class setting_email extends setting_string {
    var $_pattern = '#^\s*(([a-z0-9\-_.]+?)@([\w\-]+\.([\w\-\.]+\.)*[\w]+)(,\s*([a-z0-9\-_.]+?)@([\w\-]+\.([\w\-\.]+\.)*[\w]+))*)?\s*$#i';
  }
}

if (!class_exists('setting_richemail')) {
  class setting_richemail extends setting_email {

    /**
     *  update setting with user provided value $input
     *  if value fails error check, save it
     *
     *  @return true if changed, false otherwise (incl. on error)
     */
    function update($input) {
        if (is_null($input)) return false;
        if ($this->is_protected()) return false;

        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        // replace variables with pseudo values
        $test = $input;
        $test = str_replace('@USER@','joe',$test);
        $test = str_replace('@NAME@','Joe Schmoe',$test);
        $test = str_replace('@MAIL@','joe@example.com',$test);

        // now only check the address part
        if(preg_match('#(.*?)<(.*?)>#',$test,$matches)){
          $text = trim($matches[1]);
          $addr = $matches[2];
        }else{
          $addr = $test;
        }

        if ($this->_pattern && !preg_match($this->_pattern,$addr)) {
          $this->_error = true;
          $this->_input = $input;
          return false;
        }

        $this->_local = $input;
        return true;
    }

  }
}


if (!class_exists('setting_numeric')) {
  class setting_numeric extends setting_string {
    // This allows for many PHP syntax errors...
    // var $_pattern = '/^[-+\/*0-9 ]*$/';
    // much more restrictive, but should eliminate syntax errors.
    var $_pattern = '/^[-]?[0-9]+(?:[-+*][0-9]+)*$/';
    //FIXME - make the numeric error checking better.

    function out($var, $fmt='php') {

      if ($this->is_protected()) return '';
      if (is_null($this->_local) || ($this->_default == $this->_local)) return '';

      $out = '';

      if ($fmt=='php') {
        $out .=  '$'.$var."['".$this->_out_key()."'] = ".$this->_local.";\n";
      }

    return $out;
    }
  }
}

if (!class_exists('setting_numericopt')) {
    class setting_numericopt extends setting_numeric {
        // just allow an empty config
        var $_pattern = '/^(|[-]?[0-9]+(?:[-+*][0-9]+)*)$/';
    }
}

if (!class_exists('setting_onoff')) {
  class setting_onoff extends setting_numeric {

    function html(&$plugin) {
        $value = '';
        $disable = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = ' disabled="disabled"';
        } else {
          $value = is_null($this->_local) ? $this->_default : $this->_local;
        }

        $key = htmlspecialchars($this->_key);
        $checked = ($value) ? ' checked="checked"' : '';

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';
        $input = '<div class="input"><input id="config___'.$key.'" name="config['.$key.']" type="checkbox" class="checkbox" value="1"'.$checked.$disable.'/></div>';
        return array($label,$input);
    }

    function update($input) {
        if ($this->is_protected()) return false;

        $input = ($input) ? 1 : 0;
        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        $this->_local = $input;
        return true;
    }
  }
}

if (!class_exists('setting_multichoice')) {
  class setting_multichoice extends setting_string {
    var $_choices = array();

    function html(&$plugin) {
        $value = '';
        $disable = '';
        $nochoice = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = ' disabled="disabled"';
        } else {
          $value = is_null($this->_local) ? $this->_default : $this->_local;
        }

        // ensure current value is included
        if (!in_array($value, $this->_choices)) {
            $this->_choices[] = $value;
        }
        // disable if no other choices
        if (!$this->is_protected() && count($this->_choices) <= 1) {
          $disable = ' disabled="disabled"';
          $nochoice = $plugin->getLang('nochoice');
        }

        $key = htmlspecialchars($this->_key);

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';

        $input = "<div class=\"input\">\n";
        $input .= '<select class="edit" id="config___'.$key.'" name="config['.$key.']"'.$disable.'>'."\n";
        foreach ($this->_choices as $choice) {
            $selected = ($value == $choice) ? ' selected="selected"' : '';
            $option = $plugin->getLang($this->_key.'_o_'.$choice);
            if (!$option && isset($this->lang[$this->_key.'_o_'.$choice])) $option = $this->lang[$this->_key.'_o_'.$choice];
            if (!$option) $option = $choice;

            $choice = htmlspecialchars($choice);
            $option = htmlspecialchars($option);
            $input .= '  <option value="'.$choice.'"'.$selected.' >'.$option.'</option>'."\n";
        }
        $input .= "</select> $nochoice \n";
        $input .= "</div>\n";

        return array($label,$input);
    }

    function update($input) {
        if (is_null($input)) return false;
        if ($this->is_protected()) return false;

        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        if (!in_array($input, $this->_choices)) return false;

        $this->_local = $input;
        return true;
    }
  }
}


if (!class_exists('setting_dirchoice')) {
  class setting_dirchoice extends setting_multichoice {

    var $_dir = '';

    function initialize($default,$local,$protected) {

      // populate $this->_choices with a list of directories
      $list = array();

      if ($dh = @opendir($this->_dir)) {
        while (false !== ($entry = readdir($dh))) {
          if ($entry == '.' || $entry == '..') continue;
          if ($this->_pattern && !preg_match($this->_pattern,$entry)) continue;

          $file = (is_link($this->_dir.$entry)) ? readlink($this->_dir.$entry) : $entry;
          if (is_dir($this->_dir.$file)) $list[] = $entry;
        }
        closedir($dh);
      }
      sort($list);
      $this->_choices = $list;

      parent::initialize($default,$local,$protected);
    }
  }
}


if (!class_exists('setting_hidden')) {
  class setting_hidden extends setting {
      // Used to explicitly ignore a setting in the configuration manager.
  }
}

if (!class_exists('setting_fieldset')) {
  class setting_fieldset extends setting {
      // A do-nothing class used to detect the 'fieldset' type.
      // Used to start a new settings "display-group".
  }
}

if (!class_exists('setting_undefined')) {
  class setting_undefined extends setting_hidden {
      // A do-nothing class used to detect settings with no metadata entry.
      // Used internaly to hide undefined settings, and generate the undefined settings list.
  }
}

if (!class_exists('setting_no_class')) {
  class setting_no_class extends setting_undefined {
      // A do-nothing class used to detect settings with a missing setting class.
      // Used internaly to hide undefined settings, and generate the undefined settings list.
  }
}

if (!class_exists('setting_no_default')) {
  class setting_no_default extends setting_undefined {
      // A do-nothing class used to detect settings with no default value.
      // Used internaly to hide undefined settings, and generate the undefined settings list.
  }
}

if (!class_exists('setting_multicheckbox')) {
  class setting_multicheckbox extends setting_string {

    var $_choices = array();
    var $_combine = array();

    function update($input) {
        if ($this->is_protected()) return false;

        // split any combined values + convert from array to comma separated string
        $input = ($input) ? $input : array();
        $input = $this->_array2str($input);

        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        if ($this->_pattern && !preg_match($this->_pattern,$input)) {
          $this->_error = true;
          $this->_input = $input;
          return false;
        }

        $this->_local = $input;
        return true;
    }

    function html(&$plugin, $echo=false) {

        $value = '';
        $disable = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = 'disabled="disabled"';
        } else {
          if ($echo && $this->_error) {
            $value = $this->_input;
          } else {
            $value = is_null($this->_local) ? $this->_default : $this->_local;
          }
        }

        $key = htmlspecialchars($this->_key);

        // convert from comma separated list into array + combine complimentary actions
        $value = $this->_str2array($value);
        $default = $this->_str2array($this->_default);

        $input = '';
        foreach ($this->_choices as $choice) {
          $idx = array_search($choice, $value);
          $idx_default = array_search($choice,$default);

          $checked = ($idx !== false) ? 'checked="checked"' : '';

          // ideally this would be handled using a second class of "default", however IE6 does not
          // correctly support CSS selectors referencing multiple class names on the same element
          // (e.g. .default.selection).
          $class = (($idx !== false) == (false !== $idx_default)) ? " selectiondefault" : "";

          $prompt = ($plugin->getLang($this->_key.'_'.$choice) ?
                          $plugin->getLang($this->_key.'_'.$choice) : htmlspecialchars($choice));

          $input .= '<div class="selection'.$class.'">'."\n";
          $input .= '<label for="config___'.$key.'_'.$choice.'">'.$prompt."</label>\n";
          $input .= '<input id="config___'.$key.'_'.$choice.'" name="config['.$key.'][]" type="checkbox" class="checkbox" value="'.$choice.'" '.$disable.' '.$checked."/>\n";
          $input .= "</div>\n";

          // remove this action from the disabledactions array
          if ($idx !== false) unset($value[$idx]);
          if ($idx_default !== false) unset($default[$idx_default]);
        }

        // handle any remaining values
        $other = join(',',$value);

        $class = (count($default == count($value)) && (count($value) == count(array_intersect($value,$default)))) ?
                        " selectiondefault" : "";

        $input .= '<div class="other'.$class.'">'."\n";
        $input .= '<label for="config___'.$key.'_other">'.$plugin->getLang($key.'_other')."</label>\n";
        $input .= '<input id="config___'.$key.'_other" name="config['.$key.'][other]" type="text" class="edit" value="'.htmlspecialchars($other).'" '.$disable." />\n";
        $input .= "</div>\n";

        $label = '<label>'.$this->prompt($plugin).'</label>';
        return array($label,$input);
    }

    /**
     * convert comma separated list to an array and combine any complimentary values
     */
    function _str2array($str) {
      $array = explode(',',$str);

      if (!empty($this->_combine)) {
        foreach ($this->_combine as $key => $combinators) {
          $idx = array();
          foreach ($combinators as $val) {
            if  (($idx[] = array_search($val, $array)) === false) break;
          }

          if (count($idx) && $idx[count($idx)-1] !== false) {
            foreach ($idx as $i) unset($array[$i]);
            $array[] = $key;
          }
        }
      }

      return $array;
    }

    /**
     * convert array of values + other back to a comma separated list, incl. splitting any combined values
     */
    function _array2str($input) {

      // handle other
      $other = trim($input['other']);
      $other = !empty($other) ? explode(',',str_replace(' ','',$input['other'])) : array();
      unset($input['other']);

      $array = array_unique(array_merge($input, $other));

      // deconstruct any combinations
      if (!empty($this->_combine)) {
       foreach ($this->_combine as $key => $combinators) {

          $idx = array_search($key,$array);
          if ($idx !== false) {
            unset($array[$idx]);
            $array = array_merge($array, $combinators);
          }
        }
      }

      return join(',',array_unique($array));
    }
  }
}

/**
 *  Provide php_strip_whitespace (php5 function) functionality
 *
 *  @author   Chris Smith <chris@jalakai.co.uk>
 */
if (!function_exists('php_strip_whitespace'))  {

  if (function_exists('token_get_all')) {

    if (!defined('T_ML_COMMENT')) {
      define('T_ML_COMMENT', T_COMMENT);
    } else {
      define('T_DOC_COMMENT', T_ML_COMMENT);
    }

    /**
     * modified from original
     * source Google Groups, php.general, by David Otton
     */
    function php_strip_whitespace($file) {
        if (!@is_readable($file)) return '';

        $in = join('',@file($file));
        $out = '';

        $tokens = token_get_all($in);

        foreach ($tokens as $token) {
          if (is_string ($token)) {
            $out .= $token;
          } else {
            list ($id, $text) = $token;
            switch ($id) {
              case T_COMMENT : // fall thru
              case T_ML_COMMENT : // fall thru
              case T_DOC_COMMENT : // fall thru
              case T_WHITESPACE :
                break;
              default : $out .= $text; break;
            }
          }
        }
        return ($out);
    }

  } else {

    function is_whitespace($c) { return (strpos("\t\n\r ",$c) !== false); }
    function is_quote($c) { return (strpos("\"'",$c) !== false); }
    function is_escaped($s,$i) {
        $idx = $i-1;
        while(($idx>=0) && ($s{$idx} == '\\')) $idx--;
        return (($i - $idx + 1) % 2);
    }

    function is_commentopen($str, $i) {
        if ($str{$i} == '#') return "\n";
        if ($str{$i} == '/') {
          if ($str{$i+1} == '/') return "\n";
          if ($str{$i+1} == '*') return "*/";
        }

        return false;
    }

    function php_strip_whitespace($file) {

        if (!@is_readable($file)) return '';

        $contents = join('',@file($file));
        $out = '';

        $state = 0;
        for ($i=0; $i<strlen($contents); $i++) {
          if (!$state && is_whitespace($contents{$i})) continue;

          if (!$state && ($c_close = is_commentopen($contents, $i))) {
            $c_open_len = ($contents{$i} == '/') ? 2 : 1;
            $i = strpos($contents, $c_close, $i+$c_open_len)+strlen($c_close)-1;
            continue;
          }

          $out .= $contents{$i};
          if (is_quote($contents{$i})) {
              if (($state == $contents{$i}) && !is_escaped($contents, $i)) { $state = 0; continue; }
            if (!$state) {$state = $contents{$i}; continue; }
          }
        }

        return $out;
    }
  }
}||||||||    function _out_key($pretty=false,$url=false) {
        if($pretty){
            $out = str_replace(CM_KEYMARKER,"&raquo;",$this->_key);
            if ($url && !strstr($out,'&raquo;')) {//provide no urls for plugins, etc.
                if ($out == 'start') //one exception
                    return '<a href="http://www.dokuwiki.org/config:startpage">'.$out.'</a>';
                else
                    return '<a href="http://www.dokuwiki.org/config:'.$out.'">'.$out.'</a>';
            }
            return $out;
        }else{
            return str_replace(CM_KEYMARKER,"']['",$this->_key);
        }
    }
  }
}

if (!class_exists('setting_string')) {
  class setting_string extends setting {
    function html(&$plugin, $echo=false) {
        $value = '';
        $disable = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = 'disabled="disabled"';
        } else {
          if ($echo && $this->_error) {
            $value = $this->_input;
          } else {
            $value = is_null($this->_local) ? $this->_default : $this->_local;
          }
        }

        $key = htmlspecialchars($this->_key);
        $value = htmlspecialchars($value);

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';
        $input = '<input id="config___'.$key.'" name="config['.$key.']" type="text" class="edit" value="'.$value.'" '.$disable.'/>';
        return array($label,$input);
    }
  }
}

if (!class_exists('setting_password')) {
  class setting_password extends setting_string {

    var $_code = 'plain';  // mechanism to be used to obscure passwords

    function update($input) {
        if ($this->is_protected()) return false;
        if (!$input) return false;

        if ($this->_pattern && !preg_match($this->_pattern,$input)) {
          $this->_error = true;
          $this->_input = $input;
          return false;
        }

        $this->_local = conf_encodeString($input,$this->_code);
        return true;
    }

    function html(&$plugin, $echo=false) {

        $value = '';
        $disable = $this->is_protected() ? 'disabled="disabled"' : '';

        $key = htmlspecialchars($this->_key);

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';
        $input = '<input id="config___'.$key.'" name="config['.$key.']" autocomplete="off" type="password" class="edit" value="" '.$disable.' />';
        return array($label,$input);
    }
  }
}

if (!class_exists('setting_email')) {
  class setting_email extends setting_string {
    var $_pattern = '#^\s*(([a-z0-9\-_.]+?)@([\w\-]+\.([\w\-\.]+\.)*[\w]+)(,\s*([a-z0-9\-_.]+?)@([\w\-]+\.([\w\-\.]+\.)*[\w]+))*)?\s*$#i';
  }
}

if (!class_exists('setting_richemail')) {
  class setting_richemail extends setting_email {

    /**
     *  update setting with user provided value $input
     *  if value fails error check, save it
     *
     *  @return true if changed, false otherwise (incl. on error)
     */
    function update($input) {
        if (is_null($input)) return false;
        if ($this->is_protected()) return false;

        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        // replace variables with pseudo values
        $test = $input;
        $test = str_replace('@USER@','joe',$test);
        $test = str_replace('@NAME@','Joe Schmoe',$test);
        $test = str_replace('@MAIL@','joe@example.com',$test);

        // now only check the address part
        if(preg_match('#(.*?)<(.*?)>#',$test,$matches)){
          $text = trim($matches[1]);
          $addr = $matches[2];
        }else{
          $addr = $test;
        }

        if ($this->_pattern && !preg_match($this->_pattern,$addr)) {
          $this->_error = true;
          $this->_input = $input;
          return false;
        }

        $this->_local = $input;
        return true;
    }

  }
}


if (!class_exists('setting_numeric')) {
  class setting_numeric extends setting_string {
    // This allows for many PHP syntax errors...
    // var $_pattern = '/^[-+\/*0-9 ]*$/';
    // much more restrictive, but should eliminate syntax errors.
    var $_pattern = '/^[-]?[0-9]+(?:[-+*][0-9]+)*$/';
    //FIXME - make the numeric error checking better.

    function out($var, $fmt='php') {

      if ($this->is_protected()) return '';
      if (is_null($this->_local) || ($this->_default == $this->_local)) return '';

      $out = '';

      if ($fmt=='php') {
        $out .=  '$'.$var."['".$this->_out_key()."'] = ".$this->_local.";\n";
      }

    return $out;
    }
  }
}

if (!class_exists('setting_numericopt')) {
    class setting_numericopt extends setting_numeric {
        // just allow an empty config
        var $_pattern = '/^(|[-]?[0-9]+(?:[-+*][0-9]+)*)$/';
    }
}

if (!class_exists('setting_onoff')) {
  class setting_onoff extends setting_numeric {

    function html(&$plugin) {
        $value = '';
        $disable = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = ' disabled="disabled"';
        } else {
          $value = is_null($this->_local) ? $this->_default : $this->_local;
        }

        $key = htmlspecialchars($this->_key);
        $checked = ($value) ? ' checked="checked"' : '';

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';
        $input = '<div class="input"><input id="config___'.$key.'" name="config['.$key.']" type="checkbox" class="checkbox" value="1"'.$checked.$disable.'/></div>';
        return array($label,$input);
    }

    function update($input) {
        if ($this->is_protected()) return false;

        $input = ($input) ? 1 : 0;
        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        $this->_local = $input;
        return true;
    }
  }
}

if (!class_exists('setting_multichoice')) {
  class setting_multichoice extends setting_string {
    var $_choices = array();

    function html(&$plugin) {
        $value = '';
        $disable = '';
        $nochoice = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = ' disabled="disabled"';
        } else {
          $value = is_null($this->_local) ? $this->_default : $this->_local;
        }

        // ensure current value is included
        if (!in_array($value, $this->_choices)) {
            $this->_choices[] = $value;
        }
        // disable if no other choices
        if (!$this->is_protected() && count($this->_choices) <= 1) {
          $disable = ' disabled="disabled"';
          $nochoice = $plugin->getLang('nochoice');
        }

        $key = htmlspecialchars($this->_key);

        $label = '<label for="config___'.$key.'">'.$this->prompt($plugin).'</label>';

        $input = "<div class=\"input\">\n";
        $input .= '<select class="edit" id="config___'.$key.'" name="config['.$key.']"'.$disable.'>'."\n";
        foreach ($this->_choices as $choice) {
            $selected = ($value == $choice) ? ' selected="selected"' : '';
            $option = $plugin->getLang($this->_key.'_o_'.$choice);
            if (!$option && isset($this->lang[$this->_key.'_o_'.$choice])) $option = $this->lang[$this->_key.'_o_'.$choice];
            if (!$option) $option = $choice;

            $choice = htmlspecialchars($choice);
            $option = htmlspecialchars($option);
            $input .= '  <option value="'.$choice.'"'.$selected.' >'.$option.'</option>'."\n";
        }
        $input .= "</select> $nochoice \n";
        $input .= "</div>\n";

        return array($label,$input);
    }

    function update($input) {
        if (is_null($input)) return false;
        if ($this->is_protected()) return false;

        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        if (!in_array($input, $this->_choices)) return false;

        $this->_local = $input;
        return true;
    }
  }
}


if (!class_exists('setting_dirchoice')) {
  class setting_dirchoice extends setting_multichoice {

    var $_dir = '';

    function initialize($default,$local,$protected) {

      // populate $this->_choices with a list of directories
      $list = array();

      if ($dh = @opendir($this->_dir)) {
        while (false !== ($entry = readdir($dh))) {
          if ($entry == '.' || $entry == '..') continue;
          if ($this->_pattern && !preg_match($this->_pattern,$entry)) continue;

          $file = (is_link($this->_dir.$entry)) ? readlink($this->_dir.$entry) : $entry;
          if (is_dir($this->_dir.$file)) $list[] = $entry;
        }
        closedir($dh);
      }
      sort($list);
      $this->_choices = $list;

      parent::initialize($default,$local,$protected);
    }
  }
}


if (!class_exists('setting_hidden')) {
  class setting_hidden extends setting {
      // Used to explicitly ignore a setting in the configuration manager.
  }
}

if (!class_exists('setting_fieldset')) {
  class setting_fieldset extends setting {
      // A do-nothing class used to detect the 'fieldset' type.
      // Used to start a new settings "display-group".
  }
}

if (!class_exists('setting_undefined')) {
  class setting_undefined extends setting_hidden {
      // A do-nothing class used to detect settings with no metadata entry.
      // Used internaly to hide undefined settings, and generate the undefined settings list.
  }
}

if (!class_exists('setting_no_class')) {
  class setting_no_class extends setting_undefined {
      // A do-nothing class used to detect settings with a missing setting class.
      // Used internaly to hide undefined settings, and generate the undefined settings list.
  }
}

if (!class_exists('setting_no_default')) {
  class setting_no_default extends setting_undefined {
      // A do-nothing class used to detect settings with no default value.
      // Used internaly to hide undefined settings, and generate the undefined settings list.
  }
}

if (!class_exists('setting_multicheckbox')) {
  class setting_multicheckbox extends setting_string {

    var $_choices = array();
    var $_combine = array();

    function update($input) {
        if ($this->is_protected()) return false;

        // split any combined values + convert from array to comma separated string
        $input = ($input) ? $input : array();
        $input = $this->_array2str($input);

        $value = is_null($this->_local) ? $this->_default : $this->_local;
        if ($value == $input) return false;

        if ($this->_pattern && !preg_match($this->_pattern,$input)) {
          $this->_error = true;
          $this->_input = $input;
          return false;
        }

        $this->_local = $input;
        return true;
    }

    function html(&$plugin, $echo=false) {

        $value = '';
        $disable = '';

        if ($this->is_protected()) {
          $value = $this->_protected;
          $disable = 'disabled="disabled"';
        } else {
          if ($echo && $this->_error) {
            $value = $this->_input;
          } else {
            $value = is_null($this->_local) ? $this->_default : $this->_local;
          }
        }

        $key = htmlspecialchars($this->_key);

        // convert from comma separated list into array + combine complimentary actions
        $value = $this->_str2array($value);
        $default = $this->_str2array($this->_default);

        $input = '';
        foreach ($this->_choices as $choice) {
          $idx = array_search($choice, $value);
          $idx_default = array_search($choice,$default);

          $checked = ($idx !== false) ? 'checked="checked"' : '';

          // ideally this would be handled using a second class of "default", however IE6 does not
          // correctly support CSS selectors referencing multiple class names on the same element
          // (e.g. .default.selection).
          $class = (($idx !== false) == (false !== $idx_default)) ? " selectiondefault" : "";

          $prompt = ($plugin->getLang($this->_key.'_'.$choice) ?
                          $plugin->getLang($this->_key.'_'.$choice) : htmlspecialchars($choice));

          $input .= '<div class="selection'.$class.'">'."\n";
          $input .= '<label for="config___'.$key.'_'.$choice.'">'.$prompt."</label>\n";
          $input .= '<input id="config___'.$key.'_'.$choice.'" name="config['.$key.'][]" type="checkbox" class="checkbox" value="'.$choice.'" '.$disable.' '.$checked."/>\n";
          $input .= "</div>\n";

          // remove this action from the disabledactions array
          if ($idx !== false) unset($value[$idx]);
          if ($idx_default !== false) unset($default[$idx_default]);
        }

        // handle any remaining values
        $other = join(',',$value);

        $class = (count($default == count($value)) && (count($value) == count(array_intersect($value,$default)))) ?
                        " selectiondefault" : "";

        $input .= '<div class="other'.$class.'">'."\n";
        $input .= '<label for="config___'.$key.'_other">'.$plugin->getLang($key.'_other')."</label>\n";
        $input .= '<input id="config___'.$key.'_other" name="config['.$key.'][other]" type="text" class="edit" value="'.htmlspecialchars($other).'" '.$disable." />\n";
        $input .= "</div>\n";

        $label = '<label>'.$this->prompt($plugin).'</label>';
        return array($label,$input);
    }

    /**
     * convert comma separated list to an array and combine any complimentary values
     */
    function _str2array($str) {
      $array = explode(',',$str);

      if (!empty($this->_combine)) {
        foreach ($this->_combine as $key => $combinators) {
          $idx = array();
          foreach ($combinators as $val) {
            if  (($idx[] = array_search($val, $array)) === false) break;
          }

          if (count($idx) && $idx[count($idx)-1] !== false) {
            foreach ($idx as $i) unset($array[$i]);
            $array[] = $key;
          }
        }
      }

      return $array;
    }

    /**
     * convert array of values + other back to a comma separated list, incl. splitting any combined values
     */
    function _array2str($input) {

      // handle other
      $other = trim($input['other']);
      $other = !empty($other) ? explode(',',str_replace(' ','',$input['other'])) : array();
      unset($input['other']);

      $array = array_unique(array_merge($input, $other));

      // deconstruct any combinations
      if (!empty($this->_combine)) {
       foreach ($this->_combine as $key => $combinators) {

          $idx = array_search($key,$array);
          if ($idx !== false) {
            unset($array[$idx]);
            $array = array_merge($array, $combinators);
          }
        }
      }

      return join(',',array_unique($array));
    }
  }
}

/**
 *  Provide php_strip_whitespace (php5 function) functionality
 *
 *  @author   Chris Smith <chris@jalakai.co.uk>
 */
if (!function_exists('php_strip_whitespace'))  {

  if (function_exists('token_get_all')) {

    if (!defined('T_ML_COMMENT')) {
      define('T_ML_COMMENT', T_COMMENT);
    } else {
      define('T_DOC_COMMENT', T_ML_COMMENT);
    }

    /**
     * modified from original
     * source Google Groups, php.general, by David Otton
     */
    function php_strip_whitespace($file) {
        if (!@is_readable($file)) return '';

        $in = join('',@file($file));
        $out = '';

        $tokens = token_get_all($in);

        foreach ($tokens as $token) {
          if (is_string ($token)) {
            $out .= $token;
          } else {
            list ($id, $text) = $token;
            switch ($id) {
              case T_COMMENT : // fall thru
              case T_ML_COMMENT : // fall thru
              case T_DOC_COMMENT : // fall thru
              case T_WHITESPACE :
                break;
              default : $out .= $text; break;
            }
          }
        }
        return ($out);
    }

  } else {

    function is_whitespace($c) { return (strpos("\t\n\r ",$c) !== false); }
    function is_quote($c) { return (strpos("\"'",$c) !== false); }
    function is_escaped($s,$i) {
        $idx = $i-1;
        while(($idx>=0) && ($s{$idx} == '\\')) $idx--;
        return (($i - $idx + 1) % 2);
    }

    function is_commentopen($str, $i) {
        if ($str{$i} == '#') return "\n";
        if ($str{$i} == '/') {
          if ($str{$i+1} == '/') return "\n";
          if ($str{$i+1} == '*') return "*/";
        }

        return false;
    }

    function php_strip_whitespace($file) {

        if (!@is_readable($file)) return '';

        $contents = join('',@file($file));
        $out = '';

        $state = 0;
        for ($i=0; $i<strlen($contents); $i++) {
          if (!$state && is_whitespace($contents{$i})) continue;

          if (!$state && ($c_close = is_commentopen($contents, $i))) {
            $c_open_len = ($contents{$i} == '/') ? 2 : 1;
            $i = strpos($contents, $c_close, $i+$c_open_len)+strlen($c_close)-1;
            continue;
          }

          $out .= $contents{$i};
          if (is_quote($contents{$i})) {
              if (($state == $contents{$i}) && !is_escaped($contents, $i)) { $state = 0; continue; }
            if (!$state) {$state = $contents{$i}; continue; }
          }
        }

        return $out;
    }
  }
}||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_RETURN
                    (AST_CALL
                        (
                            (AST_CONST)
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_RETURN
                    (AST_CALL
                        (
                            (AST_CONST)
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))))))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPEPARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_CONST)
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_BINARY_OP
                            (AST_VAR)
                            (AST_UNARY_OP
                                (AST_CALL
                                    (
                                        (AST_VAR)
                                        (SCALAR)))))
                        (
                            (AST_IF
                                (AST_IF_ELEM
                                    (AST_BINARY_OP
                                        (AST_VAR)
                                        (SCALAR))
                                    (
                                        (AST_RETURN
                                            (AST_BINARY_OP
                                                (AST_BINARY_OP
                                                    (SCALAR)
                                                    (AST_VAR))
                                                (SCALAR)))))
                                (AST_IF_ELEM
                                    (NULL)
                                    (
                                        (AST_RETURN
                                            (AST_BINARY_OP
                                                (AST_BINARY_OP
                                                    (AST_BINARY_OP
                                                        (AST_BINARY_OP
                                                            (SCALAR)
                                                            (AST_VAR))
                                                        (SCALAR))
                                                    (AST_VAR))
                                                (SCALAR)))))))))
                (AST_RETURN
                    (AST_VAR))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_RETURN
                    (AST_CALL
                        (
                            (AST_CONST)
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))))))