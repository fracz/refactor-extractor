    public function path_end_reached($path) {
        print_object("end reached: $path"); // DONOTCOMMIT
    }
}


/**
 * XML parser processor
 */
class moodle1_parser_processor extends grouped_parser_processor {

    /** @var moodle1_converter */
    protected $converter;

    public function __construct(moodle1_converter $converter) {
        $this->converter = $converter;
        parent::__construct();
    }

    /**
     * Provide NULL and legacy file.php uses decoding
     */
    public function process_cdata($cdata) {
        global $CFG;

        if ($cdata === '$@NULL@$') {  // Some cases we know we can skip complete processing
            return null;
        } else if ($cdata === '') {
            return '';
        } else if (is_numeric($cdata)) {
            return $cdata;
        } else if (strlen($cdata) < 32) { // Impossible to have one link in 32cc
            return $cdata;                // (http://10.0.0.1/file.php/1/1.jpg, http://10.0.0.1/mod/url/view.php?id=)
        } else if (strpos($cdata, '$@FILEPHP@$') === false) { // No $@FILEPHP@$, nothing to convert
            return $cdata;
        }
        // Decode file.php calls
        $search = array ("$@FILEPHP@$");
        $replace = array(get_file_url($this->courseid));
        $result = str_replace($search, $replace, $cdata);
        // Now $@SLASH@$ and $@FORCEDOWNLOAD@$ MDL-18799
        $search = array('$@SLASH@$', '$@FORCEDOWNLOAD@$');
        if ($CFG->slasharguments) {
            $replace = array('/', '?forcedownload=1');
        } else {
            $replace = array('%2F', '&amp;forcedownload=1');
        }
        return str_replace($search, $replace, $result);
    }

    /**
     * Override this method so we'll be able to skip
     * dispatching some well-known chunks, like the
     * ones being 100% part of subplugins stuff. Useful
     * for allowing development without having all the
     * possible restore subplugins defined
     */
    protected function postprocess_chunk($data) {

        // Iterate over all the data tags, if any of them is
        // not 'subplugin_XXXX' or has value, then it's a valid chunk,
        // pass it to standard (parent) processing of chunks.
        foreach ($data['tags'] as $key => $value) {
            if (trim($value) !== '' || strpos($key, 'subplugin_') !== 0) {
                parent::postprocess_chunk($data);
                return;
            }
        }
        // Arrived here, all the tags correspond to sublplugins and are empty,
        // skip the chunk, and debug_developer notice
        $this->chunks--; // not counted
        debugging('Missing support on restore for ' . clean_param($data['path'], PARAM_PATH) .
                  ' subplugin (' . implode(', ', array_keys($data['tags'])) .')', DEBUG_DEVELOPER);
    }

    /**
     * Dispatches the data chunk to the converter class
     *
     * @param array $data the chunk of parsed data
     */
    protected function dispatch_chunk($data) {
        $this->converter->process_chunk($data);
    }

    /**
     * Informs the converter at the start of a watched path
     *
     * @param string $path
     */
    protected function notify_path_start($path) {
        $this->converter->path_start_reached($path);
    }

    /**
     * Informs the converter at the end of a watched path
     *
     * @param string $path
     */
    protected function notify_path_end($path) {
        $this->converter->path_end_reached($path);
    }
}


/**
 * Class representing a path to be converted from XML file
 *
 * This was created as a copy of {@link restore_path_element} and should be refactored
 * probably.
 */
class convert_path {

    /** @var string name of the element */
    protected $name;

    /** @var string path within the XML file this element will handle */
    protected $path;

    /** @var bool flag to define if this element will get child ones grouped or no */
    protected $grouped;

    /** @var object object instance in charge of processing this element. */
    protected $pobject = null;

    /** @var string the name of the processing method */
    protected $pmethod = null;

    /** @var mixed last data read for this element or returned data by processing method */
    protected $data = null;

    /** @var array of deprecated fields that are skipped and not converted */
    protected $skipfields = array();

    /** @var array of fields renaming */
    protected $renamefields = array();

    /** @var array of new fields to add and their initial values */
    protected $newfields = array();

    /**
     * Constructor
     *
     * @param string $name name of the element
     * @param string $path path of the element
     * @param array $recipe basic description of the structure conversion
     * @param bool $grouped to gather information in grouped mode or no
     */
    public function __construct($name, $path, array $recipe = array(), $grouped = false) {

        $this->validate_name($name);

        $this->name     = $name;
        $this->path     = $path;
        $this->grouped  = $grouped;

        // set the default processing method name
        $this->set_processing_method('process_' . $name);

        if (isset($recipe['skipfields']) and is_array($recipe['skipfields'])) {
            $this->set_skipped_fields($recipe['skipfields']);
        }
        if (isset($recipe['renamefields']) and is_array($recipe['renamefields'])) {
            $this->set_renamed_fields($recipe['renamefields']);
        }
        if (isset($recipe['newfields']) and is_array($recipe['newfields'])) {
            $this->set_new_fields($recipe['newfields']);
        }
    }

    /**
     * Validates and sets the given processing object
     *
     * @param object $pobject processing object, must provide a method to be called
     */
    public function set_processing_object($pobject) {
        $this->validate_pobject($pobject);
        $this->pobject = $pobject;
    }

    /**
     * Sets the name of the processing method
     *
     * @param string $pmethod
     */
    public function set_processing_method($pmethod) {
        $this->pmethod = $pmethod;
    }

    /**
     * Sets the element data
     *
     * @param mixed
     */
    public function set_data($data) {
        $this->data = $data;
    }

    /**
     * Sets the list of deprecated fields to skip
     *
     * @param array $fields
     */
    public function set_skipped_fields(array $fields) {
        $this->skipfields = $fields;
    }

    /**
     * Sets the required new names of the current fields
     *
     * @param array $fields (string)$currentname => (string)$newname
     */
    public function set_renamed_fields(array $fields) {
        $this->renamefields = $fields;
    }

    /**
     * Sets the new fields and their values
     *
     * @param array $fields (string)$field => (mixed)value
     */
    public function set_new_fields(array $fields) {
        $this->newfields = $fields;
    }

    /**
     * Cooks the parsed tags data by applying known recipes
     *
     * Recipes are used for common trivial operations like adding new fields
     * or renaming fields. The handler's processing method receives cooked
     * data.
     *
     * @param array $data the contents of the element
     * @return array
     */
    public function apply_recipes(array $data) {

        $cooked = array();

        foreach ($data as $name => $value) {
            // lower case rocks!
            $name = strtolower($name);

            // fields renaming
            if (array_key_exists($name, $this->renamefields)) {
                $name = $this->renamefields[$name];
            }

            $cooked[$name] = $value;
        }

        // adding new fields
        foreach ($this->newfields as $name => $value) {
            $cooked[$name] = $value;
        }

        return $cooked;
    }

    /**
     * @return string the element given name
     */
    public function get_name() {
        return $this->name;
    }

    /**
     * @return string the path to the element
     */
    public function get_path() {
        return $this->path;
    }

    /**
     * @return bool flag to define if this element will get child ones grouped or no
     */
    public function is_grouped() {
        return $this->grouped;
    }

    /**
     * @return object the processing object providing the processing method
     */
    public function get_processing_object() {
        return $this->pobject;
    }

    /**
     * @return string the name of the method to call to process the element
     */
    public function get_processing_method() {
        return $this->pmethod;
    }

    /**
     * @return mixed the element data
     */
    public function get_data() {
        return $this->data;
    }


    /// end of public API //////////////////////////////////////////////////////

    /**
     * Makes sure the given name is a valid element name
     *
     * Note it may look as if we used exceptions for code flow control here. That's not the case
     * as we actually validate the code, not the user data. And the code is supposed to be
     * correct.
     *
     * @param string @name the element given name
     * @throws convert_path_exception
     * @return void
     */
    protected function validate_name($name) {
        // Validate various name constraints, throwing exception if needed
        if (empty($name)) {
            throw new convert_path_exception('convert_path_emptyname', $name);
        }
        if (preg_replace('/\s/', '', $name) != $name) {
            throw new convert_path_exception('convert_path_whitespace', $name);
        }
        if (preg_replace('/[^\x30-\x39\x41-\x5a\x5f\x61-\x7a]/', '', $name) != $name) {
            throw new convert_path_exception('convert_path_notasciiname', $name);
        }
    }

    /**
     * Makes sure that the given object is a valid processing object
     *
     * The processing object must be an object providing the element's processing method.
     * Note it may look as if we used exceptions for code flow control here. That's not the case
     * as we actually validate the code, not the user data. And the code is supposed to be
     * correct.
      *
     * @param object $pobject
     * @throws convert_path_exception
     * @return void
     */
    protected function validate_pobject($pobject) {
        if (!is_object($pobject)) {
            throw new convert_path_exception('convert_path_no_object', $pobject);
        }
        if (!method_exists($pobject, $this->get_processing_method())) {
            throw new convert_path_exception('convert_path_missingmethod', $this->get_processing_method());
        }
    }
}


/**
 * Exception being thrown by {@link convert_path} methods
 */
class convert_path_exception extends moodle_exception {

    /**
     * Constructor
     *
     * @param string $errorcode key for the corresponding error string
     * @param mixed $a extra words and phrases that might be required by the error string
     * @param string $debuginfo optional debugging information
     */
    public function __construct($errorcode, $a = null, $debuginfo = null) {
        parent::__construct($errorcode, '', '', $a, $debuginfo);
    }
}||||||||    public function path_end_reached($path) {

        // expand the MOD paths so that they contain the current module name
        if ($path === '/MOODLE_BACKUP/COURSE/MODULES/MOD') {
            $path = '/MOODLE_BACKUP/COURSE/MODULES/MOD/' . $this->currentmod;

        } else if (strpos($path, '/MOODLE_BACKUP/COURSE/MODULES/MOD') === 0) {
            $path = str_replace('/MOODLE_BACKUP/COURSE/MODULES/MOD', '/MOODLE_BACKUP/COURSE/MODULES/MOD/' . $this->currentmod, $path);
        }

        // expand the BLOCK paths so that they contain the module name
        if ($path === '/MOODLE_BACKUP/COURSE/BLOCKS/BLOCK') {
            $path = '/MOODLE_BACKUP/COURSE/BLOCKS/BLOCK/' . $this->currentblock;

        } else if (strpos($path, '/MOODLE_BACKUP/COURSE/BLOCKS/BLOCK') === 0) {
            $path = str_replace('/MOODLE_BACKUP/COURSE/BLOCKS/BLOCK', '/MOODLE_BACKUP/COURSE/BLOCKS/BLOCK/' . $this->currentmod, $path);
        }

        if (empty($this->pathelements[$path])) {
            return;
        }

        $element = $this->pathelements[$path];
        $pobject = $element->get_processing_object();
        $method  = 'on_' . $element->get_name() . '_end';

        if (method_exists($pobject, $method)) {
            $pobject->$method();
        }
    }

    /**
     * Creates the backup_ids_temp table
     */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_CALL
        (
            (AST_ENCAPS_LIST
                (SCALAR)
                (AST_VAR)))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_PROP
                            (AST_VAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_BINARY_OP
                            (AST_CALL
                                (
                                    (AST_VAR)
                                    (SCALAR)))
                            (SCALAR))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_CALL
                                    (
                                        (SCALAR)
                                        (AST_BINARY_OP
                                            (SCALAR)
                                            (AST_PROP
                                                (AST_VAR)))
                                        (AST_VAR))))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_PROP
                            (AST_VAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_BINARY_OP
                            (AST_CALL
                                (
                                    (AST_VAR)
                                    (SCALAR)))
                            (SCALAR))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_CALL
                                    (
                                        (SCALAR)
                                        (AST_BINARY_OP
                                            (SCALAR)
                                            (AST_PROP
                                                (AST_VAR)))
                                        (AST_VAR))))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_EMPTY
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))
            (
                (AST_RETURN
                    (NULL)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_DIM
            (AST_PROP
                (AST_VAR))
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (SCALAR)
                (AST_METHOD_CALL
                    (AST_VAR)))
            (SCALAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)
                    (AST_VAR)))
            (
                (AST_METHOD_CALL
                    (AST_VAR))))))