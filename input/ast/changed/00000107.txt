 namespace TokenReflection;use ReflectionMethod as InternalReflectionMethod,ReflectionClass as InternalReflectionClass;use RuntimeException,InvalidArgumentException;class ReflectionMethod extends ReflectionFunctionBase implements IReflectionMethod{const IS_IMPLEMENTED_ABSTRACT=0x08;const ACCESS_LEVEL_CHANGED=0x800;const IS_CONSTRUCTOR=0x2000;const IS_DESTRUCTOR=0x4000;const IS_CLONE=0x8000;const IS_ALLOWED_STATIC=0x10000;private$declaringClassName;private$accessible=false;public function getDeclaringClass(){return null ===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getClass(){return$this->getDeclaringClassName();}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())&&false === strpos($docComment,'@inheritdoc')){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null !==$parent &&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return false;}public function getModifiers(){if(!($this->modifiers&(self::ACCESS_LEVEL_CHANGED|self::IS_IMPLEMENTED_ABSTRACT))){$declaringClass=$this->getDeclaringClass();if(null ===$declaringClass){throw new RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null !==$parentClass){$parentClassMethods=$parentClass->getMethods();if($this->modifiers&InternalReflectionMethod::IS_PUBLIC){if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::ACCESS_LEVEL_CHANGED|InternalReflectionMethod::IS_PRIVATE))){$this->modifiers |= self::ACCESS_LEVEL_CHANGED;}}if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::IS_IMPLEMENTED_ABSTRACT|InternalReflectionMethod::IS_ABSTRACT))){$this->modifiers |= self::IS_IMPLEMENTED_ABSTRACT;}}}return$this->modifiers;}public function invoke($object,$args){$params=func_get_args();return$this->invokeArgs(array_shift($params),$params);}public function invokeArgs($object,array$args=array()){$declaringClass=$this->getDeclaringClass();if(!$declaringClass->isInstance($object)){throw new InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return call_user_func_array(array($object,$this->getName()),$args);}elseif($this->isAccessible()){$refClass=new InternalReflectionClass($object);$refMethod=$refClass->getMethod($this->name);$refMethod->setAccessible(true);$value=$refMethod->invokeArgs($object,$args);$refMethod->setAccessible(false);return$value;}throw new RuntimeException('Only public methods can be invoked.');}public function isAbstract(){return (bool)($this->modifiers&InternalReflectionMethod::IS_ABSTRACT);}public function isConstructor(){return (bool)($this->modifiers&self::IS_CONSTRUCTOR);}public function isDestructor(){return (bool)($this->modifiers&self::IS_DESTRUCTOR);}public function isFinal(){return (bool)($this->modifiers&InternalReflectionMethod::IS_FINAL);}public function isPrivate(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PRIVATE);}public function isProtected(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PROTECTED);}public function isPublic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PUBLIC);}public function isStatic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_STATIC);}public function setAccessible($accessible){$this->accessible=$accessible;}public function isAccessible(){return$this->accessible;}public function getPrototype(){$declaring=$this->getDeclaringClass();if($declaring->getParentClassName()){foreach($declaring->getParentClass()->getMethods()as$method){if($method->getName()===$this->name &&!$method->isPrivate()){return$method;}}}foreach($declaring->getInterfaces()as$interface){if($interface->hasMethod($this->name)){return$interface->getMethod($this->name);}}throw new Exception('Method has no prototype',Exception::DOES_NOT_EXIST);}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionClass){throw new RuntimeException('The parent object has to be either an instance of TokenReflection\ReflectionClass or NULL, %s given.',get_class($parent));}$this->declaringClassName=$parent->getName();return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseBaseModifiers($tokenStream)->parseReturnsReference($tokenStream)->parseName($tokenStream)->parseInternalModifiers($parent);}private function parseBaseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case T_ABSTRACT:$this->modifiers |= InternalReflectionMethod::IS_ABSTRACT;break;case T_FINAL:$this->modifiers |= InternalReflectionMethod::IS_FINAL;break;case T_PUBLIC:$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;break;case T_PRIVATE:$this->modifiers |= InternalReflectionMethod::IS_PRIVATE;break;case T_PROTECTED:$this->modifiers |= InternalReflectionMethod::IS_PROTECTED;break;case T_STATIC:$this->modifiers |= InternalReflectionMethod::IS_STATIC;break;case T_FUNCTION:case null:break 2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&InternalReflectionMethod::IS_PRIVATE)&&!($this->modifiers&InternalReflectionMethod::IS_PROTECTED)){$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;}return$this;}private function parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct' ===$name ||($class &&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers |= self::IS_CONSTRUCTOR;}elseif('__destruct' ===$name){$this->modifiers |= self::IS_DESTRUCTOR;}elseif('__clone' ===$name){$this->modifiers |= self::IS_CLONE;}if(!$this->isConstructor()&&!$this->isDestructor()&&!in_array($name,array('__clone','__tostring','__get','__set','__isset','__unset'),true)){$this->modifiers |= self::IS_ALLOWED_STATIC;}return$this;}}||||||||function
parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct'
===$name
||($class
&&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers
|=
self::IS_CONSTRUCTOR;}elseif('__destruct'
===$name){$this->modifiers
|=
self::IS_DESTRUCTOR;}elseif('__clone'
===$name){$this->modifiers
|=
self::IS_CLONE;}static$notAllowed;if(null
===$notAllowed){$notAllowed=array_flip(array('__clone','__tostring','__get','__set','__isset','__unset'));}if(!$this->isConstructor()&&!$this->isDestructor()&&!isset($notAllowed[$name])){$this->modifiers
|=
self::IS_ALLOWED_STATIC;}return$this;}}}||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_PROP
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (SCALAR)
                    (AST_VAR))
                (AST_BINARY_OP
                    (AST_BINARY_OP
                        (AST_VAR)
                        (AST_UNARY_OP
                            (AST_METHOD_CALL
                                (AST_VAR))))
                    (AST_BINARY_OP
                        (AST_CALL
                            (
                                (AST_METHOD_CALL
                                    (AST_VAR))))
                        (AST_VAR))))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR)))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR)))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_UNARY_OP
                        (AST_METHOD_CALL
                            (AST_VAR)))
                    (AST_UNARY_OP
                        (AST_METHOD_CALL
                            (AST_VAR))))
                (AST_UNARY_OP
                    (AST_CALL
                        (
                            (AST_VAR)
                            (AST_ARRAY
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL)))
                            (AST_CONST)))))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_RETURN
        (AST_VAR)))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_PROP
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (SCALAR)
                    (AST_VAR))
                (AST_BINARY_OP
                    (AST_BINARY_OP
                        (AST_VAR)
                        (AST_UNARY_OP
                            (AST_METHOD_CALL
                                (AST_VAR))))
                    (AST_BINARY_OP
                        (AST_CALL
                            (
                                (AST_METHOD_CALL
                                    (AST_VAR))))
                        (AST_VAR))))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR)))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR)))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_STATIC
        (AST_VAR)
        (NULL))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_ARRAY
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL))
                                (AST_ARRAY_ELEM
                                    (SCALAR)
                                    (NULL)))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_UNARY_OP
                        (AST_METHOD_CALL
                            (AST_VAR)))
                    (AST_UNARY_OP
                        (AST_METHOD_CALL
                            (AST_VAR))))
                (AST_UNARY_OP
                    (AST_ISSET
                        (AST_DIM
                            (AST_VAR)
                            (AST_VAR)))))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_RETURN
        (AST_VAR)))