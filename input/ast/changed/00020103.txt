    public function classify_response(array $response) {
        if (empty($response['answer'])) {
            return array($this->id => question_classified_response::no_response());
        }

        $ans = $this->get_matching_answer($response);
        if (!$ans) {
            return array($this->id => question_classified_response::no_response());
        }
        return array($this->id => new question_classified_response(
                $ans->id, $response['answer'], $ans->fraction));
    }
}


/**
 * Class to represent a question answer, loaded from the question_answers table
 * in the database.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_answer {
    /** @var integer the answer id. */
    public $id;

    /** @var string the answer. */
    public $answer;

    /** @var integer one of the FORMAT_... constans. */
    public $answerformat = FORMAT_PLAIN;

    /** @var number the fraction this answer is worth. */
    public $fraction;

    /** @var string the feedback for this answer. */
    public $feedback;

    /** @var integer one of the FORMAT_... constans. */
    public $feedbackformat;

    /**
     * Constructor.
     * @param int $id the answer.
     * @param string $answer the answer.
     * @param int $answerformat the format of the answer.
     * @param number $fraction the fraction this answer is worth.
     * @param string $feedback the feedback for this answer.
     * @param int $feedbackformat the format of the feedback.
     */
    public function __construct($id, $answer, $fraction, $feedback, $feedbackformat) {
        $this->id = $id;
        $this->answer = $answer;
        $this->fraction = $fraction;
        $this->feedback = $feedback;
        $this->feedbackformat = $feedbackformat;
    }
}


/**
 * Class to represent a hint associated with a question.
 * Used by iteractive mode, etc. A question has an array of these.
 *
 * @copyright  2010 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_hint {
    /** @var integer The hint id. */
    public $id;
    /** @var string The feedback hint to be shown. */
    public $hint;
    /** @var integer The corresponding text FORMAT_... type. */
    public $hintformat;

    /**
     * Constructor.
     * @param int the hint id from the database.
     * @param string $hint The hint text
     * @param int the corresponding text FORMAT_... type.
     */
    public function __construct($id, $hint, $hintformat) {
        $this->id = $id;
        $this->hint = $hint;
        $this->hintformat = $hintformat;
    }

    /**
     * Create a basic hint from a row loaded from the question_hints table in the database.
     * @param object $row with $row->hint set.
     * @return question_hint
     */
    public static function load_from_record($row) {
        return new question_hint($row->id, $row->hint, $row->hintformat);
    }

    /**
     * Adjust this display options according to the hint settings.
     * @param question_display_options $options
     */
    public function adjust_display_options(question_display_options $options) {
        // Do nothing.
    }
}


/**
 * An extension of {@link question_hint} for questions like match and multiple
 * choice with multile answers, where there are options for whether to show the
 * number of parts right at each stage, and to reset the wrong parts.
 *
 * @copyright  2010 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_hint_with_parts extends question_hint {
    /** @var boolean option to show the number of sub-parts of the question that were right. */
    public $shownumcorrect;

    /** @var boolean option to clear the parts of the question that were wrong on retry. */
    public $clearwrong;

    /**
     * Constructor.
     * @param int the hint id from the database.
     * @param string $hint The hint text
     * @param int the corresponding text FORMAT_... type.
     * @param bool $shownumcorrect whether the number of right parts should be shown
     * @param bool $clearwrong whether the wrong parts should be reset.
     */
    public function __construct($id, $hint, $hintformat, $shownumcorrect, $clearwrong) {
        parent::__construct($id, $hint, $hintformat);
        $this->shownumcorrect = $shownumcorrect;
        $this->clearwrong = $clearwrong;
    }

    /**
     * Create a basic hint from a row loaded from the question_hints table in the database.
     * @param object $row with $row->hint, ->shownumcorrect and ->clearwrong set.
     * @return question_hint_with_parts
     */
    public static function load_from_record($row) {
        return new question_hint_with_parts($row->id, $row->hint, $row->hintformat,
                $row->shownumcorrect, $row->clearwrong);
    }

    public function adjust_display_options(question_display_options $options) {
        parent::adjust_display_options($options);
        if ($this->clearwrong) {
            $options->clearwrong = true;
        }
        $options->numpartscorrect = $this->shownumcorrect;
    }
}


/**
 * This question_grading_strategy interface. Used to share grading code between
 * questions that that subclass {@link question_graded_by_strategy}.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
interface question_grading_strategy {
    /**
     * Return a question answer that describes the outcome (fraction and feeback)
     * for a particular respons.
     * @param array $response the response.
     * @return question_answer the answer describing the outcome.
     */
    public function grade(array $response);

    /**
     * @return question_answer an answer that contains the a response that would
     *      get full marks.
     */
    public function get_correct_answer();
}


/**
 * This interface defines the methods that a {@link question_definition} must
 * implement if it is to be graded by the
 * {@link question_first_matching_answer_grading_strategy}.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
interface question_response_answer_comparer {
    /** @return array of {@link question_answers}. */
    public function get_answers();

    /**
     * @param array $response the response.
     * @param question_answer $answer an answer.
     * @return bool whether the response matches the answer.
     */
    public function compare_response_with_answer(array $response, question_answer $answer);
}


/**
 * This grading strategy is used by question types like shortanswer an numerical.
 * It gets a list of possible answers from the question, and returns the first one
 * that matches the given response. It returns the first answer with fraction 1.0
 * when asked for the correct answer.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_first_matching_answer_grading_strategy implements question_grading_strategy {
    /**
     * @var question_response_answer_comparer (presumably also a
     * {@link question_definition}) the question we are doing the grading for.
     */
    protected $question;

    /**
     * @param question_response_answer_comparer $question (presumably also a
     * {@link question_definition}) the question we are doing the grading for.
     */
    public function __construct(question_response_answer_comparer $question) {
        $this->question = $question;
    }

    public function grade(array $response) {
        foreach ($this->question->get_answers() as $aid => $answer) {
            if ($this->question->compare_response_with_answer($response, $answer)) {
                $answer->id = $aid;
                return $answer;
            }
        }
        return null;
    }

    public function get_correct_answer() {
        foreach ($this->question->get_answers() as $answer) {
            $state = question_state::graded_state_for_fraction($answer->fraction);
            if ($state == question_state::$gradedright) {
                return $answer;
            }
        }
        return null;
    }
}||||||||    public function classify_response(array $response) {
        if (empty($response['answer'])) {
            return array($this->id => question_classified_response::no_response());
        }

        $ans = $this->get_matching_answer($response);
        if (!$ans) {
            return array($this->id => new question_classified_response(
                    0, $response['answer'], 0));
        }

        return array($this->id => new question_classified_response(
                $ans->id, $response['answer'], $ans->fraction));
    }
}


/**
 * Class to represent a question answer, loaded from the question_answers table
 * in the database.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_answer {
    /** @var integer the answer id. */
    public $id;

    /** @var string the answer. */
    public $answer;

    /** @var integer one of the FORMAT_... constans. */
    public $answerformat = FORMAT_PLAIN;

    /** @var number the fraction this answer is worth. */
    public $fraction;

    /** @var string the feedback for this answer. */
    public $feedback;

    /** @var integer one of the FORMAT_... constans. */
    public $feedbackformat;

    /**
     * Constructor.
     * @param int $id the answer.
     * @param string $answer the answer.
     * @param int $answerformat the format of the answer.
     * @param number $fraction the fraction this answer is worth.
     * @param string $feedback the feedback for this answer.
     * @param int $feedbackformat the format of the feedback.
     */
    public function __construct($id, $answer, $fraction, $feedback, $feedbackformat) {
        $this->id = $id;
        $this->answer = $answer;
        $this->fraction = $fraction;
        $this->feedback = $feedback;
        $this->feedbackformat = $feedbackformat;
    }
}


/**
 * Class to represent a hint associated with a question.
 * Used by iteractive mode, etc. A question has an array of these.
 *
 * @copyright  2010 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_hint {
    /** @var integer The hint id. */
    public $id;
    /** @var string The feedback hint to be shown. */
    public $hint;
    /** @var integer The corresponding text FORMAT_... type. */
    public $hintformat;

    /**
     * Constructor.
     * @param int the hint id from the database.
     * @param string $hint The hint text
     * @param int the corresponding text FORMAT_... type.
     */
    public function __construct($id, $hint, $hintformat) {
        $this->id = $id;
        $this->hint = $hint;
        $this->hintformat = $hintformat;
    }

    /**
     * Create a basic hint from a row loaded from the question_hints table in the database.
     * @param object $row with $row->hint set.
     * @return question_hint
     */
    public static function load_from_record($row) {
        return new question_hint($row->id, $row->hint, $row->hintformat);
    }

    /**
     * Adjust this display options according to the hint settings.
     * @param question_display_options $options
     */
    public function adjust_display_options(question_display_options $options) {
        // Do nothing.
    }
}


/**
 * An extension of {@link question_hint} for questions like match and multiple
 * choice with multile answers, where there are options for whether to show the
 * number of parts right at each stage, and to reset the wrong parts.
 *
 * @copyright  2010 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_hint_with_parts extends question_hint {
    /** @var boolean option to show the number of sub-parts of the question that were right. */
    public $shownumcorrect;

    /** @var boolean option to clear the parts of the question that were wrong on retry. */
    public $clearwrong;

    /**
     * Constructor.
     * @param int the hint id from the database.
     * @param string $hint The hint text
     * @param int the corresponding text FORMAT_... type.
     * @param bool $shownumcorrect whether the number of right parts should be shown
     * @param bool $clearwrong whether the wrong parts should be reset.
     */
    public function __construct($id, $hint, $hintformat, $shownumcorrect, $clearwrong) {
        parent::__construct($id, $hint, $hintformat);
        $this->shownumcorrect = $shownumcorrect;
        $this->clearwrong = $clearwrong;
    }

    /**
     * Create a basic hint from a row loaded from the question_hints table in the database.
     * @param object $row with $row->hint, ->shownumcorrect and ->clearwrong set.
     * @return question_hint_with_parts
     */
    public static function load_from_record($row) {
        return new question_hint_with_parts($row->id, $row->hint, $row->hintformat,
                $row->shownumcorrect, $row->clearwrong);
    }

    public function adjust_display_options(question_display_options $options) {
        parent::adjust_display_options($options);
        if ($this->clearwrong) {
            $options->clearwrong = true;
        }
        $options->numpartscorrect = $this->shownumcorrect;
    }
}


/**
 * This question_grading_strategy interface. Used to share grading code between
 * questions that that subclass {@link question_graded_by_strategy}.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
interface question_grading_strategy {
    /**
     * Return a question answer that describes the outcome (fraction and feeback)
     * for a particular respons.
     * @param array $response the response.
     * @return question_answer the answer describing the outcome.
     */
    public function grade(array $response);

    /**
     * @return question_answer an answer that contains the a response that would
     *      get full marks.
     */
    public function get_correct_answer();
}


/**
 * This interface defines the methods that a {@link question_definition} must
 * implement if it is to be graded by the
 * {@link question_first_matching_answer_grading_strategy}.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
interface question_response_answer_comparer {
    /** @return array of {@link question_answers}. */
    public function get_answers();

    /**
     * @param array $response the response.
     * @param question_answer $answer an answer.
     * @return bool whether the response matches the answer.
     */
    public function compare_response_with_answer(array $response, question_answer $answer);
}


/**
 * This grading strategy is used by question types like shortanswer an numerical.
 * It gets a list of possible answers from the question, and returns the first one
 * that matches the given response. It returns the first answer with fraction 1.0
 * when asked for the correct answer.
 *
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class question_first_matching_answer_grading_strategy implements question_grading_strategy {
    /**
     * @var question_response_answer_comparer (presumably also a
     * {@link question_definition}) the question we are doing the grading for.
     */
    protected $question;

    /**
     * @param question_response_answer_comparer $question (presumably also a
     * {@link question_definition}) the question we are doing the grading for.
     */
    public function __construct(question_response_answer_comparer $question) {
        $this->question = $question;
    }

    public function grade(array $response) {
        foreach ($this->question->get_answers() as $aid => $answer) {
            if ($this->question->compare_response_with_answer($response, $answer)) {
                $answer->id = $aid;
                return $answer;
            }
        }
        return null;
    }

    public function get_correct_answer() {
        foreach ($this->question->get_answers() as $answer) {
            $state = question_state::graded_state_for_fraction($answer->fraction);
            if ($state == question_state::$gradedright) {
                return $answer;
            }
        }
        return null;
    }
}||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_EMPTY
                (AST_DIM
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_RETURN
                    (AST_ARRAY
                        (AST_ARRAY_ELEM
                            (AST_STATIC_CALL)
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_ARRAY
                        (AST_ARRAY_ELEM
                            (AST_STATIC_CALL)
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_RETURN
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_NEW
                    (
                        (AST_PROP
                            (AST_VAR))
                        (AST_DIM
                            (AST_VAR)
                            (SCALAR))
                        (AST_PROP
                            (AST_VAR))))
                (AST_PROP
                    (AST_VAR))))))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_EMPTY
                (AST_DIM
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_RETURN
                    (AST_ARRAY
                        (AST_ARRAY_ELEM
                            (AST_STATIC_CALL)
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_ARRAY
                        (AST_ARRAY_ELEM
                            (AST_NEW
                                (
                                    (SCALAR)
                                    (AST_DIM
                                        (AST_VAR)
                                        (SCALAR))
                                    (SCALAR)))
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_RETURN
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_NEW
                    (
                        (AST_PROP
                            (AST_VAR))
                        (AST_DIM
                            (AST_VAR)
                            (SCALAR))
                        (AST_PROP
                            (AST_VAR))))
                (AST_PROP
                    (AST_VAR))))))