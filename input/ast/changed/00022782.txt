    public function add_sidecalendar_blocks(core_calendar_renderer $renderer, $showfilters=false, $view=null) {
        if ($showfilters) {
            $filters = new block_contents();
            $filters->content = $renderer->fake_block_filters($this->courseid, $this->day, $this->month, $this->year, $view, $this->courses);
            $filters->footer = '';
            $filters->title = get_string('eventskey', 'calendar');
            $renderer->add_pretend_calendar_block($filters, BLOCK_POS_RIGHT);
        }
        $block = new block_contents;
        $block->content = $renderer->fake_block_threemonths($this);
        $block->footer = '';
        $block->title = get_string('monthlyview', 'calendar');
        $renderer->add_pretend_calendar_block($block, BLOCK_POS_RIGHT);
    }
}

/**
 * Returns option list for the poll interval setting.
 *
 * @return array An array of poll interval options. Interval => description.
 */
function calendar_get_pollinterval_choices() {
    return array(
        '0' => new lang_string('never', 'calendar'),
        '3600' => new lang_string('hourly', 'calendar'),
        '86400' => new lang_string('daily', 'calendar'),
        '604800' => new lang_string('weekly', 'calendar'),
        '2628000' => new lang_string('monthly', 'calendar'),
        '31536000' => new lang_string('annually', 'calendar')
    );
}

/**
 * Returns option list of available options for the calendar event type, given the current user and course.
 *
 * @param int $courseid The id of the course
 * @return array An array containing the event types the user can create.
 */
function calendar_get_eventtype_choices($courseid) {
    $choices = array();
    $allowed = new stdClass;
    calendar_get_allowed_types($allowed, $courseid);

    if ($allowed->user) {
        $choices['user'] = get_string('userevents', 'calendar');
    }
    if ($allowed->site) {
        $choices['site'] = get_string('siteevents', 'calendar');
    }
    if (!empty($allowed->courses)) {
        $choices['course'] = get_string('courseevents', 'calendar');
    }
    if (!empty($allowed->groups) and is_array($allowed->groups)) {
        $choices['group'] = get_string('group');
    }

    return array($choices, $allowed->groups);
}

/**
 * Add an iCalendar subscription to the database.
 *
 * @param stdClass $sub The subscription object (e.g. from the form)
 * @return int The insert ID, if any.
 */
function calendar_add_subscription($sub) {
    global $DB, $USER, $SITE;

    if ($sub->eventtype === 'site') {
        $sub->courseid = $SITE->id;
    } else if ($sub->eventtype === 'group' || $sub->eventtype === 'course') {
        $sub->courseid = $sub->course;
    } else {
        // User events.
        $sub->courseid = 0;
    }
    $sub->userid = $USER->id;

    // File subscriptions never update.
    if (empty($sub->url)) {
        $sub->pollinterval = 0;
    }

    if (!empty($sub->name)) {
        if (empty($sub->id)) {
            $id = $DB->insert_record('event_subscriptions', $sub);
            // we cannot cache the data here because $sub is not complete.
            return $id;
        } else {
            // Why are we doing an update here?
            calendar_update_subscription($sub);
            return $sub->id;
        }
    } else {
        print_error('errorbadsubscription', 'importcalendar');
    }
}

/**
 * Add an iCalendar event to the Moodle calendar.
 *
 * @param object $event The RFC-2445 iCalendar event
 * @param int $courseid The course ID
 * @param int $subscriptionid The iCalendar subscription ID
 * @throws dml_exception A DML specific exception is thrown for invalid subscriptionids.
 * @return int Code: 1=updated, 2=inserted, 0=error
 */
function calendar_add_icalendar_event($event, $courseid, $subscriptionid) {
    global $DB, $USER;

    // Probably an unsupported X-MICROSOFT-CDO-BUSYSTATUS event.
    if (empty($event->properties['SUMMARY'])) {
        return 0;
    }

    $name = $event->properties['SUMMARY'][0]->value;
    $name = str_replace('\n', '<br />', $name);
    $name = str_replace('\\', '', $name);
    $name = preg_replace('/\s+/', ' ', $name);

    $eventrecord = new stdClass;
    $eventrecord->name = clean_param($name, PARAM_NOTAGS);

    if (empty($event->properties['DESCRIPTION'][0]->value)) {
        $description = '';
    } else {
        $description = $event->properties['DESCRIPTION'][0]->value;
        $description = str_replace('\n', '<br />', $description);
        $description = str_replace('\\', '', $description);
        $description = preg_replace('/\s+/', ' ', $description);
    }
    $eventrecord->description = clean_param($description, PARAM_NOTAGS);

    // Probably a repeating event with RRULE etc. TODO: skip for now.
    if (empty($event->properties['DTSTART'][0]->value)) {
        return 0;
    }

    $eventrecord->timestart = strtotime($event->properties['DTSTART'][0]->value);
    if (empty($event->properties['DTEND'])) {
        $eventrecord->timeduration = 3600; // one hour if no end time specified
    } else {
        $eventrecord->timeduration = strtotime($event->properties['DTEND'][0]->value) - $eventrecord->timestart;
    }
    $eventrecord->uuid = $event->properties['UID'][0]->value;
    $eventrecord->timemodified = time();

    // Add the iCal subscription details if required.
    // We should never do anything with an event without a subscription reference.
    $sub = calendar_get_subscription($subscriptionid);
    $eventrecord->subscriptionid = $subscriptionid;
    $eventrecord->userid = $sub->userid;
    $eventrecord->groupid = $sub->groupid;
    $eventrecord->courseid = $sub->courseid;
    $eventrecord->eventtype = $sub->eventtype;

    if ($updaterecord = $DB->get_record('event', array('uuid' => $eventrecord->uuid))) {
        $eventrecord->id = $updaterecord->id;
        if ($DB->update_record('event', $eventrecord)) {
            return CALENDAR_IMPORT_EVENT_UPDATED;
        } else {
            return 0;
        }
    } else {
        if ($DB->insert_record('event', $eventrecord)) {
            return CALENDAR_IMPORT_EVENT_INSERTED;
        } else {
            return 0;
        }
    }
}

/**
 * Update a subscription from the form data in one of the rows in the existing subscriptions table.
 *
 * @param int $subscriptionid The ID of the subscription we are acting upon.
 * @param int $pollinterval The poll interval to use.
 * @param int $action The action to be performed. One of update or remove.
 * @throws dml_exception if invalid subscriptionid is provided
 * @return string A log of the import progress, including errors
 */
function calendar_process_subscription_row($subscriptionid, $pollinterval, $action) {

    // Fetch the subscription from the database making sure it exists.
    $sub = calendar_get_subscription($subscriptionid);

    // Update or remove the subscription, based on action.
    switch ($action) {
        case CALENDAR_SUBSCRIPTION_UPDATE:
            // Skip updating file subscriptions.
            if (empty($sub->url)) {
                break;
            }
            $sub->pollinterval = $pollinterval;
            calendar_update_subscription($sub);

            // Update the events.
            return "<p>".get_string('subscriptionupdated', 'calendar', $sub->name)."</p>" . calendar_update_subscription_events($subscriptionid);

        case CALENDAR_SUBSCRIPTION_REMOVE:
            calendar_delete_subscription($subscriptionid);
            return get_string('subscriptionremoved', 'calendar', $sub->name);
            break;

        default:
            break;
    }
    return '';
}

/**
 * Delete subscription and all related events.
 *
 * @param int|stdClass $subscription subscription or it's id, which needs to be deleted.
 */
function calendar_delete_subscription($subscription) {
    global $DB;

    if (is_object($subscription)) {
        $subscription = $subscription->id;
    }
    // Delete subscription and related events.
    $DB->delete_records('event', array('subscriptionid' => $subscription));
    $DB->delete_records('event_subscriptions', array('id' => $subscription));
    cache_helper::invalidate_by_definition('core', 'calendar_subscriptions', array(), array($subscription));
}
/**
 * From a URL, fetch the calendar and return an iCalendar object.
 *
 * @param string $url The iCalendar URL
 * @return stdClass The iCalendar object
 */
function calendar_get_icalendar($url) {
    global $CFG;

    require_once($CFG->libdir.'/filelib.php');

    $curl = new curl();
    $curl->setopt(array('CURLOPT_FOLLOWLOCATION' => 1, 'CURLOPT_MAXREDIRS' => 5));
    $calendar = $curl->get($url);
    // Http code validation should actually be the job of curl class.
    if (!$calendar || $curl->info['http_code'] != 200 || !empty($curl->errorno)) {
        throw new moodle_exception('errorinvalidicalurl', 'calendar');
    }

    $ical = new iCalendar();
    $ical->unserialize($calendar);
    return $ical;
}

/**
 * Import events from an iCalendar object into a course calendar.
 *
 * @param stdClass $ical The iCalendar object.
 * @param int $courseid The course ID for the calendar.
 * @param int $subscriptionid The subscription ID.
 * @return string A log of the import progress, including errors.
 */
function calendar_import_icalendar_events($ical, $courseid, $subscriptionid = null) {
    global $DB;
    $return = '';
    $eventcount = 0;
    $updatecount = 0;

    // Large calendars take a while...
    set_time_limit(300);

    // Mark all events in a subscription with a zero timestamp.
    if (!empty($subscriptionid)) {
        $sql = "UPDATE {event} SET timemodified = :time WHERE subscriptionid = :id";
        $DB->execute($sql, array('time' => 0, 'id' => $subscriptionid));
    }
    foreach ($ical->components['VEVENT'] as $event) {
        $res = calendar_add_icalendar_event($event, $courseid, $subscriptionid);
        switch ($res) {
          case CALENDAR_IMPORT_EVENT_UPDATED:
            $updatecount++;
            break;
          case CALENDAR_IMPORT_EVENT_INSERTED:
            $eventcount++;
            break;
          case 0:
            $return .= '<p>'.get_string('erroraddingevent', 'calendar').': '.(empty($event->properties['SUMMARY'])?'('.get_string('notitle', 'calendar').')':$event->properties['SUMMARY'][0]->value)." </p>\n";
            break;
        }
    }
    $return .= "<p> ".get_string('eventsimported', 'calendar', $eventcount)."</p>";
    $return .= "<p> ".get_string('eventsupdated', 'calendar', $updatecount)."</p>";

    // Delete remaining zero-marked events since they're not in remote calendar.
    if (!empty($subscriptionid)) {
        $deletecount = $DB->count_records('event', array('timemodified' => 0, 'subscriptionid' => $subscriptionid));
        if (!empty($deletecount)) {
            $sql = "DELETE FROM {event} WHERE timemodified = :time AND subscriptionid = :id";
            $DB->execute($sql, array('time' => 0, 'id' => $subscriptionid));
            $return .= "<p> ".get_string('eventsdeleted', 'calendar').": {$deletecount} </p>\n";
        }
    }

    return $return;
}

/**
 * Fetch a calendar subscription and update the events in the calendar.
 *
 * @param int $subscriptionid The course ID for the calendar.
 * @return string A log of the import progress, including errors.
 */
function calendar_update_subscription_events($subscriptionid) {
    global $DB;

    $sub = calendar_get_subscription($subscriptionid);
    // Don't update a file subscription. TODO: Update from a new uploaded file.
    if (empty($sub->url)) {
        return 'File subscription not updated.';
    }
    $ical = calendar_get_icalendar($sub->url);
    $return = calendar_import_icalendar_events($ical, $sub->courseid, $subscriptionid);
    $sub->lastupdated = time();
    calendar_update_subscription($sub);
    return $return;
}

/**
 * Update a calendar subscription. Also updates the associated cache.
 *
 * @param stdClass|array $subscription Subscription record.
 * @throws coding_exception If something goes wrong
 * @since Moodle 2.5
 */
function calendar_update_subscription($subscription) {
    global $DB;

    if (is_array($subscription)) {
        $subscription = (object)$subscription;
    }
    if (empty($subscription->id) || !$DB->record_exists('event_subscriptions', array('id' => $subscription->id))) {
        throw new coding_exception('Cannot update a subscription without a valid id');
    }

    $DB->update_record('event_subscriptions', $subscription);
    // Update cache.
    $cache = cache::make('core', 'calendar_subscriptions');
    $cache->set($subscription->id, $subscription);
}

/**
 * Checks to see if the user can edit a given subscription feed.
 *
 * @param mixed $subscriptionorid Subscription object or id
 * @return bool true if current user can edit the subscription else false
 */
function calendar_can_edit_subscription($subscriptionorid) {
    global $DB;

    if (is_array($subscriptionorid)) {
        $subscription = (object)$subscriptionorid;
    } else if (is_object($subscriptionorid)) {
        $subscription = $subscriptionorid;
    } else {
        $subscription = calendar_get_subscription($subscriptionorid);
    }
    $allowed = new stdClass;
    $courseid = $subscription->courseid;
    $groupid = $subscription->groupid;
    calendar_get_allowed_types($allowed, $courseid);
    switch ($subscription->eventtype) {
        case 'user':
            return $allowed->user;
        case 'course':
            if (isset($allowed->courses[$courseid])) {
                return $allowed->courses[$courseid];
            } else {
                return false;
            }
        case 'site':
            return $allowed->site;
        case 'group':
            if (isset($allowed->groups[$groupid])) {
                return $allowed->groups[$groupid];
            } else {
                return false;
            }
        default:
            return false;
    }
}

/**
 * Update calendar subscriptions.
 *
 * @return bool
 */
function calendar_cron() {
    global $CFG, $DB;

    // In order to execute this we need bennu.
    require_once($CFG->libdir.'/bennu/bennu.inc.php');

    mtrace('Updating calendar subscriptions:');
    cron_trace_time_and_memory();

    $time = time();
    $subscriptions = $DB->get_records_sql('SELECT * FROM {event_subscriptions} WHERE pollinterval > 0 AND lastupdated + pollinterval < ?', array($time));
    foreach ($subscriptions as $sub) {
        mtrace("Updating calendar subscription {$sub->name} in course {$sub->courseid}");
        try {
            $log = calendar_update_subscription_events($sub->id);
        } catch (moodle_exception $ex) {

        }
        mtrace(trim(strip_tags($log)));
    }

    mtrace('Finished updating calendar subscriptions.');

    return true;
}||||||||    public function add_sidecalendar_blocks(core_calendar_renderer $renderer, $showfilters=false, $view=null) {
        if ($showfilters) {
            $filters = new block_contents();
            $filters->content = $renderer->fake_block_filters($this->courseid, 0, 0, 0, $view, $this->courses);
            $filters->footer = '';
            $filters->title = get_string('eventskey', 'calendar');
            $renderer->add_pretend_calendar_block($filters, BLOCK_POS_RIGHT);
        }
        $block = new block_contents;
        $block->content = $renderer->fake_block_threemonths($this);
        $block->footer = '';
        $block->title = get_string('monthlyview', 'calendar');
        $renderer->add_pretend_calendar_block($block, BLOCK_POS_RIGHT);
    }
}

/**
 * Returns option list for the poll interval setting.
 *
 * @return array An array of poll interval options. Interval => description.
 */
function calendar_get_pollinterval_choices() {
    return array(
        '0' => new lang_string('never', 'calendar'),
        '3600' => new lang_string('hourly', 'calendar'),
        '86400' => new lang_string('daily', 'calendar'),
        '604800' => new lang_string('weekly', 'calendar'),
        '2628000' => new lang_string('monthly', 'calendar'),
        '31536000' => new lang_string('annually', 'calendar')
    );
}

/**
 * Returns option list of available options for the calendar event type, given the current user and course.
 *
 * @param int $courseid The id of the course
 * @return array An array containing the event types the user can create.
 */
function calendar_get_eventtype_choices($courseid) {
    $choices = array();
    $allowed = new stdClass;
    calendar_get_allowed_types($allowed, $courseid);

    if ($allowed->user) {
        $choices['user'] = get_string('userevents', 'calendar');
    }
    if ($allowed->site) {
        $choices['site'] = get_string('siteevents', 'calendar');
    }
    if (!empty($allowed->courses)) {
        $choices['course'] = get_string('courseevents', 'calendar');
    }
    if (!empty($allowed->groups) and is_array($allowed->groups)) {
        $choices['group'] = get_string('group');
    }

    return array($choices, $allowed->groups);
}

/**
 * Add an iCalendar subscription to the database.
 *
 * @param stdClass $sub The subscription object (e.g. from the form)
 * @return int The insert ID, if any.
 */
function calendar_add_subscription($sub) {
    global $DB, $USER, $SITE;

    if ($sub->eventtype === 'site') {
        $sub->courseid = $SITE->id;
    } else if ($sub->eventtype === 'group' || $sub->eventtype === 'course') {
        $sub->courseid = $sub->course;
    } else {
        // User events.
        $sub->courseid = 0;
    }
    $sub->userid = $USER->id;

    // File subscriptions never update.
    if (empty($sub->url)) {
        $sub->pollinterval = 0;
    }

    if (!empty($sub->name)) {
        if (empty($sub->id)) {
            $id = $DB->insert_record('event_subscriptions', $sub);
            // we cannot cache the data here because $sub is not complete.
            return $id;
        } else {
            // Why are we doing an update here?
            calendar_update_subscription($sub);
            return $sub->id;
        }
    } else {
        print_error('errorbadsubscription', 'importcalendar');
    }
}

/**
 * Add an iCalendar event to the Moodle calendar.
 *
 * @param object $event The RFC-2445 iCalendar event
 * @param int $courseid The course ID
 * @param int $subscriptionid The iCalendar subscription ID
 * @throws dml_exception A DML specific exception is thrown for invalid subscriptionids.
 * @return int Code: 1=updated, 2=inserted, 0=error
 */
function calendar_add_icalendar_event($event, $courseid, $subscriptionid) {
    global $DB, $USER;

    // Probably an unsupported X-MICROSOFT-CDO-BUSYSTATUS event.
    if (empty($event->properties['SUMMARY'])) {
        return 0;
    }

    $name = $event->properties['SUMMARY'][0]->value;
    $name = str_replace('\n', '<br />', $name);
    $name = str_replace('\\', '', $name);
    $name = preg_replace('/\s+/', ' ', $name);

    $eventrecord = new stdClass;
    $eventrecord->name = clean_param($name, PARAM_NOTAGS);

    if (empty($event->properties['DESCRIPTION'][0]->value)) {
        $description = '';
    } else {
        $description = $event->properties['DESCRIPTION'][0]->value;
        $description = str_replace('\n', '<br />', $description);
        $description = str_replace('\\', '', $description);
        $description = preg_replace('/\s+/', ' ', $description);
    }
    $eventrecord->description = clean_param($description, PARAM_NOTAGS);

    // Probably a repeating event with RRULE etc. TODO: skip for now.
    if (empty($event->properties['DTSTART'][0]->value)) {
        return 0;
    }

    $eventrecord->timestart = strtotime($event->properties['DTSTART'][0]->value);
    if (empty($event->properties['DTEND'])) {
        $eventrecord->timeduration = 3600; // one hour if no end time specified
    } else {
        $eventrecord->timeduration = strtotime($event->properties['DTEND'][0]->value) - $eventrecord->timestart;
    }
    $eventrecord->uuid = $event->properties['UID'][0]->value;
    $eventrecord->timemodified = time();

    // Add the iCal subscription details if required.
    // We should never do anything with an event without a subscription reference.
    $sub = calendar_get_subscription($subscriptionid);
    $eventrecord->subscriptionid = $subscriptionid;
    $eventrecord->userid = $sub->userid;
    $eventrecord->groupid = $sub->groupid;
    $eventrecord->courseid = $sub->courseid;
    $eventrecord->eventtype = $sub->eventtype;

    if ($updaterecord = $DB->get_record('event', array('uuid' => $eventrecord->uuid))) {
        $eventrecord->id = $updaterecord->id;
        if ($DB->update_record('event', $eventrecord)) {
            return CALENDAR_IMPORT_EVENT_UPDATED;
        } else {
            return 0;
        }
    } else {
        if ($DB->insert_record('event', $eventrecord)) {
            return CALENDAR_IMPORT_EVENT_INSERTED;
        } else {
            return 0;
        }
    }
}

/**
 * Update a subscription from the form data in one of the rows in the existing subscriptions table.
 *
 * @param int $subscriptionid The ID of the subscription we are acting upon.
 * @param int $pollinterval The poll interval to use.
 * @param int $action The action to be performed. One of update or remove.
 * @throws dml_exception if invalid subscriptionid is provided
 * @return string A log of the import progress, including errors
 */
function calendar_process_subscription_row($subscriptionid, $pollinterval, $action) {

    // Fetch the subscription from the database making sure it exists.
    $sub = calendar_get_subscription($subscriptionid);

    // Update or remove the subscription, based on action.
    switch ($action) {
        case CALENDAR_SUBSCRIPTION_UPDATE:
            // Skip updating file subscriptions.
            if (empty($sub->url)) {
                break;
            }
            $sub->pollinterval = $pollinterval;
            calendar_update_subscription($sub);

            // Update the events.
            return "<p>".get_string('subscriptionupdated', 'calendar', $sub->name)."</p>" . calendar_update_subscription_events($subscriptionid);

        case CALENDAR_SUBSCRIPTION_REMOVE:
            calendar_delete_subscription($subscriptionid);
            return get_string('subscriptionremoved', 'calendar', $sub->name);
            break;

        default:
            break;
    }
    return '';
}

/**
 * Delete subscription and all related events.
 *
 * @param int|stdClass $subscription subscription or it's id, which needs to be deleted.
 */
function calendar_delete_subscription($subscription) {
    global $DB;

    if (is_object($subscription)) {
        $subscription = $subscription->id;
    }
    // Delete subscription and related events.
    $DB->delete_records('event', array('subscriptionid' => $subscription));
    $DB->delete_records('event_subscriptions', array('id' => $subscription));
    cache_helper::invalidate_by_definition('core', 'calendar_subscriptions', array(), array($subscription));
}
/**
 * From a URL, fetch the calendar and return an iCalendar object.
 *
 * @param string $url The iCalendar URL
 * @return stdClass The iCalendar object
 */
function calendar_get_icalendar($url) {
    global $CFG;

    require_once($CFG->libdir.'/filelib.php');

    $curl = new curl();
    $curl->setopt(array('CURLOPT_FOLLOWLOCATION' => 1, 'CURLOPT_MAXREDIRS' => 5));
    $calendar = $curl->get($url);
    // Http code validation should actually be the job of curl class.
    if (!$calendar || $curl->info['http_code'] != 200 || !empty($curl->errorno)) {
        throw new moodle_exception('errorinvalidicalurl', 'calendar');
    }

    $ical = new iCalendar();
    $ical->unserialize($calendar);
    return $ical;
}

/**
 * Import events from an iCalendar object into a course calendar.
 *
 * @param stdClass $ical The iCalendar object.
 * @param int $courseid The course ID for the calendar.
 * @param int $subscriptionid The subscription ID.
 * @return string A log of the import progress, including errors.
 */
function calendar_import_icalendar_events($ical, $courseid, $subscriptionid = null) {
    global $DB;
    $return = '';
    $eventcount = 0;
    $updatecount = 0;

    // Large calendars take a while...
    set_time_limit(300);

    // Mark all events in a subscription with a zero timestamp.
    if (!empty($subscriptionid)) {
        $sql = "UPDATE {event} SET timemodified = :time WHERE subscriptionid = :id";
        $DB->execute($sql, array('time' => 0, 'id' => $subscriptionid));
    }
    foreach ($ical->components['VEVENT'] as $event) {
        $res = calendar_add_icalendar_event($event, $courseid, $subscriptionid);
        switch ($res) {
          case CALENDAR_IMPORT_EVENT_UPDATED:
            $updatecount++;
            break;
          case CALENDAR_IMPORT_EVENT_INSERTED:
            $eventcount++;
            break;
          case 0:
            $return .= '<p>'.get_string('erroraddingevent', 'calendar').': '.(empty($event->properties['SUMMARY'])?'('.get_string('notitle', 'calendar').')':$event->properties['SUMMARY'][0]->value)." </p>\n";
            break;
        }
    }
    $return .= "<p> ".get_string('eventsimported', 'calendar', $eventcount)."</p>";
    $return .= "<p> ".get_string('eventsupdated', 'calendar', $updatecount)."</p>";

    // Delete remaining zero-marked events since they're not in remote calendar.
    if (!empty($subscriptionid)) {
        $deletecount = $DB->count_records('event', array('timemodified' => 0, 'subscriptionid' => $subscriptionid));
        if (!empty($deletecount)) {
            $sql = "DELETE FROM {event} WHERE timemodified = :time AND subscriptionid = :id";
            $DB->execute($sql, array('time' => 0, 'id' => $subscriptionid));
            $return .= "<p> ".get_string('eventsdeleted', 'calendar').": {$deletecount} </p>\n";
        }
    }

    return $return;
}

/**
 * Fetch a calendar subscription and update the events in the calendar.
 *
 * @param int $subscriptionid The course ID for the calendar.
 * @return string A log of the import progress, including errors.
 */
function calendar_update_subscription_events($subscriptionid) {
    global $DB;

    $sub = calendar_get_subscription($subscriptionid);
    // Don't update a file subscription. TODO: Update from a new uploaded file.
    if (empty($sub->url)) {
        return 'File subscription not updated.';
    }
    $ical = calendar_get_icalendar($sub->url);
    $return = calendar_import_icalendar_events($ical, $sub->courseid, $subscriptionid);
    $sub->lastupdated = time();
    calendar_update_subscription($sub);
    return $return;
}

/**
 * Update a calendar subscription. Also updates the associated cache.
 *
 * @param stdClass|array $subscription Subscription record.
 * @throws coding_exception If something goes wrong
 * @since Moodle 2.5
 */
function calendar_update_subscription($subscription) {
    global $DB;

    if (is_array($subscription)) {
        $subscription = (object)$subscription;
    }
    if (empty($subscription->id) || !$DB->record_exists('event_subscriptions', array('id' => $subscription->id))) {
        throw new coding_exception('Cannot update a subscription without a valid id');
    }

    $DB->update_record('event_subscriptions', $subscription);
    // Update cache.
    $cache = cache::make('core', 'calendar_subscriptions');
    $cache->set($subscription->id, $subscription);
}

/**
 * Checks to see if the user can edit a given subscription feed.
 *
 * @param mixed $subscriptionorid Subscription object or id
 * @return bool true if current user can edit the subscription else false
 */
function calendar_can_edit_subscription($subscriptionorid) {
    global $DB;

    if (is_array($subscriptionorid)) {
        $subscription = (object)$subscriptionorid;
    } else if (is_object($subscriptionorid)) {
        $subscription = $subscriptionorid;
    } else {
        $subscription = calendar_get_subscription($subscriptionorid);
    }
    $allowed = new stdClass;
    $courseid = $subscription->courseid;
    $groupid = $subscription->groupid;
    calendar_get_allowed_types($allowed, $courseid);
    switch ($subscription->eventtype) {
        case 'user':
            return $allowed->user;
        case 'course':
            if (isset($allowed->courses[$courseid])) {
                return $allowed->courses[$courseid];
            } else {
                return false;
            }
        case 'site':
            return $allowed->site;
        case 'group':
            if (isset($allowed->groups[$groupid])) {
                return $allowed->groups[$groupid];
            } else {
                return false;
            }
        default:
            return false;
    }
}

/**
 * Update calendar subscriptions.
 *
 * @return bool
 */
function calendar_cron() {
    global $CFG, $DB;

    // In order to execute this we need bennu.
    require_once($CFG->libdir.'/bennu/bennu.inc.php');

    mtrace('Updating calendar subscriptions:');
    cron_trace_time_and_memory();

    $time = time();
    $subscriptions = $DB->get_records_sql('SELECT * FROM {event_subscriptions} WHERE pollinterval > 0 AND lastupdated + pollinterval < ?', array($time));
    foreach ($subscriptions as $sub) {
        mtrace("Updating calendar subscription {$sub->name} in course {$sub->courseid}");
        try {
            $log = calendar_update_subscription_events($sub->id);
        } catch (moodle_exception $ex) {

        }
        mtrace(trim(strip_tags($log)));
    }

    mtrace('Finished updating calendar subscriptions.');

    return true;
}||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_PROP
                                (AST_VAR))
                            (AST_PROP
                                (AST_VAR))
                            (AST_PROP
                                (AST_VAR))
                            (AST_PROP
                                (AST_VAR))
                            (AST_VAR)
                            (AST_PROP
                                (AST_VAR)))))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_CALL
                        (
                            (SCALAR)
                            (SCALAR))))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_VAR)
                        (AST_CONST))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (SCALAR))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_CALL
            (
                (SCALAR)
                (SCALAR))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)
            (AST_CONST))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR)
                            (SCALAR)
                            (SCALAR)
                            (AST_VAR)
                            (AST_PROP
                                (AST_VAR)))))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_CALL
                        (
                            (SCALAR)
                            (SCALAR))))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_VAR)
                        (AST_CONST))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (SCALAR))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_CALL
            (
                (SCALAR)
                (SCALAR))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)
            (AST_CONST))))