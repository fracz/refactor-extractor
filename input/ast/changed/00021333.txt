    public function get_all_block_regions() {
        // Legacy fallback.
        if (empty($this->layouts)) {
            return array(
                'side-pre' => get_string('region-side-pre', 'theme_standard'),
                'side-post' => get_string('region-side-post', 'theme_standard'),
            );
        }

        $regions = array();
        foreach ($this->layouts as $layoutinfo) {
            $ownertheme = $this->name;
            if (strpos($layoutinfo['layout'], 'standard:') === 0) {
                $ownertheme = 'standard';
            } else if (strpos($layoutinfo['layout'], 'parent:') === 0) {
                $ownertheme = $this->parent;
            }

            foreach ($layoutinfo['regions'] as $region) {
                $regions[$region] = get_string('region-' . $region, 'theme_' . $ownertheme);
            }
        }
        return $regions;
    }

    /**
     * Helper method used by {@link update_legacy_information()}. Update one entry
     * in the $this->pluginsheets array, based on the legacy $property propery.
     * @param string $plugintype e.g. 'mod'.
     * @param string $property e.g. 'modsheets'.
     * @return void
     */
||||||||    public function get_all_block_regions() {
        $regions = array();
        //TODO: this is weird because the regions from different layouts override each other
        foreach ($this->layouts as $layoutinfo) {
            foreach ($layoutinfo['regions'] as $region) {
                $regions[$region] = get_string('region-' . $region, 'theme_' . $layoutinfo['theme']);
            }
        }
        return $regions;
    }
}


/**
 * This class keeps track of which HTML tags are currently open.
 *
 * This makes it much easier to always generate well formed XHTML output, even
 * if execution terminates abruptly. Any time you output some opening HTML
 * without the matching closing HTML, you should push the necessary close tags
 * onto the stack.
 *
 * @copyright 2009 Tim Hunt
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @since     Moodle 2.0
 */
class xhtml_container_stack {
    /** @var array stores the list of open containers. */
    protected $opencontainers = array();
    /**
     * @var array in developer debug mode, stores a stack trace of all opens and
     * closes, so we can output helpful error messages when there is a mismatch.
     */
    protected $log = array();
    /**
     * Store whether we are developer debug mode. We need this in several places
     * including in the destructor where we may no thave access to $CFG.
     * @var boolean
     */
    protected $isdebugging;

    public function __construct() {
        $this->isdebugging = debugging('', DEBUG_DEVELOPER);
    }

    /**
     * Push the close HTML for a recently opened container onto the stack.
     * @param string $type The type of container. This is checked when {@link pop()}
     *      is called and must match, otherwise a developer debug warning is output.
     * @param string $closehtml The HTML required to close the container.
     * @return void
     */
    public function push($type, $closehtml) {
        $container = new stdClass;
        $container->type = $type;
        $container->closehtml = $closehtml;
        if ($this->isdebugging) {
            $this->log('Open', $type);
        }
        array_push($this->opencontainers, $container);
    }

    /**
     * Pop the HTML for the next closing container from the stack. The $type
     * must match the type passed when the container was opened, otherwise a
     * warning will be output.
     * @param string $type The type of container.
     * @return string the HTML required to close the container.
     */
    public function pop($type) {
        if (empty($this->opencontainers)) {
            debugging('<p>There are no more open containers. This suggests there is a nesting problem.</p>' .
                    $this->output_log(), DEBUG_DEVELOPER);
            return;
        }

        $container = array_pop($this->opencontainers);
        if ($container->type != $type) {
            debugging('<p>The type of container to be closed (' . $container->type .
                    ') does not match the type of the next open container (' . $type .
                    '). This suggests there is a nesting problem.</p>' .
                    $this->output_log(), DEBUG_DEVELOPER);
        }
        if ($this->isdebugging) {
            $this->log('Close', $type);
        }
        return $container->closehtml;
    }

    /**
     * Close all but the last open container. This is useful in places like error
     * handling, where you want to close all the open containers (apart from <body>)
     * before outputting the error message.
     * @param bool $shouldbenone assert that the stack should be empty now - causes a
     *      developer debug warning if it isn't.
     * @return string the HTML required to close any open containers inside <body>.
     */
    public function pop_all_but_last($shouldbenone = false) {
        if ($shouldbenone && count($this->opencontainers) != 1) {
            debugging('<p>Some HTML tags were opened in the body of the page but not closed.</p>' .
                    $this->output_log(), DEBUG_DEVELOPER);
        }
        $output = '';
        while (count($this->opencontainers) > 1) {
            $container = array_pop($this->opencontainers);
            $output .= $container->closehtml;
        }
        return $output;
    }

    /**
     * You can call this function if you want to throw away an instance of this
     * class without properly emptying the stack (for example, in a unit test).
     * Calling this method stops the destruct method from outputting a developer
     * debug warning. After calling this method, the instance can no longer be used.
     * @return void
     */
    public function discard() {
        $this->opencontainers = null;
    }

    /**
     * Emergency fallback. If we get to the end of processing and not all
     * containers have been closed, output the rest with a developer debug warning.
     * @return void
     */
    public function __destruct() {
        if (empty($this->opencontainers)) {
            return;
        }

        // TODO: MDL-20625 this looks dangerous and problematic because we never know
        //       the order of calling of constructors ==> the transaction warning will not be included

        // It seems you cannot rely on $CFG, and hence the debugging function here,
        // becuase $CFG may be destroyed before this object is.
        if ($this->isdebugging) {
            echo '<div class="notifytiny"><p>Some containers were left open. This suggests there is a nesting problem.</p>' .
                    $this->output_log() . '</div>';
        }
        echo $this->pop_all_but_last();
        $container = array_pop($this->opencontainers);
        echo $container->closehtml;
    }

    /**
     * Adds an entry to the log.
     * @param string $action The name of the action
     * @param string $type The type of action
     * @return void
     */
    protected function log($action, $type) {
        $this->log[] = '<li>' . $action . ' ' . $type . ' at:' .
                format_backtrace(debug_backtrace()) . '</li>';
    }

    /**
     * Outputs the log's contents as a HTML list.
     * @return string HTML list of the log
     */
    protected function output_log() {
        return '<ul>' . implode("\n", $this->log) . '</ul>';
    }
}||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_IF
        (AST_IF_ELEM
            (AST_EMPTY
                (AST_PROP
                    (AST_VAR)))
            (
                (AST_RETURN
                    (AST_ARRAY
                        (AST_ARRAY_ELEM
                            (AST_CALL
                                (
                                    (SCALAR)
                                    (SCALAR)))
                            (SCALAR))
                        (AST_ARRAY_ELEM
                            (AST_CALL
                                (
                                    (SCALAR)
                                    (SCALAR)))
                            (SCALAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_FOREACH
        (AST_PROP
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_PROP
                    (AST_VAR)))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_CALL
                            (
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR))
                                (SCALAR)))
                        (SCALAR))
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (SCALAR))))
                (AST_IF_ELEM
                    (NULL)
                    (
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_BINARY_OP
                                    (AST_CALL
                                        (
                                            (AST_DIM
                                                (AST_VAR)
                                                (SCALAR))
                                            (SCALAR)))
                                    (SCALAR))
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_PROP
                                            (AST_VAR)))))))))
            (AST_FOREACH
                (AST_DIM
                    (AST_VAR)
                    (SCALAR))
                (AST_VAR)
                (NULL)
                (
                    (AST_ASSIGN
                        (AST_DIM
                            (AST_VAR)
                            (AST_VAR))
                        (AST_CALL
                            (
                                (AST_BINARY_OP
                                    (SCALAR)
                                    (AST_VAR))
                                (AST_BINARY_OP
                                    (SCALAR)
                                    (AST_VAR)))))))))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_FOREACH
        (AST_PROP
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_FOREACH
                (AST_DIM
                    (AST_VAR)
                    (SCALAR))
                (AST_VAR)
                (NULL)
                (
                    (AST_ASSIGN
                        (AST_DIM
                            (AST_VAR)
                            (AST_VAR))
                        (AST_CALL
                            (
                                (AST_BINARY_OP
                                    (SCALAR)
                                    (AST_VAR))
                                (AST_BINARY_OP
                                    (SCALAR)
                                    (AST_DIM
                                        (AST_VAR)
                                        (SCALAR))))))))))
    (AST_RETURN
        (AST_VAR)))