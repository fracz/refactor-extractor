	function get($guid) {
		// This should not be a static local var. Notice that cache writing occurs in a completely
		// different instance outside this function.
		// @todo We need a single Memcache instance with a shared pool of namespace wrappers. This function would pull an instance from the pool.
		static $shared_cache;

		// We could also use: if (!(int) $guid) { return false },
		// but that evaluates to a false positive for $guid = true.
		// This is a bit slower, but more thorough.
		if (!is_numeric($guid) || $guid === 0 || $guid === '0') {
			return false;
		}

		// Check local cache first
		$new_entity = _elgg_retrieve_cached_entity($guid);
		if ($new_entity) {
			return $new_entity;
		}

		// Check shared memory cache, if available
		if (null === $shared_cache) {
			if (is_memcache_available()) {
				$shared_cache = new \ElggMemcache('new_entity_cache');
			} else {
				$shared_cache = false;
			}
		}

		// until ACLs in memcache, DB query is required to determine access
		$entity_row = get_entity_as_row($guid);
		if (!$entity_row) {
			return false;
		}

		if ($shared_cache) {
			$cached_entity = $shared_cache->load($guid);
			// @todo store ACLs in memcache https://github.com/elgg/elgg/issues/3018#issuecomment-13662617
			if ($cached_entity) {
				// @todo use ACL and cached entity access_id to determine if user can see it
				return $cached_entity;
			}
		}

		// don't let incomplete entities cause fatal exceptions
		try {
			$new_entity = entity_row_to_elggstar($entity_row);
		} catch (IncompleteEntityException $e) {
			return false;
		}

		if ($new_entity) {
			_elgg_cache_entity($new_entity);
		}
		return $new_entity;
	}

	/**
	 * Does an entity exist?
	 *
	 * This function checks for the existence of an entity independent of access
	 * permissions. It is useful for situations when a user cannot access an entity
	 * and it must be determined whether entity has been deleted or the access level
	 * has changed.
	 *
	 * @param int $guid The GUID of the entity
	 *
	 * @return bool
	 */
||||||||	function get($guid, $type = '') {
		// We could also use: if (!(int) $guid) { return false },
		// but that evaluates to a false positive for $guid = true.
		// This is a bit slower, but more thorough.
		if (!is_numeric($guid) || $guid === 0 || $guid === '0') {
			return false;
		}

		// Check local cache first
		$new_entity = _elgg_retrieve_cached_entity($guid);
		if ($new_entity) {
			if ($type) {
				return elgg_instanceof($new_entity, $type) ? $new_entity : false;
			}
			return $new_entity;
		}

		$options = [
			'guid' => $guid,
			'limit' => 1,
			'site_guids' => ELGG_ENTITIES_ANY_VALUE, // for BC with get_entity, allow matching any site
		];
		if ($type) {
			$options['type'] = $type;
		}
		$entities = $this->getEntities($options);
		return $entities ? $entities[0] : false;
	}

	/**
	 * Does an entity exist?
	 *
	 * This function checks for the existence of an entity independent of access
	 * permissions. It is useful for situations when a user cannot access an entity
	 * and it must be determined whether entity has been deleted or the access level
	 * has changed.
	 *
	 * @param int $guid The GUID of the entity
	 *
	 * @return bool
	 */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_STATIC
        (AST_VAR)
        (NULL))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_UNARY_OP
                        (AST_CALL
                            (
                                (AST_VAR))))
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR)))
                (AST_BINARY_OP
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_RETURN
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (AST_VAR))
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_CALL)
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_NEW
                                    (
                                        (SCALAR))))))
                    (AST_IF_ELEM
                        (NULL)
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_CONST))))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR))))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_VAR)
                        (
                            (AST_RETURN
                                (AST_VAR))))))))
    (AST_TRY
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (AST_VAR)))))
        (AST_CATCH_LIST
            (AST_CATCH
                (AST_NAME_LIST)
                (AST_VAR)
                (
                    (AST_RETURN
                        (AST_CONST)))))
        (NULL))
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_CALL
                    (
                        (AST_VAR))))))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_UNARY_OP
                        (AST_CALL
                            (
                                (AST_VAR))))
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR)))
                (AST_BINARY_OP
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_VAR)
                        (
                            (AST_RETURN
                                (AST_CONDITIONAL
                                    (AST_CALL
                                        (
                                            (AST_VAR)
                                            (AST_VAR)))
                                    (AST_VAR)
                                    (AST_CONST))))))
                (AST_RETURN
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_VAR)
                (SCALAR))
            (AST_ARRAY_ELEM
                (SCALAR)
                (SCALAR))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (SCALAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_RETURN
        (AST_CONDITIONAL
            (AST_VAR)
            (AST_DIM
                (AST_VAR)
                (SCALAR))
            (AST_CONST))))