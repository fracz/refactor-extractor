	function adjust_media_urls() {

		if ($this->forceplugins) {

			// make sure the Moodle media plugin is available
			global $CFG;
			include_once "$CFG->dirroot/filter/mediaplugin/filter.php";

			// exclude swf files from the filter
			//$CFG->filter_mediaplugin_ignore_swf = true;

			$q = '["'."']?"; // single, double, or no quote

			// patterns to media files types and paths
			$filetype = "avi|mpeg|mpg|mp3|mov|swf|wmv";
			$filepath = ".*?\.($filetype)";

			$tagopen = '(?:(<)|(\\\\u003C))'; // left angle-bracket (uses two parenthese)
			$tagclose = '(?(1)>|(?(2)\\\\u003E))'; // right angle-bracket (to match the left one)
			$tagreopen = '(?(1)<|(?(2)\\\\u003C))'; // another left angle-bracket (to match the first one)

			// pattern to match <PARAM> tags which contain the file path
			//	wmp	     : url
			//	quicktime  : src
			//	realplayer : src
			//	flash      : movie (doesn't need replacing)
			$param_url = "/{$tagopen}PARAM\s+.*?NAME=$q(?:movie|src|url)$q\s+.*?VALUE=$q($filepath)$q.*?$tagclose/is";

			// pattern to match <a> tags which link to multimedia files
			$link_url = "/{$tagopen}A\s.*?HREF=$q($filepath)$q.*?$tagclose.*?$tagreopen\/A$tagclose/is";

			// extract <OBJECT> tags
			preg_match_all("/{$tagopen}OBJECT\s+.*?{$tagclose}(.*?){$tagreopen}\/OBJECT{$tagclose}/is", $this->html, $objects);

			$i_max = count($objects[0]);
			for ($i=0; $i<$i_max; $i++) {

				// extract URL from <PARAM> or <A>
				$url = '';
				if (preg_match($param_url, $objects[3][$i], $matches) || preg_match($link_url, $objects[3][$i], $matches)) {
					$url = $matches[3];
				}

				if ($url) {
					$txt = preg_replace("/$tagopen.*?$tagclose/", '', $objects[3][$i]);

					// if url is in the query string, remove the leading characters
					$url = preg_replace('/^[^?]*\?([^=]+=[^&]*&)*[^=]+=([^&]*)$/', '$2', $url, 1);
					$link = '<a href="'.$url.'">'.$txt.'</a>';

					$new_object = mediaplugin_filter($this->filedir, $link);
					$new_object = str_replace($link, '', $new_object);
					$new_object = str_replace('&amp;', '&', $new_object);

					$this->html = str_replace($objects[0][$i], $new_object, $this->html);
				}
			}
		}
	}

} // end class

function hotpot_convert_stylesheets_urls($baseurl, $reference, $css, $stripslashes=true) {
	if ($stripslashes) {
		$css = stripslashes($css);
	}
	$search = '|'.'(?<='.'url'.'\('.')'."(.+?)".'(?='.'\)'.')'.'|ise';
	$replace = "hotpot_convert_url('".$baseurl."','".$reference."','\\1')";
	return preg_replace($search, $replace, $css);
}
function hotpot_convert_preloadimages_urls($baseurl, $reference, $urls, $stripslashes=true) {
	if ($stripslashes) {
		$urls = stripslashes($urls);
	}
	$search = '|(?<=["'."'])([^,'".'"]*?)(?=["'."'])|ise";
	$replace = "hotpot_convert_url('".$baseurl."','".$reference."','\\1')";
	return preg_replace($search, $replace, $urls);
}
function hotpot_convert_navbutton_url($baseurl, $reference, $url, $course, $stripslashes=true) {
	global $CFG;

	if ($stripslashes) {
		$url = stripslashes($url);
	}
	$url = hotpot_convert_url($baseurl, $reference, $url, false);

	// is this a $url for another hotpot in this course ?
	if (preg_match("|^$baseurl(.*)$|", $url, $matches)) {
		if ($records = get_records_select('hotpot', "course='$course' AND reference='".$matches[1]."'")) {
			$ids = array_keys($records);
			$url = "$CFG->wwwroot/mod/hotpot/view.php?hp=".$ids[0];
		}
	}

	return $url;
}

function hotpot_convert_relative_url($baseurl, $reference, $opentag, $url, $closetag, $stripslashes=true) {
	if ($stripslashes) {
		$opentag = stripslashes($opentag);
		$url = stripslashes($url);
		$closetag = stripslashes($closetag);
	}

	// catch <PARAM name="FlashVars" value="TheSound=soundfile.mp3">
	//	ampersands can appear as "&", "&amp;" or "&amp;#x0026;amp;"
	if (preg_match('|^'.'\w+=[^&]+'.'('.'&((amp;#x0026;)?amp;)?'.'\w+=[^&]+)*'.'$|', $url)) {
		$query = $url;
		$url = '';
		$fragment = '';

	// parse the $url into $matches
	//	[1] path
	//	[2] query string, if any
	//	[3] anchor fragment, if any
	} else if (preg_match('|^'.'([^?]*)'.'((?:\\?[^#]*)?)'.'((?:#.*)?)'.'$|', $url, $matches)) {
		$url = $matches[1];
		$query = $matches[2];
		$fragment = $matches[3];

	// these appears to be no query or fragment in this url
	} else {
		$query = '';
		$fragment = '';
	}

	if ($url) {
		$url = hotpot_convert_url($baseurl, $reference, $url, false);
	}

	if ($query) {
		$search = '#'.'(file|src|thesound)='."([^&]+)".'#ise';
		$replace = "'\\1='.hotpot_convert_url('".$baseurl."','".$reference."','\\2')";
		$query = preg_replace($search, $replace, $query);
	}

	$url = $opentag.$url.$query.$fragment.$closetag;

	return $url;
}

function hotpot_convert_url($baseurl, $reference, $url, $stripslashes=true) {
	// maintain a cache of converted urls
	static $HOTPOT_RELATIVE_URLS = array();

	if ($stripslashes) {
		$url = stripslashes($url);
	}

	// is this an absolute url? (or javascript pseudo url)
	if (preg_match('%^(http://|/|javascript:)%i', $url)) {
		// do nothing

	// has this relative url already been converted?
	} else if (isset($HOTPOT_RELATIVE_URLS[$url])) {
		$url = $HOTPOT_RELATIVE_URLS[$url];

	} else {
		$relativeurl = $url;

		// get the subdirectory, $dir, of the quiz $reference
		$dir = dirname($reference);

		// allow for leading "./" and "../"
		while (preg_match('|^(\.{1,2})/(.*)$|', $url, $matches)) {
			if ($matches[1]=='..') {
				$dir = dirname($dir);
			}
			$url = $matches[2];
		}

		// add subdirectory, $dir, to $baseurl, if necessary
		if ($dir && $dir<>'.') {
			$baseurl .= "$dir/";
		}

		// prefix $url with $baseurl
		$url = "$baseurl$url";

		// add url to cache
		$HOTPOT_RELATIVE_URLS[$relativeurl] = $url;
	}
	return $url;
}

// ===================================================
// function for adding attempt questions and responses
// ===================================================

function hotpot_add_attempt_details(&$attempt) {

	// encode ampersands so that HTML entities are preserved in the XML parser
	// N.B. ampersands inside <![CDATA[ ]]> blocks do NOT need to be encoded

	$old = &$attempt->details; // shortcut to "old" details
	$new = '';
	$str_start = 0;
	while (($cdata_start = strpos($old, '<![CDATA[', $str_start)) && ($cdata_end = strpos($old, ']]>', $cdata_start))) {
		$cdata_end += 3;
		$new .= str_replace('&', '&amp;', substr($old, $str_start, $cdata_start-$str_start)).substr($old, $cdata_start, $cdata_end-$cdata_start);
		$str_start = $cdata_end;
	}
	$new .= str_replace('&', '&amp;', substr($old, $str_start));
	unset($old);

	// parse the attempt details as xml
	$details = new hotpot_xml_tree($new, "['hpjsresult']['#']");

	$num = -1;
	$q_num = -1;
	$question = NULL;
	$reponse = NULL;

	$i = 0;
	$tags = 'fields,field';

	while (($field="[$i]['#']") && $details->xml_value($tags, $field)) {

		$name = $details->xml_value($tags, $field."['fieldname'][0]['#']");
		$data = $details->xml_value($tags, $field."['fielddata'][0]['#']");

		// parse the field name into $matches
		//	[1] quiz type
		//	[2] attempt detail name
		if (preg_match('/^(\w+?)_(\w+)$/', $name, $matches)) {
			$quiztype = strtolower($matches[1]);
			$name = strtolower($matches[2]);

			// parse the attempt detail $name into $matches
			//	[1] question number
			//	[2] question detail name
			if (preg_match('/^q(\d+)_(\w+)$/', $name, $matches)) {
				$num = $matches[1];
				$name = strtolower($matches[2]);
				$data = addslashes($data);

				// adjust JCross question numbers
				if (preg_match('/^(across|down)(.*)$/', $name, $matches)) {
					$num .= '_'.$matches[1]; // e.g. 01_across, 02_down
					$name = $matches[2];
					if (substr($name, 0, 1)=='_') {
						$name = substr($name, 1); // remove leading '_'
					}
				}

				// is this a new question (or the first one)?
				if ($q_num<>$num) {

					// add previous question and response, if any
					hotpot_add_response($attempt, $question, $response);

					// initialize question object
					$question = NULL;
					$question->name = '';
					$question->text = '';
					$question->hotpot = $attempt->hotpot;

					// initialize response object
					$response = NULL;
					$response->attempt = $attempt->id;

					// update question number
					$q_num = $num;
				}

				// adjust field name and value, and set question type
				// (may not be necessary one day)
				hotpot_adjust_response_field($quiztype, $question, $num, $name, $data);

				// add $data to the question/response details
				switch ($name) {
					case 'name':
					case 'type':
						$question->$name = $data;
						break;
					case 'text':
						$question->$name = hotpot_string_id($data);
						break;

					case 'correct':
					case 'ignored':
					case 'wrong':
						$response->$name = hotpot_string_ids($data);
						break;

					case 'score':
					case 'weighting':
					case 'hints':
					case 'clues':
					case 'checks':
						$response->$name = intval($data);
						break;
				}

			} else { // attempt details

				// adjust field name and value
				hotpot_adjust_response_field($quiztype, $question, $num='', $name, $data);

				// add $data to the attempt details
				if ($name=='penalties') {
					$attempt->$name = intval($data);
				}
			}
		}

		$i++;
	} // end while

	// add the final question and response, if any
	hotpot_add_response($attempt, $question, $response);
}
function hotpot_add_response(&$attempt, &$question, &$response) {
	global $db, $next_url;

	$loopcount = 1;

	$looping = isset($question) && isset($question->name) && isset($response);
	while ($looping) {

		if ($loopcount==1) {
			$questionname = $question->name;
		}

		if (!$question->id = get_field('hotpot_questions', 'id', 'name', $question->name, 'hotpot', $attempt->hotpot)) {
			// add question record
			if (!$question->id = insert_record('hotpot_questions', $question)) {
				error("Could not add question record (attempt_id=$attempt->id): ".$db->ErrorMsg(), $next_url);
			}
		}

		if (record_exists('hotpot_responses', 'attempt', $attempt->id, 'question', $question->id)) {
			// there is already a response to this question for this attempt
			// probably because this quiz has two questions with the same text
			//	e.g. Which one of these answers is correct?

			// To workaround this, we create new question names
			//	e.g. Which one of these answers is correct? (2)
			// until we get a question name for which there is no response yet on this attempt

			$loopcount++;
			$question->name = "$questionname ($loopcount)";

			// This method fails to correctly identify questions in
			// quizzes which allow questions to be shuffled or omitted.
			// As yet, there is no workaround for such cases.

		} else {
			$response->question = $question->id;

			// add response record
			if(!$response->id = insert_record('hotpot_responses', $response)) {
				error("Could not add response record (attempt_id=$attempt->id, question_id=$question->id): ".$db->ErrorMsg(), $next_url);
			}

			// we can stop looping now
			$looping = false;
		}
	} // end while
}
function hotpot_adjust_response_field($quiztype, &$question, &$num, &$name, &$data) {
	switch ($quiztype) {
		case 'jbc':
			$question->type = HOTPOT_JCB;
			switch ($name) {
				case 'right':
					$name = 'correct';
				break;
			}
			break;
		case 'jcloze':
			$question->type = HOTPOT_JCLOZE;
			if (is_numeric($num)) {
				$question->name = $num;
			}
			switch ($name) {
				case 'penalties':
					if (is_numeric($num)) {
						$name = 'checks';
						if (is_numeric($data)) {
							$data++;
						}
					}
					break;
				case 'clue_shown':
					$name = 'clues';
					$data = ($data=='YES' ? 1 : 0);
					break;
				case 'clue_text':
					$name = 'text';
					break;
			}
			break;
		case 'jcross':
			$question->type = HOTPOT_JCROSS;
			$question->name = $num;
			switch ($name) {
				case '': // HotPot v2.0.x
					$name = 'correct';
					break;
				case 'clue':
					$name = 'text';
					break;
			}
			break;
		case 'jmatch':
			$question->type = HOTPOT_JMATCH;
			switch ($name) {
				case 'attempts':
					$name = 'penalties';
					if (is_numeric($data) && $data>0) {
						$data--;
					}
				break;
				case 'lhs':
					$name = 'name';
				break;
				case 'rhs':
					$name = 'correct';
				break;
			}
			break;
		case 'jmix':
			$question->type = HOTPOT_JMIX;
			$question->name = $num;
			switch ($name) {
				// keep these in for "restore" of courses
				// which were backed up with HotPot v2.0.x
				case 'wrongguesses':
					$name = 'checks';
					if (is_numeric($data)) {
						$data++;
					}
				break;
				case 'right':
					$name = 'correct';
				break;
			}
			break;
			break;
		case 'jquiz':
			switch ($name) {
				case 'type':
					$data = HOTPOT_JQUIZ;
					switch ($data) {
						case 'multiple-choice':
							$data .= '.'.HOTPOT_JQUIZ_MULTICHOICE;
						break;
						case 'short-answer':
							$data .= '.'.HOTPOT_JQUIZ_SHORTANSWER;
						break;
						case 'hybrid':
							$data .= '.'.HOTPOT_JQUIZ_HYBRID;
						break;
						case 'multi-select':
							$data .= '.'.HOTPOT_JQUIZ_MULTISELECT;
						case 'n/a':
						default:
							// do nothing more
						break;
					}
				break;
				case 'question':
					$name = 'name';
				break;
			}
			break;

		case 'rhubarb':
			$question->type = HOTPOT_TEXTOYS_RHUBARB;
			if (empty($question->name)) {
				$question->name = $num;
			}
			break;

		case 'sequitur':
			$question->type = HOTPOT_TEXTOYS_SEQUITUR;
			break;
	}
}
function hotpot_string_ids($field_value) {
	$ids = array();
	$strings = explode(',', $field_value);
	foreach($strings as $str) {
		if ($id = hotpot_string_id($str)) {
			$ids[] = $id;
		}
	}
	return implode(',', $ids);
}
function hotpot_string_id($str) {
	$id = '';
	if (isset($str) && $str<>'') {

		// get the id from the table if it is already there
		if (!$id = get_field('hotpot_strings', 'id', 'string', $str)) {

			// create a string record
			$record = NULL;
			$record->string = $str;

			// try and add the new string record
			if (!$id = insert_record('hotpot_strings', $record)) {
				global $db;
				error("Could not add string record for '".htmlspecialchars($str)."': ".$db->ErrorMsg());
			}
		}
	}
	return $id;
}

if (!function_exists('file_get_contents')) {
	// add this function for php version<4.3
	function file_get_contents($filepath) {
		$contents = file($filepath);
		if (is_array($contents)) {
			 $contents = implode('', $contents);
		}
		return $contents;
	}
}
if (!function_exists('html_entity_decode')) {
	// add this function for php version<4.3
	function html_entity_decode($str) {
		$t = get_html_translation_table(HTML_ENTITIES);
		$t = array_flip($t);
		return strtr($str, $t);
	}

}

// required for Moodle 1.x
if (!isset($CFG->pixpath)) {
	$CFG->pixpath = "$CFG->wwwroot/pix";
}

if (!function_exists('fullname')) {
	// add this function for Moodle 1.x
	function fullname($user) {
		return "$user->firstname $user->lastname";
	}
}
if (!function_exists('get_user_preferences')) {
	// add this function for Moodle 1.x
	function get_user_preferences($name=NULL, $default=NULL, $userid=NULL) {
		return $default;
	}
}
if (!function_exists('set_user_preference')) {
	// add this function for Moodle 1.x
	function set_user_preference($name, $value, $otheruser=NULL) {
		return false;
	}
}
function hotpot_utf8_to_html_entity($char) {
	// http://www.zend.com/codex.php?id=835&single=1

	// array used to figure what number to decrement from character order value
	// according to number of characters used to map unicode to ascii by utf-8
	static $HOTPOT_UTF8_DECREMENT = array(
		1=>0, 2=>192, 3=>224, 4=>240
	);

	// the number of bits to shift each character by
	static $HOTPOT_UTF8_SHIFT = array(
		1=>array(0=>0),
		2=>array(0=>6,  1=>0),
		3=>array(0=>12, 1=>6,  2=>0),
		4=>array(0=>18, 1=>12, 2=>6, 3=>0)
	);

	$dec = 0;
	$len = strlen($char);
	for ($pos=0; $pos<$len; $pos++) {
		$ord = ord ($char{$pos});
		$ord -= ($pos ? 128 : $HOTPOT_UTF8_DECREMENT[$len]);
		$dec += ($ord << $HOTPOT_UTF8_SHIFT[$len][$pos]);
	}
	return '&#x'.sprintf('%04X', $dec).';';
}

function hotpot_print_show_links($course, $location, $reference, $actions='', $spacer=' &nbsp; ', $new_window=false) {
	global $CFG;
	if (is_string($actions)) {
		if (empty($actions)) {
			$actions = 'showxmlsource,showxmltree,showhtmlsource';
		}
		$actions = explode(',', $actions);
	}
	$strenterafilename = get_string('enterafilename', 'hotpot');
	$html = <<<END_OF_SCRIPT
<script type="text/javascript" language="javascript">
<!--
	function setLink(lnk) {
		var form = document.forms['form'];
		return setLinkAttribute(lnk, 'reference', form) && setLinkAttribute(lnk, 'location', form);
	}
	function setLinkAttribute(lnk, name, form) {
		// set link attribute value using
		// f(orm) name and e(lement) name

		var r = true; // result

		var obj = (form) ? form.elements[name] : null;
		if (obj) {
			r = false;
			var v = getObjValue(obj);
			if (v=='') {
				alert('$strenterafilename');
			} else {
				var s = lnk.href;
				var i = s.indexOf('?');
				if (i>=0) {
					i = s.indexOf(name+'=', i+1);
					if (i>=0) {
						i += name.length+1;
						var ii = s.indexOf('&', i);
						if (ii<0) {
							ii = s.length;
						}
						lnk.href = s.substring(0, i) + v + s.substring(ii);
						r = true;
					}
				}
			}
		}
		return r;
	}
	function getObjValue(obj) {
		var v = ''; // the value
		var t = (obj && obj.type) ? obj.type : "";
		if (t=="text" || t=="textarea" || t=="hidden") {
			v = obj.value;
		} else if (t=="select-one" || t=="select-multiple") {
			var l = obj.options.length;
			for (var i=0; i<l; i++) {
				if (obj.options[i].selected) {
					v += (v=="" ? "" : ",") + obj.options[i].value;
				}
			}
		}
		return v;
	}
	function getDir(s) {
		if (s.charAt(0)!='/') {
			s = '/' + s;
		}
		var i = s.lastIndexOf('/');
		return s.substring(0, i);
	}
//-->
</script>
END_OF_SCRIPT;

	foreach ($actions as $action) {
		$html .= $spacer
		.	'<a href="'
		.			$CFG->wwwroot.'/mod/hotpot/show.php'
		.			'?course='.$course.'&location='.$location.'&reference='.urlencode($reference).'&action='.$action
		.		'"'
		.		' onclick="return setLink(this);"'
		.		($new_window ? ' target="_blank"' : '')
		.	'>'.get_string($action, 'hotpot').'</a>'
		;
	}
	print '<span class="helplink">'.$html.'</span>';
}

?>||||||||	function adjust_media_urls() {

		if ($this->forceplugins) {

			// make sure the Moodle media plugin is available
			global $CFG;
			include_once "$CFG->dirroot/filter/mediaplugin/filter.php";

			// exclude swf files from the filter
			//$CFG->filter_mediaplugin_ignore_swf = true;

			$space = '\s(?:.+\s)?';
			$quote = '["'."']?"; // single, double, or no quote

			// patterns to media files types and paths
			$filetype = "avi|mpeg|mpg|mp3|mov|wmv";
			$filepath = ".*?\.($filetype)";

			$tagopen = '(?:(<)|(\\\\u003C))'; // left angle-bracket (uses two parenthese)
			$tagclose = '(?(1)>|(?(2)\\\\u003E))'; // right angle-bracket (to match the left one)
			$tagreopen = '(?(1)<|(?(2)\\\\u003C))'; // another left angle-bracket (to match the first one)

			// pattern to match <PARAM> tags which contain the file path
			//	wmp        : url
			//	quicktime  : src
			//	realplayer : src
			//	flash      : movie (doesn't need replacing)
			$param_url = "/{$tagopen}param{$space}name=$quote(?:movie|src|url)$quote{$space}value=$quote($filepath)$quote.*?$tagclose/is";

			// pattern to match <a> tags which link to multimedia files
			$link_url = "/{$tagopen}a{$space}href=$quote($filepath)$quote.*?$tagclose.*?$tagreopen\/A$tagclose/is";

			// extract <object> tags
			preg_match_all("/{$tagopen}object\s.*?{$tagclose}(.*?){$tagreopen}\/object{$tagclose}/is", $this->html, $objects);

			$i_max = count($objects[0]);
			for ($i=0; $i<$i_max; $i++) {

				// extract URL from <PARAM> or <A>
				$url = '';
				if (preg_match($param_url, $objects[3][$i], $matches) || preg_match($link_url, $objects[3][$i], $matches)) {
					$url = $matches[3];
				}

				if ($url) {
					// strip inner tags (e.g. <embed>)
					$txt = preg_replace("/$tagopen.*?$tagclose/", '', $objects[3][$i]);

					// if url is in the query string, remove the leading characters
					$url = preg_replace('/^[^?]*\?([^=]+=[^&]*&)*[^=]+=([^&]*)$/', '$2', $url, 1);
					$link = '<a href="'.$url.'">'.$txt.'</a>';

					$new_object = mediaplugin_filter($this->filedir, $link);
					$new_object = str_replace($link, '', $new_object);
					$new_object = str_replace('&amp;', '&', $new_object);

					$this->html = str_replace($objects[0][$i], $new_object, $this->html);
				}
			}
		}
	}

} // end class

function hotpot_convert_stylesheets_urls($baseurl, $reference, $css, $stripslashes=true) {
	if ($stripslashes) {
		$css = stripslashes($css);
	}
	$search = '|'.'(?<='.'url'.'\('.')'."(.+?)".'(?='.'\)'.')'.'|ise';
	$replace = "hotpot_convert_url('".$baseurl."','".$reference."','\\1')";
	return preg_replace($search, $replace, $css);
}
function hotpot_convert_preloadimages_urls($baseurl, $reference, $urls, $stripslashes=true) {
	if ($stripslashes) {
		$urls = stripslashes($urls);
	}
	$search = '|(?<=["'."'])([^,'".'"]*?)(?=["'."'])|ise";
	$replace = "hotpot_convert_url('".$baseurl."','".$reference."','\\1')";
	return preg_replace($search, $replace, $urls);
}
function hotpot_convert_navbutton_url($baseurl, $reference, $url, $course, $stripslashes=true) {
	global $CFG;

	if ($stripslashes) {
		$url = stripslashes($url);
	}
	$url = hotpot_convert_url($baseurl, $reference, $url, false);

	// is this a $url for another hotpot in this course ?
	if (preg_match("|^$baseurl(.*)$|", $url, $matches)) {
		if ($records = get_records_select('hotpot', "course='$course' AND reference='".$matches[1]."'")) {
			$ids = array_keys($records);
			$url = "$CFG->wwwroot/mod/hotpot/view.php?hp=".$ids[0];
		}
	}

	return $url;
}

function hotpot_convert_relative_url($baseurl, $reference, $opentag, $url, $closetag, $stripslashes=true) {
	if ($stripslashes) {
		$opentag = stripslashes($opentag);
		$url = stripslashes($url);
		$closetag = stripslashes($closetag);
	}

	// catch <PARAM name="FlashVars" value="TheSound=soundfile.mp3">
	//	ampersands can appear as "&", "&amp;" or "&amp;#x0026;amp;"
	if (preg_match('|^'.'\w+=[^&]+'.'('.'&((amp;#x0026;)?amp;)?'.'\w+=[^&]+)*'.'$|', $url)) {
		$query = $url;
		$url = '';
		$fragment = '';

	// parse the $url into $matches
	//	[1] path
	//	[2] query string, if any
	//	[3] anchor fragment, if any
	} else if (preg_match('|^'.'([^?]*)'.'((?:\\?[^#]*)?)'.'((?:#.*)?)'.'$|', $url, $matches)) {
		$url = $matches[1];
		$query = $matches[2];
		$fragment = $matches[3];

	// these appears to be no query or fragment in this url
	} else {
		$query = '';
		$fragment = '';
	}

	if ($url) {
		$url = hotpot_convert_url($baseurl, $reference, $url, false);
	}

	if ($query) {
		$search = '#'.'(file|src|thesound)='."([^&]+)".'#ise';
		$replace = "'\\1='.hotpot_convert_url('".$baseurl."','".$reference."','\\2')";
		$query = preg_replace($search, $replace, $query);
	}

	$url = $opentag.$url.$query.$fragment.$closetag;

	return $url;
}

function hotpot_convert_url($baseurl, $reference, $url, $stripslashes=true) {
	// maintain a cache of converted urls
	static $HOTPOT_RELATIVE_URLS = array();

	if ($stripslashes) {
		$url = stripslashes($url);
	}

	// is this an absolute url? (or javascript pseudo url)
	if (preg_match('%^(http://|/|javascript:)%i', $url)) {
		// do nothing

	// has this relative url already been converted?
	} else if (isset($HOTPOT_RELATIVE_URLS[$url])) {
		$url = $HOTPOT_RELATIVE_URLS[$url];

	} else {
		$relativeurl = $url;

		// get the subdirectory, $dir, of the quiz $reference
		$dir = dirname($reference);

		// allow for leading "./" and "../"
		while (preg_match('|^(\.{1,2})/(.*)$|', $url, $matches)) {
			if ($matches[1]=='..') {
				$dir = dirname($dir);
			}
			$url = $matches[2];
		}

		// add subdirectory, $dir, to $baseurl, if necessary
		if ($dir && $dir<>'.') {
			$baseurl .= "$dir/";
		}

		// prefix $url with $baseurl
		$url = "$baseurl$url";

		// add url to cache
		$HOTPOT_RELATIVE_URLS[$relativeurl] = $url;
	}
	return $url;
}

// ===================================================
// function for adding attempt questions and responses
// ===================================================

function hotpot_add_attempt_details(&$attempt) {

	// encode ampersands so that HTML entities are preserved in the XML parser
	// N.B. ampersands inside <![CDATA[ ]]> blocks do NOT need to be encoded

	$old = &$attempt->details; // shortcut to "old" details
	$new = '';
	$str_start = 0;
	while (($cdata_start = strpos($old, '<![CDATA[', $str_start)) && ($cdata_end = strpos($old, ']]>', $cdata_start))) {
		$cdata_end += 3;
		$new .= str_replace('&', '&amp;', substr($old, $str_start, $cdata_start-$str_start)).substr($old, $cdata_start, $cdata_end-$cdata_start);
		$str_start = $cdata_end;
	}
	$new .= str_replace('&', '&amp;', substr($old, $str_start));
	unset($old);

	// parse the attempt details as xml
	$details = new hotpot_xml_tree($new, "['hpjsresult']['#']");

	$num = -1;
	$q_num = -1;
	$question = NULL;
	$reponse = NULL;

	$i = 0;
	$tags = 'fields,field';

	while (($field="[$i]['#']") && $details->xml_value($tags, $field)) {

		$name = $details->xml_value($tags, $field."['fieldname'][0]['#']");
		$data = $details->xml_value($tags, $field."['fielddata'][0]['#']");

		// parse the field name into $matches
		//	[1] quiz type
		//	[2] attempt detail name
		if (preg_match('/^(\w+?)_(\w+)$/', $name, $matches)) {
			$quiztype = strtolower($matches[1]);
			$name = strtolower($matches[2]);

			// parse the attempt detail $name into $matches
			//	[1] question number
			//	[2] question detail name
			if (preg_match('/^q(\d+)_(\w+)$/', $name, $matches)) {
				$num = $matches[1];
				$name = strtolower($matches[2]);
				$data = addslashes($data);

				// adjust JCross question numbers
				if (preg_match('/^(across|down)(.*)$/', $name, $matches)) {
					$num .= '_'.$matches[1]; // e.g. 01_across, 02_down
					$name = $matches[2];
					if (substr($name, 0, 1)=='_') {
						$name = substr($name, 1); // remove leading '_'
					}
				}

				// is this a new question (or the first one)?
				if ($q_num<>$num) {

					// add previous question and response, if any
					hotpot_add_response($attempt, $question, $response);

					// initialize question object
					$question = NULL;
					$question->name = '';
					$question->text = '';
					$question->hotpot = $attempt->hotpot;

					// initialize response object
					$response = NULL;
					$response->attempt = $attempt->id;

					// update question number
					$q_num = $num;
				}

				// adjust field name and value, and set question type
				// (may not be necessary one day)
				hotpot_adjust_response_field($quiztype, $question, $num, $name, $data);

				// add $data to the question/response details
				switch ($name) {
					case 'name':
					case 'type':
						$question->$name = $data;
						break;
					case 'text':
						$question->$name = hotpot_string_id($data);
						break;

					case 'correct':
					case 'ignored':
					case 'wrong':
						$response->$name = hotpot_string_ids($data);
						break;

					case 'score':
					case 'weighting':
					case 'hints':
					case 'clues':
					case 'checks':
						$response->$name = intval($data);
						break;
				}

			} else { // attempt details

				// adjust field name and value
				hotpot_adjust_response_field($quiztype, $question, $num='', $name, $data);

				// add $data to the attempt details
				if ($name=='penalties') {
					$attempt->$name = intval($data);
				}
			}
		}

		$i++;
	} // end while

	// add the final question and response, if any
	hotpot_add_response($attempt, $question, $response);
}
function hotpot_add_response(&$attempt, &$question, &$response) {
	global $db, $next_url;

	$loopcount = 1;

	$looping = isset($question) && isset($question->name) && isset($response);
	while ($looping) {

		if ($loopcount==1) {
			$questionname = $question->name;
		}

		if (!$question->id = get_field('hotpot_questions', 'id', 'name', $question->name, 'hotpot', $attempt->hotpot)) {
			// add question record
			if (!$question->id = insert_record('hotpot_questions', $question)) {
				error("Could not add question record (attempt_id=$attempt->id): ".$db->ErrorMsg(), $next_url);
			}
		}

		if (record_exists('hotpot_responses', 'attempt', $attempt->id, 'question', $question->id)) {
			// there is already a response to this question for this attempt
			// probably because this quiz has two questions with the same text
			//	e.g. Which one of these answers is correct?

			// To workaround this, we create new question names
			//	e.g. Which one of these answers is correct? (2)
			// until we get a question name for which there is no response yet on this attempt

			$loopcount++;
			$question->name = "$questionname ($loopcount)";

			// This method fails to correctly identify questions in
			// quizzes which allow questions to be shuffled or omitted.
			// As yet, there is no workaround for such cases.

		} else {
			$response->question = $question->id;

			// add response record
			if(!$response->id = insert_record('hotpot_responses', $response)) {
				error("Could not add response record (attempt_id=$attempt->id, question_id=$question->id): ".$db->ErrorMsg(), $next_url);
			}

			// we can stop looping now
			$looping = false;
		}
	} // end while
}
function hotpot_adjust_response_field($quiztype, &$question, &$num, &$name, &$data) {
	switch ($quiztype) {
		case 'jbc':
			$question->type = HOTPOT_JCB;
			switch ($name) {
				case 'right':
					$name = 'correct';
				break;
			}
			break;
		case 'jcloze':
			$question->type = HOTPOT_JCLOZE;
			if (is_numeric($num)) {
				$question->name = $num;
			}
			switch ($name) {
				case 'penalties':
					if (is_numeric($num)) {
						$name = 'checks';
						if (is_numeric($data)) {
							$data++;
						}
					}
					break;
				case 'clue_shown':
					$name = 'clues';
					$data = ($data=='YES' ? 1 : 0);
					break;
				case 'clue_text':
					$name = 'text';
					break;
			}
			break;
		case 'jcross':
			$question->type = HOTPOT_JCROSS;
			$question->name = $num;
			switch ($name) {
				case '': // HotPot v2.0.x
					$name = 'correct';
					break;
				case 'clue':
					$name = 'text';
					break;
			}
			break;
		case 'jmatch':
			$question->type = HOTPOT_JMATCH;
			switch ($name) {
				case 'attempts':
					$name = 'penalties';
					if (is_numeric($data) && $data>0) {
						$data--;
					}
				break;
				case 'lhs':
					$name = 'name';
				break;
				case 'rhs':
					$name = 'correct';
				break;
			}
			break;
		case 'jmix':
			$question->type = HOTPOT_JMIX;
			$question->name = $num;
			switch ($name) {
				// keep these in for "restore" of courses
				// which were backed up with HotPot v2.0.x
				case 'wrongguesses':
					$name = 'checks';
					if (is_numeric($data)) {
						$data++;
					}
				break;
				case 'right':
					$name = 'correct';
				break;
			}
			break;
			break;
		case 'jquiz':
			switch ($name) {
				case 'type':
					$data = HOTPOT_JQUIZ;
					switch ($data) {
						case 'multiple-choice':
							$data .= '.'.HOTPOT_JQUIZ_MULTICHOICE;
						break;
						case 'short-answer':
							$data .= '.'.HOTPOT_JQUIZ_SHORTANSWER;
						break;
						case 'hybrid':
							$data .= '.'.HOTPOT_JQUIZ_HYBRID;
						break;
						case 'multi-select':
							$data .= '.'.HOTPOT_JQUIZ_MULTISELECT;
						case 'n/a':
						default:
							// do nothing more
						break;
					}
				break;
				case 'question':
					$name = 'name';
				break;
			}
			break;

		case 'rhubarb':
			$question->type = HOTPOT_TEXTOYS_RHUBARB;
			if (empty($question->name)) {
				$question->name = $num;
			}
			break;

		case 'sequitur':
			$question->type = HOTPOT_TEXTOYS_SEQUITUR;
			break;
	}
}
function hotpot_string_ids($field_value) {
	$ids = array();
	$strings = explode(',', $field_value);
	foreach($strings as $str) {
		if ($id = hotpot_string_id($str)) {
			$ids[] = $id;
		}
	}
	return implode(',', $ids);
}
function hotpot_string_id($str) {
	$id = '';
	if (isset($str) && $str<>'') {

		// get the id from the table if it is already there
		if (!$id = get_field('hotpot_strings', 'id', 'string', $str)) {

			// create a string record
			$record = NULL;
			$record->string = $str;

			// try and add the new string record
			if (!$id = insert_record('hotpot_strings', $record)) {
				global $db;
				error("Could not add string record for '".htmlspecialchars($str)."': ".$db->ErrorMsg());
			}
		}
	}
	return $id;
}

if (!function_exists('file_get_contents')) {
	// add this function for php version<4.3
	function file_get_contents($filepath) {
		$contents = file($filepath);
		if (is_array($contents)) {
			 $contents = implode('', $contents);
		}
		return $contents;
	}
}
if (!function_exists('html_entity_decode')) {
	// add this function for php version<4.3
	function html_entity_decode($str) {
		$t = get_html_translation_table(HTML_ENTITIES);
		$t = array_flip($t);
		return strtr($str, $t);
	}

}

// required for Moodle 1.x
if (!isset($CFG->pixpath)) {
	$CFG->pixpath = "$CFG->wwwroot/pix";
}

if (!function_exists('fullname')) {
	// add this function for Moodle 1.x
	function fullname($user) {
		return "$user->firstname $user->lastname";
	}
}
if (!function_exists('get_user_preferences')) {
	// add this function for Moodle 1.x
	function get_user_preferences($name=NULL, $default=NULL, $userid=NULL) {
		return $default;
	}
}
if (!function_exists('set_user_preference')) {
	// add this function for Moodle 1.x
	function set_user_preference($name, $value, $otheruser=NULL) {
		return false;
	}
}
function hotpot_utf8_to_html_entity($char) {
	// http://www.zend.com/codex.php?id=835&single=1

	// array used to figure what number to decrement from character order value
	// according to number of characters used to map unicode to ascii by utf-8
	static $HOTPOT_UTF8_DECREMENT = array(
		1=>0, 2=>192, 3=>224, 4=>240
	);

	// the number of bits to shift each character by
	static $HOTPOT_UTF8_SHIFT = array(
		1=>array(0=>0),
		2=>array(0=>6,  1=>0),
		3=>array(0=>12, 1=>6,  2=>0),
		4=>array(0=>18, 1=>12, 2=>6, 3=>0)
	);

	$dec = 0;
	$len = strlen($char);
	for ($pos=0; $pos<$len; $pos++) {
		$ord = ord ($char{$pos});
		$ord -= ($pos ? 128 : $HOTPOT_UTF8_DECREMENT[$len]);
		$dec += ($ord << $HOTPOT_UTF8_SHIFT[$len][$pos]);
	}
	return '&#x'.sprintf('%04X', $dec).';';
}

function hotpot_print_show_links($course, $location, $reference, $actions='', $spacer=' &nbsp; ', $new_window=false) {
	global $CFG;
	if (is_string($actions)) {
		if (empty($actions)) {
			$actions = 'showxmlsource,showxmltree,showhtmlsource';
		}
		$actions = explode(',', $actions);
	}
	$strenterafilename = get_string('enterafilename', 'hotpot');
	$html = <<<END_OF_SCRIPT
<script type="text/javascript" language="javascript">
<!--
	function setLink(lnk) {
		var form = document.forms['form'];
		return setLinkAttribute(lnk, 'reference', form) && setLinkAttribute(lnk, 'location', form);
	}
	function setLinkAttribute(lnk, name, form) {
		// set link attribute value using
		// f(orm) name and e(lement) name

		var r = true; // result

		var obj = (form) ? form.elements[name] : null;
		if (obj) {
			r = false;
			var v = getObjValue(obj);
			if (v=='') {
				alert('$strenterafilename');
			} else {
				var s = lnk.href;
				var i = s.indexOf('?');
				if (i>=0) {
					i = s.indexOf(name+'=', i+1);
					if (i>=0) {
						i += name.length+1;
						var ii = s.indexOf('&', i);
						if (ii<0) {
							ii = s.length;
						}
						lnk.href = s.substring(0, i) + v + s.substring(ii);
						r = true;
					}
				}
			}
		}
		return r;
	}
	function getObjValue(obj) {
		var v = ''; // the value
		var t = (obj && obj.type) ? obj.type : "";
		if (t=="text" || t=="textarea" || t=="hidden") {
			v = obj.value;
		} else if (t=="select-one" || t=="select-multiple") {
			var l = obj.options.length;
			for (var i=0; i<l; i++) {
				if (obj.options[i].selected) {
					v += (v=="" ? "" : ",") + obj.options[i].value;
				}
			}
		}
		return v;
	}
	function getDir(s) {
		if (s.charAt(0)!='/') {
			s = '/' + s;
		}
		var i = s.lastIndexOf('/');
		return s.substring(0, i);
	}
//-->
</script>
END_OF_SCRIPT;

	foreach ($actions as $action) {
		$html .= $spacer
		.	'<a href="'
		.			$CFG->wwwroot.'/mod/hotpot/show.php'
		.			'?course='.$course.'&location='.$location.'&reference='.urlencode($reference).'&action='.$action
		.		'"'
		.		' onclick="return setLink(this);"'
		.		($new_window ? ' target="_blank"' : '')
		.	'>'.get_string($action, 'hotpot').'</a>'
		;
	}
	print '<span class="helplink">'.$html.'</span>';
}

?>||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_GLOBAL
                    (AST_VAR))
                (AST_INCLUDE_OR_EVAL
                    (AST_ENCAPS_LIST
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (SCALAR)
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_ENCAPS_LIST
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_ENCAPS_LIST
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_ENCAPS_LIST
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)))
                (AST_CALL
                    (
                        (AST_ENCAPS_LIST
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR))
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR)))))
                (AST_FOR
                    (AST_EXPR_LIST
                        (AST_ASSIGN
                            (AST_VAR)
                            (SCALAR)))
                    (AST_EXPR_LIST
                        (AST_BINARY_OP
                            (AST_VAR)
                            (AST_VAR)))
                    (AST_EXPR_LIST
                        (AST_POST_INC
                            (AST_VAR)))
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (SCALAR))
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_BINARY_OP
                                    (AST_CALL
                                        (
                                            (AST_VAR)
                                            (AST_DIM
                                                (AST_DIM
                                                    (AST_VAR)
                                                    (SCALAR))
                                                (AST_VAR))
                                            (AST_VAR)))
                                    (AST_CALL
                                        (
                                            (AST_VAR)
                                            (AST_DIM
                                                (AST_DIM
                                                    (AST_VAR)
                                                    (SCALAR))
                                                (AST_VAR))
                                            (AST_VAR))))
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))))
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_VAR)
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (AST_ENCAPS_LIST
                                                    (SCALAR)
                                                    (AST_VAR)
                                                    (SCALAR)
                                                    (AST_VAR)
                                                    (SCALAR))
                                                (SCALAR)
                                                (AST_DIM
                                                    (AST_DIM
                                                        (AST_VAR)
                                                        (SCALAR))
                                                    (AST_VAR)))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (SCALAR)
                                                (SCALAR)
                                                (AST_VAR)
                                                (SCALAR))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_BINARY_OP
                                            (AST_BINARY_OP
                                                (AST_BINARY_OP
                                                    (AST_BINARY_OP
                                                        (SCALAR)
                                                        (AST_VAR))
                                                    (SCALAR))
                                                (AST_VAR))
                                            (SCALAR)))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (AST_PROP
                                                    (AST_VAR))
                                                (AST_VAR))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (AST_VAR)
                                                (SCALAR)
                                                (AST_VAR))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (SCALAR)
                                                (SCALAR)
                                                (AST_VAR))))
                                    (AST_ASSIGN
                                        (AST_PROP
                                            (AST_VAR))
                                        (AST_CALL
                                            (
                                                (AST_DIM
                                                    (AST_DIM
                                                        (AST_VAR)
                                                        (SCALAR))
                                                    (AST_VAR))
                                                (AST_VAR)
                                                (AST_PROP
                                                    (AST_VAR))))))))))))))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_GLOBAL
                    (AST_VAR))
                (AST_INCLUDE_OR_EVAL
                    (AST_ENCAPS_LIST
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (SCALAR)
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_ENCAPS_LIST
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_ENCAPS_LIST
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_ENCAPS_LIST
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR)
                        (SCALAR)))
                (AST_CALL
                    (
                        (AST_ENCAPS_LIST
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR)
                            (AST_VAR)
                            (SCALAR))
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR)))))
                (AST_FOR
                    (AST_EXPR_LIST
                        (AST_ASSIGN
                            (AST_VAR)
                            (SCALAR)))
                    (AST_EXPR_LIST
                        (AST_BINARY_OP
                            (AST_VAR)
                            (AST_VAR)))
                    (AST_EXPR_LIST
                        (AST_POST_INC
                            (AST_VAR)))
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (SCALAR))
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_BINARY_OP
                                    (AST_CALL
                                        (
                                            (AST_VAR)
                                            (AST_DIM
                                                (AST_DIM
                                                    (AST_VAR)
                                                    (SCALAR))
                                                (AST_VAR))
                                            (AST_VAR)))
                                    (AST_CALL
                                        (
                                            (AST_VAR)
                                            (AST_DIM
                                                (AST_DIM
                                                    (AST_VAR)
                                                    (SCALAR))
                                                (AST_VAR))
                                            (AST_VAR))))
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))))
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_VAR)
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (AST_ENCAPS_LIST
                                                    (SCALAR)
                                                    (AST_VAR)
                                                    (SCALAR)
                                                    (AST_VAR)
                                                    (SCALAR))
                                                (SCALAR)
                                                (AST_DIM
                                                    (AST_DIM
                                                        (AST_VAR)
                                                        (SCALAR))
                                                    (AST_VAR)))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (SCALAR)
                                                (SCALAR)
                                                (AST_VAR)
                                                (SCALAR))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_BINARY_OP
                                            (AST_BINARY_OP
                                                (AST_BINARY_OP
                                                    (AST_BINARY_OP
                                                        (SCALAR)
                                                        (AST_VAR))
                                                    (SCALAR))
                                                (AST_VAR))
                                            (SCALAR)))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (AST_PROP
                                                    (AST_VAR))
                                                (AST_VAR))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (AST_VAR)
                                                (SCALAR)
                                                (AST_VAR))))
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_CALL
                                            (
                                                (SCALAR)
                                                (SCALAR)
                                                (AST_VAR))))
                                    (AST_ASSIGN
                                        (AST_PROP
                                            (AST_VAR))
                                        (AST_CALL
                                            (
                                                (AST_DIM
                                                    (AST_DIM
                                                        (AST_VAR)
                                                        (SCALAR))
                                                    (AST_VAR))
                                                (AST_VAR)
                                                (AST_PROP
                                                    (AST_VAR))))))))))))))