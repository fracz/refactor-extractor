    public function after_restore() {
        global $DB;
        // Get main data object
        $sectionid = $this->get_task()->get_sectionid();
        $data = $DB->get_record('course_sections',
                array('id' => $sectionid), 'id, groupingid', MUST_EXIST);
        if ($data->groupingid) {
            // Correct grouping id
            $DB->set_field('course_sections', 'groupingid',
                    $this->get_mappingid('grouping', $data->groupingid),
                    array('id' => $sectionid));
        }

        // Get data object for current section availability (if any)
        $data = $DB->get_record('course_sections_availability',
                array('coursesectionid' => $sectionid), 'id, sourcecmid, gradeitemid', IGNORE_MISSING);

        // Update mappings
        if ($data) {
            $data->sourcecmid = $this->get_mappingid('course_module', $data->sourcecmid);
            if (!$data->sourcecmid) {
                $data->sourcecmid = null;
            }
            $data->gradeitemid = $this->get_mappingid('grade_item', $data->gradeitemid);
            if (!$data->gradeitemid) {
                $data->gradeitemid = null;
            }

            $DB->update_record('course_sections_availability', $data);
            rebuild_course_cache($this->get_task()->get_courseid(), true);
        }
    }

||||||||    public function after_restore() {
        global $DB;

        $sectionid = $this->get_task()->get_sectionid();

        // Get data object for current section availability (if any)
        // TODO: This can be processing already existing records, we need to be able to know which ones
        //       are the just restored ones, perhaps creating 'course_sections_availability' mappings for them.
        // TODO: Also, this must avoid duplicates, so if one course module or one grade item already is being
        //       used for some availability rule... we need to handle that carefully.
        $data = $DB->get_record('course_sections_availability',
                array('coursesectionid' => $sectionid), 'id, sourcecmid, gradeitemid', IGNORE_MISSING);

        // Update mappings
        if ($data) {
            $data->sourcecmid = $this->get_mappingid('course_module', $data->sourcecmid);
            if (!$data->sourcecmid) {
                $data->sourcecmid = null;
            }
            $data->gradeitemid = $this->get_mappingid('grade_item', $data->gradeitemid);
            if (!$data->gradeitemid) {
                $data->gradeitemid = null;
            }

            $DB->update_record('course_sections_availability', $data);
        }
    }
}


/**
 * Structure step that will read the course.xml file, loading it and performing
 * various actions depending of the site/restore settings. Note that target
 * course always exist before arriving here so this step will be updating
 * the course record (never inserting)
 */
class restore_course_structure_step extends restore_structure_step {
    /**
     * @var bool this gets set to true by {@link process_course()} if we are
     * restoring an old coures that used the legacy 'module security' feature.
     * If so, we have to do more work in {@link after_execute()}.
     */
    protected $legacyrestrictmodules = false;

    /**
     * @var array Used when {@link $legacyrestrictmodules} is true. This is an
     * array with array keys the module names ('forum', 'quiz', etc.). These are
     * the modules that are allowed according to the data in the backup file.
     * In {@link after_execute()} we then have to prevent adding of all the other
     * types of activity.
     */
    protected $legacyallowedmodules = array();

    protected function define_structure() {

        $course = new restore_path_element('course', '/course');
        $category = new restore_path_element('category', '/course/category');
        $tag = new restore_path_element('tag', '/course/tags/tag');
        $allowed_module = new restore_path_element('allowed_module', '/course/allowed_modules/module');

        // Apply for 'format' plugins optional paths at course level
        $this->add_plugin_structure('format', $course);

        // Apply for 'theme' plugins optional paths at course level
        $this->add_plugin_structure('theme', $course);

        // Apply for 'report' plugins optional paths at course level
        $this->add_plugin_structure('report', $course);

        // Apply for 'course report' plugins optional paths at course level
        $this->add_plugin_structure('coursereport', $course);

        // Apply for plagiarism plugins optional paths at course level
        $this->add_plugin_structure('plagiarism', $course);

        return array($course, $category, $tag, $allowed_module);
    }

    /**
     * Processing functions go here
     *
     * @global moodledatabase $DB
     * @param stdClass $data
     */
    public function process_course($data) {
        global $CFG, $DB;

        $data = (object)$data;

        $fullname  = $this->get_setting_value('course_fullname');
        $shortname = $this->get_setting_value('course_shortname');
        $startdate = $this->get_setting_value('course_startdate');

        // Calculate final course names, to avoid dupes
        list($fullname, $shortname) = restore_dbops::calculate_course_names($this->get_courseid(), $fullname, $shortname);

        // Need to change some fields before updating the course record
        $data->id = $this->get_courseid();
        $data->fullname = $fullname;
        $data->shortname= $shortname;

        $context = get_context_instance_by_id($this->task->get_contextid());
        if (has_capability('moodle/course:changeidnumber', $context, $this->task->get_userid())) {
            $data->idnumber = '';
        } else {
            unset($data->idnumber);
        }

        // Any empty value for course->hiddensections will lead to 0 (default, show collapsed).
        // It has been reported that some old 1.9 courses may have it null leading to DB error. MDL-31532
        if (empty($data->hiddensections)) {
            $data->hiddensections = 0;
        }

        // Set legacyrestrictmodules to true if the course was resticting modules. If so
        // then we will need to process restricted modules after execution.
        $this->legacyrestrictmodules = !empty($data->restrictmodules);

        $data->startdate= $this->apply_date_offset($data->startdate);
        if ($data->defaultgroupingid) {
            $data->defaultgroupingid = $this->get_mappingid('grouping', $data->defaultgroupingid);
        }
        if (empty($CFG->enablecompletion)) {
            $data->enablecompletion = 0;
            $data->completionstartonenrol = 0;
            $data->completionnotify = 0;
        }
        $languages = get_string_manager()->get_list_of_translations(); // Get languages for quick search
        if (!array_key_exists($data->lang, $languages)) {
            $data->lang = '';
        }

        $themes = get_list_of_themes(); // Get themes for quick search later
        if (!array_key_exists($data->theme, $themes) || empty($CFG->allowcoursethemes)) {
            $data->theme = '';
        }

        // Course record ready, update it
        $DB->update_record('course', $data);

        // Role name aliases
        restore_dbops::set_course_role_names($this->get_restoreid(), $this->get_courseid());
    }

    public function process_category($data) {
        // Nothing to do with the category. UI sets it before restore starts
    }

    public function process_tag($data) {
        global $CFG, $DB;

        $data = (object)$data;

        if (!empty($CFG->usetags)) { // if enabled in server
            // TODO: This is highly inneficient. Each time we add one tag
            // we fetch all the existing because tag_set() deletes them
            // so everything must be reinserted on each call
            $tags = array();
            $existingtags = tag_get_tags('course', $this->get_courseid());
            // Re-add all the existitng tags
            foreach ($existingtags as $existingtag) {
                $tags[] = $existingtag->rawname;
            }
            // Add the one being restored
            $tags[] = $data->rawname;
            // Send all the tags back to the course
            tag_set('course', $this->get_courseid(), $tags);
        }
    }

    public function process_allowed_module($data) {
        $data = (object)$data;

        // Backwards compatiblity support for the data that used to be in the
        // course_allowed_modules table.
        if ($this->legacyrestrictmodules) {
            $this->legacyallowedmodules[$data->modulename] = 1;
        }
    }

    protected function after_execute() {
        global $DB;

        // Add course related files, without itemid to match
        $this->add_related_files('course', 'summary', null);
        $this->add_related_files('course', 'legacy', null);

        // Deal with legacy allowed modules.
        if ($this->legacyrestrictmodules) {
            $context = context_course::instance($this->get_courseid());

            list($roleids) = get_roles_with_cap_in_context($context, 'moodle/course:manageactivities');
            list($managerroleids) = get_roles_with_cap_in_context($context, 'moodle/site:config');
            foreach ($managerroleids as $roleid) {
                unset($roleids[$roleid]);
            }

            foreach (get_plugin_list('mod') as $modname => $notused) {
                if (isset($this->legacyallowedmodules[$modname])) {
                    // Module is allowed, no worries.
                    continue;
                }

                $capability = 'mod/' . $modname . ':addinstance';
                foreach ($roleids as $roleid) {
                    assign_capability($capability, CAP_PREVENT, $roleid, $context);
                }
            }
        }
    }
}


/*
 * Structure step that will read the roles.xml file (at course/activity/block levels)
 * containig all the role_assignments and overrides for that context. If corresponding to
 * one mapped role, they will be applied to target context. Will observe the role_assignments
 * setting to decide if ras are restored.
 * Note: only ras with component == null are restored as far as the any ra with component
 * is handled by one enrolment plugin, hence it will createt the ras later
 */
class restore_ras_and_caps_structure_step extends restore_structure_step {

    protected function define_structure() {

        $paths = array();

        // Observe the role_assignments setting
        if ($this->get_setting_value('role_assignments')) {
            $paths[] = new restore_path_element('assignment', '/roles/role_assignments/assignment');
        }
        $paths[] = new restore_path_element('override', '/roles/role_overrides/override');

        return $paths;
    }

    /**
     * Assign roles
     *
     * This has to be called after enrolments processing.
     *
     * @param mixed $data
     * @return void
     */
    public function process_assignment($data) {
        global $DB;

        $data = (object)$data;

        // Check roleid, userid are one of the mapped ones
        if (!$newroleid = $this->get_mappingid('role', $data->roleid)) {
            return;
        }
        if (!$newuserid = $this->get_mappingid('user', $data->userid)) {
            return;
        }
        if (!$DB->record_exists('user', array('id' => $newuserid, 'deleted' => 0))) {
            // Only assign roles to not deleted users
            return;
        }
        if (!$contextid = $this->task->get_contextid()) {
            return;
        }

        if (empty($data->component)) {
            // assign standard manual roles
            // TODO: role_assign() needs one userid param to be able to specify our restore userid
            role_assign($newroleid, $newuserid, $contextid);

        } else if ((strpos($data->component, 'enrol_') === 0)) {
            // Deal with enrolment roles
            if ($enrolid = $this->get_mappingid('enrol', $data->itemid)) {
                if ($component = $DB->get_field('enrol', 'component', array('id'=>$enrolid))) {
                    //note: we have to verify component because it might have changed
                    if ($component === 'enrol_manual') {
                        // manual is a special case, we do not use components - this owudl happen when converting from other plugin
                        role_assign($newroleid, $newuserid, $contextid); //TODO: do we need modifierid?
                    } else {
                        role_assign($newroleid, $newuserid, $contextid, $component, $enrolid); //TODO: do we need modifierid?
                    }
                }
            }
        }
    }

    public function process_override($data) {
        $data = (object)$data;

        // Check roleid is one of the mapped ones
        $newroleid = $this->get_mappingid('role', $data->roleid);
        // If newroleid and context are valid assign it via API (it handles dupes and so on)
        if ($newroleid && $this->task->get_contextid()) {
            // TODO: assign_capability() needs one userid param to be able to specify our restore userid
            // TODO: it seems that assign_capability() doesn't check for valid capabilities at all ???
            assign_capability($data->capability, $data->permission, $newroleid, $this->task->get_contextid());
        }
    }
}

/**
 * This structure steps restores the enrol plugins and their underlying
 * enrolments, performing all the mappings and/or movements required
 */
class restore_enrolments_structure_step extends restore_structure_step {

    /**
     * Conditionally decide if this step should be executed.
     *
     * This function checks the following parameter:
     *
     *   1. the course/enrolments.xml file exists
     *
     * @return bool true is safe to execute, false otherwise
     */
    protected function execute_condition() {

        // Check it is included in the backup
        $fullpath = $this->task->get_taskbasepath();
        $fullpath = rtrim($fullpath, '/') . '/' . $this->filename;
        if (!file_exists($fullpath)) {
            // Not found, can't restore enrolments info
            return false;
        }

        return true;
    }

    protected function define_structure() {

        $paths = array();

        $paths[] = new restore_path_element('enrol', '/enrolments/enrols/enrol');
        $paths[] = new restore_path_element('enrolment', '/enrolments/enrols/enrol/user_enrolments/enrolment');

        return $paths;
    }

    /**
     * Create enrolment instances.
     *
     * This has to be called after creation of roles
     * and before adding of role assignments.
     *
     * @param mixed $data
     * @return void
     */
    public function process_enrol($data) {
        global $DB;

        $data = (object)$data;
        $oldid = $data->id; // We'll need this later

        $restoretype = plugin_supports('enrol', $data->enrol, ENROL_RESTORE_TYPE, null);

        if ($restoretype !== ENROL_RESTORE_EXACT and $restoretype !== ENROL_RESTORE_NOUSERS) {
            // TODO: add complex restore support via custom class
            debugging("Skipping '{$data->enrol}' enrolment plugin. Will be implemented before 2.0 release", DEBUG_DEVELOPER);
            $this->set_mapping('enrol', $oldid, 0);
            return;
        }

        // Perform various checks to decide what to do with the enrol plugin
        if (!array_key_exists($data->enrol, enrol_get_plugins(false))) {
            // TODO: decide if we want to switch to manual enrol - we need UI for this
            debugging("Enrol plugin data can not be restored because it is not installed");
            $this->set_mapping('enrol', $oldid, 0);
            return;

        }
        if (!enrol_is_enabled($data->enrol)) {
            // TODO: decide if we want to switch to manual enrol - we need UI for this
            debugging("Enrol plugin data can not be restored because it is not enabled");
            $this->set_mapping('enrol', $oldid, 0);
            return;
        }

        // map standard fields - plugin has to process custom fields from own restore class
        $data->roleid = $this->get_mappingid('role', $data->roleid);
        //TODO: should we move the enrol start and end date here?

        // always add instance, if the course does not support multiple instances it just returns NULL
        $enrol = enrol_get_plugin($data->enrol);
        $courserec = $DB->get_record('course', array('id' => $this->get_courseid())); // Requires object, uses only id!!
        if ($newitemid = $enrol->add_instance($courserec, (array)$data)) {
            // ok
        } else {
            if ($instances = $DB->get_records('enrol', array('courseid'=>$courserec->id, 'enrol'=>$data->enrol))) {
                // most probably plugin that supports only one instance
                $newitemid = key($instances);
            } else {
                debugging('Can not create new enrol instance or reuse existing');
                $newitemid = 0;
            }
        }

        if ($restoretype === ENROL_RESTORE_NOUSERS) {
            // plugin requests to prevent restore of any users
            $newitemid = 0;
        }

        $this->set_mapping('enrol', $oldid, $newitemid);
    }

    /**
     * Create user enrolments
     *
     * This has to be called after creation of enrolment instances
     * and before adding of role assignments.
     *
     * @param mixed $data
     * @return void
     */
    public function process_enrolment($data) {
        global $DB;

        $data = (object)$data;

        // Process only if parent instance have been mapped
        if ($enrolid = $this->get_new_parentid('enrol')) {
            if ($instance = $DB->get_record('enrol', array('id'=>$enrolid))) {
                // And only if user is a mapped one
                if ($userid = $this->get_mappingid('user', $data->userid)) {
                    $enrol = enrol_get_plugin($instance->enrol);
                    //TODO: do we need specify modifierid?
                    $enrol->enrol_user($instance, $userid, null, $data->timestart, $data->timeend, $data->status);
                    //note: roles are assigned in restore_ras_and_caps_structure_step::process_assignment() processing above
                }
            }
        }
    }
}


/**
 * Make sure the user restoring the course can actually access it.
 */
class restore_fix_restorer_access_step extends restore_execution_step {
    protected function define_execution() {
        global $CFG, $DB;

        if (!$userid = $this->task->get_userid()) {
            return;
        }

        if (empty($CFG->restorernewroleid)) {
            // Bad luck, no fallback role for restorers specified
            return;
        }

        $courseid = $this->get_courseid();
        $context = context_course::instance($courseid);

        if (is_enrolled($context, $userid, 'moodle/course:update', true) or is_viewing($context, $userid, 'moodle/course:update')) {
            // Current user may access the course (admin, category manager or restored teacher enrolment usually)
            return;
        }

        // Try to add role only - we do not need enrolment if user has moodle/course:view or is already enrolled
        role_assign($CFG->restorernewroleid, $userid, $context);

        if (is_enrolled($context, $userid, 'moodle/course:update', true) or is_viewing($context, $userid, 'moodle/course:update')) {
            // Extra role is enough, yay!
            return;
        }

        // The last chance is to create manual enrol if it does not exist and and try to enrol the current user,
        // hopefully admin selected suitable $CFG->restorernewroleid ...
        if (!enrol_is_enabled('manual')) {
            return;
        }
        if (!$enrol = enrol_get_plugin('manual')) {
            return;
        }
        if (!$DB->record_exists('enrol', array('enrol'=>'manual', 'courseid'=>$courseid))) {
            $course = $DB->get_record('course', array('id'=>$courseid), '*', MUST_EXIST);
            $fields = array('status'=>ENROL_INSTANCE_ENABLED, 'enrolperiod'=>$enrol->get_config('enrolperiod', 0), 'roleid'=>$enrol->get_config('roleid', 0));
            $enrol->add_instance($course, $fields);
        }

        enrol_try_internal_enrol($courseid, $userid);
    }
}


/**
 * This structure steps restores the filters and their configs
 */
class restore_filters_structure_step extends restore_structure_step {

    protected function define_structure() {

        $paths = array();

        $paths[] = new restore_path_element('active', '/filters/filter_actives/filter_active');
        $paths[] = new restore_path_element('config', '/filters/filter_configs/filter_config');

        return $paths;
    }

    public function process_active($data) {

        $data = (object)$data;

        if (!filter_is_enabled($data->filter)) { // Not installed or not enabled, nothing to do
            return;
        }
        filter_set_local_state($data->filter, $this->task->get_contextid(), $data->active);
    }

    public function process_config($data) {

        $data = (object)$data;

        if (!filter_is_enabled($data->filter)) { // Not installed or not enabled, nothing to do
            return;
        }
        filter_set_local_config($data->filter, $this->task->get_contextid(), $data->name, $data->value);
    }
}


/**
 * This structure steps restores the comments
 * Note: Cannot use the comments API because defaults to USER->id.
 * That should change allowing to pass $userid
 */
class restore_comments_structure_step extends restore_structure_step {

    protected function define_structure() {

        $paths = array();

        $paths[] = new restore_path_element('comment', '/comments/comment');

        return $paths;
    }

    public function process_comment($data) {
        global $DB;

        $data = (object)$data;

        // First of all, if the comment has some itemid, ask to the task what to map
        $mapping = false;
        if ($data->itemid) {
            $mapping = $this->task->get_comment_mapping_itemname($data->commentarea);
            $data->itemid = $this->get_mappingid($mapping, $data->itemid);
        }
        // Only restore the comment if has no mapping OR we have found the matching mapping
        if (!$mapping || $data->itemid) {
            // Only if user mapping and context
            $data->userid = $this->get_mappingid('user', $data->userid);
            if ($data->userid && $this->task->get_contextid()) {
                $data->contextid = $this->task->get_contextid();
                // Only if there is another comment with same context/user/timecreated
                $params = array('contextid' => $data->contextid, 'userid' => $data->userid, 'timecreated' => $data->timecreated);
                if (!$DB->record_exists('comments', $params)) {
                    $DB->insert_record('comments', $data);
                }
            }
        }
    }
}

/**
 * This structure steps restores the calendar events
 */
class restore_calendarevents_structure_step extends restore_structure_step {

    protected function define_structure() {

        $paths = array();

        $paths[] = new restore_path_element('calendarevents', '/events/event');

        return $paths;
    }

    public function process_calendarevents($data) {
        global $DB;

        $data = (object)$data;
        $oldid = $data->id;
        $restorefiles = true; // We'll restore the files
        // Find the userid and the groupid associated with the event. Return if not found.
        $data->userid = $this->get_mappingid('user', $data->userid);
        if ($data->userid === false) {
            return;
        }
        if (!empty($data->groupid)) {
            $data->groupid = $this->get_mappingid('group', $data->groupid);
            if ($data->groupid === false) {
                return;
            }
        }

        $params = array(
                'name'           => $data->name,
                'description'    => $data->description,
                'format'         => $data->format,
                'courseid'       => $this->get_courseid(),
                'groupid'        => $data->groupid,
                'userid'         => $data->userid,
                'repeatid'       => $data->repeatid,
                'modulename'     => $data->modulename,
                'eventtype'      => $data->eventtype,
                'timestart'      => $this->apply_date_offset($data->timestart),
                'timeduration'   => $data->timeduration,
                'visible'        => $data->visible,
                'uuid'           => $data->uuid,
                'sequence'       => $data->sequence,
                'timemodified'    => $this->apply_date_offset($data->timemodified));
        if ($this->name == 'activity_calendar') {
            $params['instance'] = $this->task->get_activityid();
        } else {
            $params['instance'] = 0;
        }
        $sql = 'SELECT id FROM {event} WHERE name = ? AND courseid = ? AND
                repeatid = ? AND modulename = ? AND timestart = ? AND timeduration =?
                AND ' . $DB->sql_compare_text('description', 255) . ' = ' . $DB->sql_compare_text('?', 255);
        $arg = array ($params['name'], $params['courseid'], $params['repeatid'], $params['modulename'], $params['timestart'], $params['timeduration'], $params['description']);
        $result = $DB->record_exists_sql($sql, $arg);
        if (empty($result)) {
            $newitemid = $DB->insert_record('event', $params);
            $this->set_mapping('event_description', $oldid, $newitemid, $restorefiles);
        }

    }
    protected function after_execute() {
        // Add related files
        $this->add_related_files('calendar', 'event_description', 'event_description');
    }
}

class restore_course_completion_structure_step extends restore_structure_step {

    /**
     * Conditionally decide if this step should be executed.
     *
     * This function checks parameters that are not immediate settings to ensure
     * that the enviroment is suitable for the restore of course completion info.
     *
     * This function checks the following four parameters:
     *
     *   1. Course completion is enabled on the site
     *   2. The backup includes course completion information
     *   3. All modules are restorable
     *   4. All modules are marked for restore.
     *
     * @return bool True is safe to execute, false otherwise
     */
    protected function execute_condition() {
        global $CFG;

        // First check course completion is enabled on this site
        if (empty($CFG->enablecompletion)) {
            // Disabled, don't restore course completion
            return false;
        }

        // Check it is included in the backup
        $fullpath = $this->task->get_taskbasepath();
        $fullpath = rtrim($fullpath, '/') . '/' . $this->filename;
        if (!file_exists($fullpath)) {
            // Not found, can't restore course completion
            return false;
        }

        // Check we are able to restore all backed up modules
        if ($this->task->is_missing_modules()) {
            return false;
        }

        // Finally check all modules within the backup are being restored.
        if ($this->task->is_excluding_activities()) {
            return false;
        }

        return true;
    }

    /**
     * Define the course completion structure
     *
     * @return array Array of restore_path_element
     */
    protected function define_structure() {

        // To know if we are including user completion info
        $userinfo = $this->get_setting_value('userscompletion');

        $paths = array();
        $paths[] = new restore_path_element('course_completion_criteria', '/course_completion/course_completion_criteria');
        $paths[] = new restore_path_element('course_completion_notify', '/course_completion/course_completion_notify');
        $paths[] = new restore_path_element('course_completion_aggr_methd', '/course_completion/course_completion_aggr_methd');

        if ($userinfo) {
            $paths[] = new restore_path_element('course_completion_crit_compl', '/course_completion/course_completion_criteria/course_completion_crit_completions/course_completion_crit_compl');
            $paths[] = new restore_path_element('course_completions', '/course_completion/course_completions');
        }

        return $paths;

    }

    /**
     * Process course completion criteria
     *
     * @global moodle_database $DB
     * @param stdClass $data
     */
    public function process_course_completion_criteria($data) {
        global $DB;

        $data = (object)$data;
        $data->course = $this->get_courseid();

        // Apply the date offset to the time end field
        $data->timeend = $this->apply_date_offset($data->timeend);

        // Map the role from the criteria
        if (!empty($data->role)) {
            $data->role = $this->get_mappingid('role', $data->role);
        }

        $skipcriteria = false;

        // If the completion criteria is for a module we need to map the module instance
        // to the new module id.
        if (!empty($data->moduleinstance) && !empty($data->module)) {
            $data->moduleinstance = $this->get_mappingid('course_module', $data->moduleinstance);
            if (empty($data->moduleinstance)) {
                $skipcriteria = true;
            }
        } else {
            $data->module = null;
            $data->moduleinstance = null;
        }

        // We backup the course shortname rather than the ID so that we can match back to the course
        if (!empty($data->courseinstanceshortname)) {
            $courseinstanceid = $DB->get_field('course', 'id', array('shortname'=>$data->courseinstanceshortname));
            if (!$courseinstanceid) {
                $skipcriteria = true;
            }
        } else {
            $courseinstanceid = null;
        }
        $data->courseinstance = $courseinstanceid;

        if (!$skipcriteria) {
            $params = array(
                'course'         => $data->course,
                'criteriatype'   => $data->criteriatype,
                'enrolperiod'    => $data->enrolperiod,
                'courseinstance' => $data->courseinstance,
                'module'         => $data->module,
                'moduleinstance' => $data->moduleinstance,
                'timeend'        => $data->timeend,
                'gradepass'      => $data->gradepass,
                'role'           => $data->role
            );
            $newid = $DB->insert_record('course_completion_criteria', $params);
            $this->set_mapping('course_completion_criteria', $data->id, $newid);
        }
    }

    /**
     * Processes course compltion criteria complete records
     *
     * @global moodle_database $DB
     * @param stdClass $data
     */
    public function process_course_completion_crit_compl($data) {
        global $DB;

        $data = (object)$data;

        // This may be empty if criteria could not be restored
        $data->criteriaid = $this->get_mappingid('course_completion_criteria', $data->criteriaid);

        $data->course = $this->get_courseid();
        $data->userid = $this->get_mappingid('user', $data->userid);

        if (!empty($data->criteriaid) && !empty($data->userid)) {
            $params = array(
                'userid' => $data->userid,
                'course' => $data->course,
                'criteriaid' => $data->criteriaid,
                'timecompleted' => $this->apply_date_offset($data->timecompleted)
            );
            if (isset($data->gradefinal)) {
                $params['gradefinal'] = $data->gradefinal;
            }
            if (isset($data->unenroled)) {
                $params['unenroled'] = $data->unenroled;
            }
            if (isset($data->deleted)) {
                $params['deleted'] = $data->deleted;
            }
            $DB->insert_record('course_completion_crit_compl', $params);
        }
    }

    /**
     * Process course completions
     *
     * @global moodle_database $DB
     * @param stdClass $data
     */
    public function process_course_completions($data) {
        global $DB;

        $data = (object)$data;

        $data->course = $this->get_courseid();
        $data->userid = $this->get_mappingid('user', $data->userid);

        if (!empty($data->userid)) {
            $params = array(
                'userid' => $data->userid,
                'course' => $data->course,
                'deleted' => $data->deleted,
                'timenotified' => $this->apply_date_offset($data->timenotified),
                'timeenrolled' => $this->apply_date_offset($data->timeenrolled),
                'timestarted' => $this->apply_date_offset($data->timestarted),
                'timecompleted' => $this->apply_date_offset($data->timecompleted),
                'reaggregate' => $data->reaggregate
            );
            $DB->insert_record('course_completions', $params);
        }
    }

    /**
     * Process course completion notification records.
     *
     * Note: As of Moodle 2.0 this table is not being used however it has been
     * left in in the hopes that one day the functionality there will be completed
     *
     * @global moodle_database $DB
     * @param stdClass $data
     */
    public function process_course_completion_notify($data) {
        global $DB;

        $data = (object)$data;

        $data->course = $this->get_courseid();
        if (!empty($data->role)) {
            $data->role = $this->get_mappingid('role', $data->role);
        }

        $params = array(
            'course' => $data->course,
            'role' => $data->role,
            'message' => $data->message,
            'timesent' => $this->apply_date_offset($data->timesent),
        );
        $DB->insert_record('course_completion_notify', $params);
    }

    /**
     * Process course completion aggregate methods
     *
     * @global moodle_database $DB
     * @param stdClass $data
     */
    public function process_course_completion_aggr_methd($data) {
        global $DB;

        $data = (object)$data;

        $data->course = $this->get_courseid();

        // Only create the course_completion_aggr_methd records if
        // the target course has not them defined. MDL-28180
        if (!$DB->record_exists('course_completion_aggr_methd', array(
                    'course' => $data->course,
                    'criteriatype' => $data->criteriatype))) {
            $params = array(
                'course' => $data->course,
                'criteriatype' => $data->criteriatype,
                'method' => $data->method,
                'value' => $data->value,
            );
            $DB->insert_record('course_completion_aggr_methd', $params);
        }
    }
}


/**
 * This structure step restores course logs (cmid = 0), delegating
 * the hard work to the corresponding {@link restore_logs_processor} passing the
 * collection of {@link restore_log_rule} rules to be observed as they are defined
 * by the task. Note this is only executed based in the 'logs' setting.
 *
 * NOTE: This is executed by final task, to have all the activities already restored
 *
 * NOTE: Not all course logs are being restored. For now only 'course' and 'user'
 * records are. There are others like 'calendar' and 'upload' that will be handled
 * later.
 *
 * NOTE: All the missing actions (not able to be restored) are sent to logs for
 * debugging purposes
 */
class restore_course_logs_structure_step extends restore_structure_step {

    /**
     * Conditionally decide if this step should be executed.
     *
     * This function checks the following parameter:
     *
     *   1. the course/logs.xml file exists
     *
     * @return bool true is safe to execute, false otherwise
     */
    protected function execute_condition() {

        // Check it is included in the backup
        $fullpath = $this->task->get_taskbasepath();
        $fullpath = rtrim($fullpath, '/') . '/' . $this->filename;
        if (!file_exists($fullpath)) {
            // Not found, can't restore course logs
            return false;
        }

        return true;
    }

    protected function define_structure() {

        $paths = array();

        // Simple, one plain level of information contains them
        $paths[] = new restore_path_element('log', '/logs/log');

        return $paths;
    }

    protected function process_log($data) {
        global $DB;

        $data = (object)($data);

        $data->time = $this->apply_date_offset($data->time);
        $data->userid = $this->get_mappingid('user', $data->userid);
        $data->course = $this->get_courseid();
        $data->cmid = 0;

        // For any reason user wasn't remapped ok, stop processing this
        if (empty($data->userid)) {
            return;
        }

        // Everything ready, let's delegate to the restore_logs_processor

        // Set some fixed values that will save tons of DB requests
        $values = array(
            'course' => $this->get_courseid());
        // Get instance and process log record
        $data = restore_logs_processor::get_instance($this->task, $values)->process_log_record($data);

        // If we have data, insert it, else something went wrong in the restore_logs_processor
        if ($data) {
            $DB->insert_record('log', $data);
        }
    }
}

/**
 * This structure step restores activity logs, extending {@link restore_course_logs_structure_step}
 * sharing its same structure but modifying the way records are handled
 */
class restore_activity_logs_structure_step extends restore_course_logs_structure_step {

    protected function process_log($data) {
        global $DB;

        $data = (object)($data);

        $data->time = $this->apply_date_offset($data->time);
        $data->userid = $this->get_mappingid('user', $data->userid);
        $data->course = $this->get_courseid();
        $data->cmid = $this->task->get_moduleid();

        // For any reason user wasn't remapped ok, stop processing this
        if (empty($data->userid)) {
            return;
        }

        // Everything ready, let's delegate to the restore_logs_processor

        // Set some fixed values that will save tons of DB requests
        $values = array(
            'course' => $this->get_courseid(),
            'course_module' => $this->task->get_moduleid(),
            $this->task->get_modulename() => $this->task->get_activityid());
        // Get instance and process log record
        $data = restore_logs_processor::get_instance($this->task, $values)->process_log_record($data);

        // If we have data, insert it, else something went wrong in the restore_logs_processor
        if ($data) {
            $DB->insert_record('log', $data);
        }
    }
}


/**
 * Defines the restore step for advanced grading methods attached to the activity module
 */
class restore_activity_grading_structure_step extends restore_structure_step {

    /**
     * This step is executed only if the grading file is present
     */
     protected function execute_condition() {

        $fullpath = $this->task->get_taskbasepath();
        $fullpath = rtrim($fullpath, '/') . '/' . $this->filename;
        if (!file_exists($fullpath)) {
            return false;
        }

        return true;
    }


    /**
     * Declares paths in the grading.xml file we are interested in
     */
    protected function define_structure() {

        $paths = array();
        $userinfo = $this->get_setting_value('userinfo');

        $paths[] = new restore_path_element('grading_area', '/areas/area');

        $definition = new restore_path_element('grading_definition', '/areas/area/definitions/definition');
        $paths[] = $definition;
        $this->add_plugin_structure('gradingform', $definition);

        if ($userinfo) {
            $instance = new restore_path_element('grading_instance',
                '/areas/area/definitions/definition/instances/instance');
            $paths[] = $instance;
            $this->add_plugin_structure('gradingform', $instance);
        }

        return $paths;
    }

    /**
     * Processes one grading area element
     *
     * @param array $data element data
     */
    protected function process_grading_area($data) {
        global $DB;

        $task = $this->get_task();
        $data = (object)$data;
        $oldid = $data->id;
        $data->component = 'mod_'.$task->get_modulename();
        $data->contextid = $task->get_contextid();

        $newid = $DB->insert_record('grading_areas', $data);
        $this->set_mapping('grading_area', $oldid, $newid);
    }

    /**
     * Processes one grading definition element
     *
     * @param array $data element data
     */
    protected function process_grading_definition($data) {
        global $DB;

        $task = $this->get_task();
        $data = (object)$data;
        $oldid = $data->id;
        $data->areaid = $this->get_new_parentid('grading_area');
        $data->copiedfromid = null;
        $data->timecreated = time();
        $data->usercreated = $task->get_userid();
        $data->timemodified = $data->timecreated;
        $data->usermodified = $data->usercreated;

        $newid = $DB->insert_record('grading_definitions', $data);
        $this->set_mapping('grading_definition', $oldid, $newid, true);
    }

    /**
     * Processes one grading form instance element
     *
     * @param array $data element data
     */
    protected function process_grading_instance($data) {
        global $DB;

        $data = (object)$data;

        // new form definition id
        $newformid = $this->get_new_parentid('grading_definition');

        // get the name of the area we are restoring to
        $sql = "SELECT ga.areaname
                  FROM {grading_definitions} gd
                  JOIN {grading_areas} ga ON gd.areaid = ga.id
                 WHERE gd.id = ?";
        $areaname = $DB->get_field_sql($sql, array($newformid), MUST_EXIST);

        // get the mapped itemid - the activity module is expected to define the mappings
        // for each gradable area
        $newitemid = $this->get_mappingid(restore_gradingform_plugin::itemid_mapping($areaname), $data->itemid);

        $oldid = $data->id;
        $data->definitionid = $newformid;
        $data->raterid = $this->get_mappingid('user', $data->raterid);
        $data->itemid = $newitemid;

        $newid = $DB->insert_record('grading_instances', $data);
        $this->set_mapping('grading_instance', $oldid, $newid);
    }

    /**
     * Final operations when the database records are inserted
     */
    protected function after_execute() {
        // Add files embedded into the definition description
        $this->add_related_files('grading', 'description', 'grading_definition');
    }
}


/**
 * This structure step restores the grade items associated with one activity
 * All the grade items are made child of the "course" grade item but the original
 * categoryid is saved as parentitemid in the backup_ids table, so, when restoring
 * the complete gradebook (categories and calculations), that information is
 * available there
 */
class restore_activity_grades_structure_step extends restore_structure_step {

    protected function define_structure() {

        $paths = array();
        $userinfo = $this->get_setting_value('userinfo');

        $paths[] = new restore_path_element('grade_item', '/activity_gradebook/grade_items/grade_item');
        $paths[] = new restore_path_element('grade_letter', '/activity_gradebook/grade_letters/grade_letter');
        if ($userinfo) {
            $paths[] = new restore_path_element('grade_grade',
                           '/activity_gradebook/grade_items/grade_item/grade_grades/grade_grade');
        }
        return $paths;
    }

    protected function process_grade_item($data) {
        global $DB;

        $data = (object)($data);
        $oldid       = $data->id;        // We'll need these later
        $oldparentid = $data->categoryid;
        $courseid = $this->get_courseid();

        // make sure top course category exists, all grade items will be associated
        // to it. Later, if restoring the whole gradebook, categories will be introduced
        $coursecat = grade_category::fetch_course_category($courseid);
        $coursecatid = $coursecat->id; // Get the categoryid to be used

        $idnumber = null;
        if (!empty($data->idnumber)) {
            // Don't get any idnumber from course module. Keep them as they are in grade_item->idnumber
            // Reason: it's not clear what happens with outcomes->idnumber or activities with multiple items (workshop)
            // so the best is to keep the ones already in the gradebook
            // Potential problem: duplicates if same items are restored more than once. :-(
            // This needs to be fixed in some way (outcomes & activities with multiple items)
            // $data->idnumber     = get_coursemodule_from_instance($data->itemmodule, $data->iteminstance)->idnumber;
            // In any case, verify always for uniqueness
            $sql = "SELECT cm.id
                      FROM {course_modules} cm
                     WHERE cm.course = :courseid AND
                           cm.idnumber = :idnumber AND
                           cm.id <> :cmid";
            $params = array(
                'courseid' => $courseid,
                'idnumber' => $data->idnumber,
                'cmid' => $this->task->get_moduleid()
            );
            if (!$DB->record_exists_sql($sql, $params) && !$DB->record_exists('grade_items', array('courseid' => $courseid, 'idnumber' => $data->idnumber))) {
                $idnumber = $data->idnumber;
            }
        }

        unset($data->id);
        $data->categoryid   = $coursecatid;
        $data->courseid     = $this->get_courseid();
        $data->iteminstance = $this->task->get_activityid();
        $data->idnumber     = $idnumber;
        $data->scaleid      = $this->get_mappingid('scale', $data->scaleid);
        $data->outcomeid    = $this->get_mappingid('outcome', $data->outcomeid);
        $data->timecreated  = $this->apply_date_offset($data->timecreated);
        $data->timemodified = $this->apply_date_offset($data->timemodified);

        $gradeitem = new grade_item($data, false);
        $gradeitem->insert('restore');

        //sortorder is automatically assigned when inserting. Re-instate the previous sortorder
        $gradeitem->sortorder = $data->sortorder;
        $gradeitem->update('restore');

        // Set mapping, saving the original category id into parentitemid
        // gradebook restore (final task) will need it to reorganise items
        $this->set_mapping('grade_item', $oldid, $gradeitem->id, false, null, $oldparentid);
    }

    protected function process_grade_grade($data) {
        $data = (object)($data);

        unset($data->id);
        $data->itemid = $this->get_new_parentid('grade_item');
        $data->userid = $this->get_mappingid('user', $data->userid);
        $data->usermodified = $this->get_mappingid('user', $data->usermodified);
        $data->rawscaleid = $this->get_mappingid('scale', $data->rawscaleid);
        // TODO: Ask, all the rest of locktime/exported... work with time... to be rolled?
        $data->overridden = $this->apply_date_offset($data->overridden);

        $grade = new grade_grade($data, false);
        $grade->insert('restore');
        // no need to save any grade_grade mapping
    }

    /**
     * process activity grade_letters. Note that, while these are possible,
     * because grade_letters are contextid based, in proctice, only course
     * context letters can be defined. So we keep here this method knowing
     * it won't be executed ever. gradebook restore will restore course letters.
     */
    protected function process_grade_letter($data) {
        global $DB;

        $data = (object)$data;

        $data->contextid = $this->task->get_contextid();
        $newitemid = $DB->insert_record('grade_letters', $data);
        // no need to save any grade_letter mapping
    }
}


/**
 * This structure steps restores one instance + positions of one block
 * Note: Positions corresponding to one existing context are restored
 * here, but all the ones having unknown contexts are sent to backup_ids
 * for a later chance to be restored at the end (final task)
 */
class restore_block_instance_structure_step extends restore_structure_step {

    protected function define_structure() {

        $paths = array();

        $paths[] = new restore_path_element('block', '/block', true); // Get the whole XML together
        $paths[] = new restore_path_element('block_position', '/block/block_positions/block_position');

        return $paths;
    }

    public function process_block($data) {
        global $DB, $CFG;

        $data = (object)$data; // Handy
        $oldcontextid = $data->contextid;
        $oldid        = $data->id;
        $positions = isset($data->block_positions['block_position']) ? $data->block_positions['block_position'] : array();

        // Look for the parent contextid
        if (!$data->parentcontextid = $this->get_mappingid('context', $data->parentcontextid)) {
            throw new restore_step_exception('restore_block_missing_parent_ctx', $data->parentcontextid);
        }

        // TODO: it would be nice to use standard plugin supports instead of this instance_allow_multiple()
        // If there is already one block of that type in the parent context
        // and the block is not multiple, stop processing
        // Use blockslib loader / method executor
        if (!$bi = block_instance($data->blockname)) {
            return false;
        }

        if (!$bi->instance_allow_multiple()) {
            if ($DB->record_exists_sql("SELECT bi.id
                                          FROM {block_instances} bi
                                          JOIN {block} b ON b.name = bi.blockname
                                         WHERE bi.parentcontextid = ?
                                           AND bi.blockname = ?", array($data->parentcontextid, $data->blockname))) {
                return false;
            }
        }

        // If there is already one block of that type in the parent context
        // with the same showincontexts, pagetypepattern, subpagepattern, defaultregion and configdata
        // stop processing
        $params = array(
            'blockname' => $data->blockname, 'parentcontextid' => $data->parentcontextid,
            'showinsubcontexts' => $data->showinsubcontexts, 'pagetypepattern' => $data->pagetypepattern,
            'subpagepattern' => $data->subpagepattern, 'defaultregion' => $data->defaultregion);
        if ($birecs = $DB->get_records('block_instances', $params)) {
            foreach($birecs as $birec) {
                if ($birec->configdata == $data->configdata) {
                    return false;
                }
            }
        }

        // Set task old contextid, blockid and blockname once we know them
        $this->task->set_old_contextid($oldcontextid);
        $this->task->set_old_blockid($oldid);
        $this->task->set_blockname($data->blockname);

        // Let's look for anything within configdata neededing processing
        // (nulls and uses of legacy file.php)
        if ($attrstotransform = $this->task->get_configdata_encoded_attributes()) {
            $configdata = (array)unserialize(base64_decode($data->configdata));
            foreach ($configdata as $attribute => $value) {
                if (in_array($attribute, $attrstotransform)) {
                    $configdata[$attribute] = $this->contentprocessor->process_cdata($value);
                }
            }
            $data->configdata = base64_encode(serialize((object)$configdata));
        }

        // Create the block instance
        $newitemid = $DB->insert_record('block_instances', $data);
        // Save the mapping (with restorefiles support)
        $this->set_mapping('block_instance', $oldid, $newitemid, true);
        // Create the block context
        $newcontextid = get_context_instance(CONTEXT_BLOCK, $newitemid)->id;
        // Save the block contexts mapping and sent it to task
        $this->set_mapping('context', $oldcontextid, $newcontextid);
        $this->task->set_contextid($newcontextid);
        $this->task->set_blockid($newitemid);

        // Restore block fileareas if declared
        $component = 'block_' . $this->task->get_blockname();
        foreach ($this->task->get_fileareas() as $filearea) { // Simple match by contextid. No itemname needed
            $this->add_related_files($component, $filearea, null);
        }

        // Process block positions, creating them or accumulating for final step
        foreach($positions as $position) {
            $position = (object)$position;
            $position->blockinstanceid = $newitemid; // The instance is always the restored one
            // If position is for one already mapped (known) contextid
            // process it now, creating the position
            if ($newpositionctxid = $this->get_mappingid('context', $position->contextid)) {
                $position->contextid = $newpositionctxid;
                // Create the block position
                $DB->insert_record('block_positions', $position);

            // The position belongs to an unknown context, send it to backup_ids
            // to process them as part of the final steps of restore. We send the
            // whole $position object there, hence use the low level method.
            } else {
                restore_dbops::set_backup_ids_record($this->get_restoreid(), 'block_position', $position->id, 0, null, $position);
            }
        }
    }
}

/**
 * Structure step to restore common course_module information
 *
 * This step will process the module.xml file for one activity, in order to restore
 * the corresponding information to the course_modules table, skipping various bits
 * of information based on CFG settings (groupings, completion...) in order to fullfill
 * all the reqs to be able to create the context to be used by all the rest of steps
 * in the activity restore task
 */
class restore_module_structure_step extends restore_structure_step {

    protected function define_structure() {
        global $CFG;

        $paths = array();

        $module = new restore_path_element('module', '/module');
        $paths[] = $module;
        if ($CFG->enableavailability) {
            $paths[] = new restore_path_element('availability', '/module/availability_info/availability');
        }

        // Apply for 'format' plugins optional paths at module level
        $this->add_plugin_structure('format', $module);

        // Apply for 'plagiarism' plugins optional paths at module level
        $this->add_plugin_structure('plagiarism', $module);

        return $paths;
    }

    protected function process_module($data) {
        global $CFG, $DB;

        $data = (object)$data;
        $oldid = $data->id;

        $this->task->set_old_moduleversion($data->version);

        $data->course = $this->task->get_courseid();
        $data->module = $DB->get_field('modules', 'id', array('name' => $data->modulename));
        // Map section (first try by course_section mapping match. Useful in course and section restores)
        $data->section = $this->get_mappingid('course_section', $data->sectionid);
        if (!$data->section) { // mapping failed, try to get section by sectionnumber matching
            $params = array(
                'course' => $this->get_courseid(),
                'section' => $data->sectionnumber);
            $data->section = $DB->get_field('course_sections', 'id', $params);
        }
        if (!$data->section) { // sectionnumber failed, try to get first section in course
            $params = array(
                'course' => $this->get_courseid());
            $data->section = $DB->get_field('course_sections', 'MIN(id)', $params);
        }
        if (!$data->section) { // no sections in course, create section 0 and 1 and assign module to 1
            $sectionrec = array(
                'course' => $this->get_courseid(),
                'section' => 0);
            $DB->insert_record('course_sections', $sectionrec); // section 0
            $sectionrec = array(
                'course' => $this->get_courseid(),
                'section' => 1);
            $data->section = $DB->insert_record('course_sections', $sectionrec); // section 1
        }
        $data->groupingid= $this->get_mappingid('grouping', $data->groupingid);      // grouping
        if (!$CFG->enablegroupmembersonly) {                                         // observe groupsmemberonly
            $data->groupmembersonly = 0;
        }
        if (!grade_verify_idnumber($data->idnumber, $this->get_courseid())) {        // idnumber uniqueness
            $data->idnumber = '';
        }
        if (empty($CFG->enablecompletion)) { // completion
            $data->completion = 0;
            $data->completiongradeitemnumber = null;
            $data->completionview = 0;
            $data->completionexpected = 0;
        } else {
            $data->completionexpected = $this->apply_date_offset($data->completionexpected);
        }
        if (empty($CFG->enableavailability)) {
            $data->availablefrom = 0;
            $data->availableuntil = 0;
            $data->showavailability = 0;
        } else {
            $data->availablefrom = $this->apply_date_offset($data->availablefrom);
            $data->availableuntil= $this->apply_date_offset($data->availableuntil);
        }
        // Backups that did not include showdescription, set it to default 0
        // (this is not totally necessary as it has a db default, but just to
        // be explicit).
        if (!isset($data->showdescription)) {
            $data->showdescription = 0;
        }
        $data->instance = 0; // Set to 0 for now, going to create it soon (next step)

        // course_module record ready, insert it
        $newitemid = $DB->insert_record('course_modules', $data);
        // save mapping
        $this->set_mapping('course_module', $oldid, $newitemid);
        // set the new course_module id in the task
        $this->task->set_moduleid($newitemid);
        // we can now create the context safely
        $ctxid = get_context_instance(CONTEXT_MODULE, $newitemid)->id;
        // set the new context id in the task
        $this->task->set_contextid($ctxid);
        // update sequence field in course_section
        if ($sequence = $DB->get_field('course_sections', 'sequence', array('id' => $data->section))) {
            $sequence .= ',' . $newitemid;
        } else {
            $sequence = $newitemid;
        }
        $DB->set_field('course_sections', 'sequence', $sequence, array('id' => $data->section));
    }


    protected function process_availability($data) {
        $data = (object)$data;
        // Simply going to store the whole availability record now, we'll process
        // all them later in the final task (once all actvivities have been restored)
        // Let's call the low level one to be able to store the whole object
        $data->coursemoduleid = $this->task->get_moduleid(); // Let add the availability cmid
        restore_dbops::set_backup_ids_record($this->get_restoreid(), 'module_availability', $data->id, 0, null, $data);
    }
}

/**
 * Structure step that will process the user activity completion
 * information if all these conditions are met:
 *  - Target site has completion enabled ($CFG->enablecompletion)
 *  - Activity includes completion info (file_exists)
 */
class restore_userscompletion_structure_step extends restore_structure_step {
    /**
     * To conditionally decide if this step must be executed
     * Note the "settings" conditions are evaluated in the
     * corresponding task. Here we check for other conditions
     * not being restore settings (files, site settings...)
     */
     protected function execute_condition() {
         global $CFG;

         // Completion disabled in this site, don't execute
         if (empty($CFG->enablecompletion)) {
             return false;
         }

         // No user completion info found, don't execute
        $fullpath = $this->task->get_taskbasepath();
        $fullpath = rtrim($fullpath, '/') . '/' . $this->filename;
         if (!file_exists($fullpath)) {
             return false;
         }

         // Arrived here, execute the step
         return true;
     }

     protected function define_structure() {

        $paths = array();

        $paths[] = new restore_path_element('completion', '/completions/completion');

        return $paths;
    }

    protected function process_completion($data) {
        global $DB;

        $data = (object)$data;

        $data->coursemoduleid = $this->task->get_moduleid();
        $data->userid = $this->get_mappingid('user', $data->userid);
        $data->timemodified = $this->apply_date_offset($data->timemodified);

        // Find the existing record
        $existing = $DB->get_record('course_modules_completion', array(
                'coursemoduleid' => $data->coursemoduleid,
                'userid' => $data->userid), 'id, timemodified');
        // Check we didn't already insert one for this cmid and userid
        // (there aren't supposed to be duplicates in that field, but
        // it was possible until MDL-28021 was fixed).
        if ($existing) {
            // Update it to these new values, but only if the time is newer
            if ($existing->timemodified < $data->timemodified) {
                $data->id = $existing->id;
                $DB->update_record('course_modules_completion', $data);
            }
        } else {
            // Normal entry where it doesn't exist already
            $DB->insert_record('course_modules_completion', $data);
        }
    }
}

/**
 * Abstract structure step, parent of all the activity structure steps. Used to suuport
 * the main <activity ...> tag and process it. Also provides subplugin support for
 * activities.
 */
abstract class restore_activity_structure_step extends restore_structure_step {

    protected function add_subplugin_structure($subplugintype, $element) {

        global $CFG;

        // Check the requested subplugintype is a valid one
        $subpluginsfile = $CFG->dirroot . '/mod/' . $this->task->get_modulename() . '/db/subplugins.php';
        if (!file_exists($subpluginsfile)) {
             throw new restore_step_exception('activity_missing_subplugins_php_file', $this->task->get_modulename());
        }
        include($subpluginsfile);
        if (!array_key_exists($subplugintype, $subplugins)) {
             throw new restore_step_exception('incorrect_subplugin_type', $subplugintype);
        }
        // Get all the restore path elements, looking across all the subplugin dirs
        $subpluginsdirs = get_plugin_list($subplugintype);
        foreach ($subpluginsdirs as $name => $subpluginsdir) {
            $classname = 'restore_' . $subplugintype . '_' . $name . '_subplugin';
            $restorefile = $subpluginsdir . '/backup/moodle2/' . $classname . '.class.php';
            if (file_exists($restorefile)) {
                require_once($restorefile);
                $restoresubplugin = new $classname($subplugintype, $name, $this);
                // Add subplugin paths to the step
                $this->prepare_pathelements($restoresubplugin->define_subplugin_structure($element));
            }
        }
    }

    /**
     * As far as activity restore steps are implementing restore_subplugin stuff, they need to
     * have the parent task available for wrapping purposes (get course/context....)
     * @return restore_task
     */
    public function get_task() {
        return $this->task;
    }

    /**
     * Adds support for the 'activity' path that is common to all the activities
     * and will be processed globally here
     */
    protected function prepare_activity_structure($paths) {

        $paths[] = new restore_path_element('activity', '/activity');

        return $paths;
    }

    /**
     * Process the activity path, informing the task about various ids, needed later
     */
    protected function process_activity($data) {
        $data = (object)$data;
        $this->task->set_old_contextid($data->contextid); // Save old contextid in task
        $this->set_mapping('context', $data->contextid, $this->task->get_contextid()); // Set the mapping
        $this->task->set_old_activityid($data->id); // Save old activityid in task
    }

    /**
     * This must be invoked immediately after creating the "module" activity record (forum, choice...)
     * and will adjust the new activity id (the instance) in various places
     */
    protected function apply_activity_instance($newitemid) {
        global $DB;

        $this->task->set_activityid($newitemid); // Save activity id in task
        // Apply the id to course_sections->instanceid
        $DB->set_field('course_modules', 'instance', $newitemid, array('id' => $this->task->get_moduleid()));
        // Do the mapping for modulename, preparing it for files by oldcontext
        $modulename = $this->task->get_modulename();
        $oldid = $this->task->get_old_activityid();
        $this->set_mapping($modulename, $oldid, $newitemid, true);
    }
}

/**
 * Structure step in charge of creating/mapping all the qcats and qs
 * by parsing the questions.xml file and checking it against the
 * results calculated by {@link restore_process_categories_and_questions}
 * and stored in backup_ids_temp
 */
class restore_create_categories_and_questions extends restore_structure_step {

    protected function define_structure() {

        $category = new restore_path_element('question_category', '/question_categories/question_category');
        $question = new restore_path_element('question', '/question_categories/question_category/questions/question');
        $hint = new restore_path_element('question_hint',
                '/question_categories/question_category/questions/question/question_hints/question_hint');

        // Apply for 'qtype' plugins optional paths at question level
        $this->add_plugin_structure('qtype', $question);

        return array($category, $question, $hint);
    }

    protected function process_question_category($data) {
        global $DB;

        $data = (object)$data;
        $oldid = $data->id;

        // Check we have one mapping for this category
        if (!$mapping = $this->get_mapping('question_category', $oldid)) {
            return self::SKIP_ALL_CHILDREN; // No mapping = this category doesn't need to be created/mapped
        }

        // Check we have to create the category (newitemid = 0)
        if ($mapping->newitemid) {
            return; // newitemid != 0, this category is going to be mapped. Nothing to do
        }

        // Arrived here, newitemid = 0, we need to create the category
        // we'll do it at parentitemid context, but for CONTEXT_MODULE
        // categories, that will be created at CONTEXT_COURSE and moved
        // to module context later when the activity is created
        if ($mapping->info->contextlevel == CONTEXT_MODULE) {
            $mapping->parentitemid = $this->get_mappingid('context', $this->task->get_old_contextid());
        }
        $data->contextid = $mapping->parentitemid;

        // Let's create the question_category and save mapping
        $newitemid = $DB->insert_record('question_categories', $data);
        $this->set_mapping('question_category', $oldid, $newitemid);
        // Also annotate them as question_category_created, we need
        // that later when remapping parents
        $this->set_mapping('question_category_created', $oldid, $newitemid, false, null, $data->contextid);
    }

    protected function process_question($data) {
        global $DB;

        $data = (object)$data;
        $oldid = $data->id;

        // Check we have one mapping for this question
        if (!$questionmapping = $this->get_mapping('question', $oldid)) {
            return; // No mapping = this question doesn't need to be created/mapped
        }

        // Get the mapped category (cannot use get_new_parentid() because not
        // all the categories have been created, so it is not always available
        // Instead we get the mapping for the question->parentitemid because
        // we have loaded qcatids there for all parsed questions
        $data->category = $this->get_mappingid('question_category', $questionmapping->parentitemid);

        // In the past, there were some very sloppy values of penalty. Fix them.
        if ($data->penalty >= 0.33 && $data->penalty <= 0.34) {
            $data->penalty = 0.3333333;
        }
        if ($data->penalty >= 0.66 && $data->penalty <= 0.67) {
            $data->penalty = 0.6666667;
        }
        if ($data->penalty >= 1) {
            $data->penalty = 1;
        }

        $data->timecreated  = $this->apply_date_offset($data->timecreated);
        $data->timemodified = $this->apply_date_offset($data->timemodified);

        $userid = $this->get_mappingid('user', $data->createdby);
        $data->createdby = $userid ? $userid : $this->task->get_userid();

        $userid = $this->get_mappingid('user', $data->modifiedby);
        $data->modifiedby = $userid ? $userid : $this->task->get_userid();

        // With newitemid = 0, let's create the question
        if (!$questionmapping->newitemid) {
            $newitemid = $DB->insert_record('question', $data);
            $this->set_mapping('question', $oldid, $newitemid);
            // Also annotate them as question_created, we need
            // that later when remapping parents (keeping the old categoryid as parentid)
            $this->set_mapping('question_created', $oldid, $newitemid, false, null, $questionmapping->parentitemid);
        } else {
            // By performing this set_mapping() we make get_old/new_parentid() to work for all the
            // children elements of the 'question' one (so qtype plugins will know the question they belong to)
            $this->set_mapping('question', $oldid, $questionmapping->newitemid);
        }

        // Note, we don't restore any question files yet
        // as far as the CONTEXT_MODULE categories still
        // haven't their contexts to be restored to
        // The {@link restore_create_question_files}, executed in the final step
        // step will be in charge of restoring all the question files
    }

        protected function process_question_hint($data) {
        global $DB;

        $data = (object)$data;
        $oldid = $data->id;

        // Detect if the question is created or mapped
        $oldquestionid   = $this->get_old_parentid('question');
        $newquestionid   = $this->get_new_parentid('question');
        $questioncreated = $this->get_mappingid('question_created', $oldquestionid) ? true : false;

        // If the question has been created by restore, we need to create its question_answers too
        if ($questioncreated) {
            // Adjust some columns
            $data->questionid = $newquestionid;
            // Insert record
            $newitemid = $DB->insert_record('question_hints', $data);

        // The question existed, we need to map the existing question_hints
        } else {
            // Look in question_hints by hint text matching
            $sql = 'SELECT id
                      FROM {question_hints}
                     WHERE questionid = ?
                       AND ' . $DB->sql_compare_text('hint', 255) . ' = ' . $DB->sql_compare_text('?', 255);
            $params = array($newquestionid, $data->hint);
            $newitemid = $DB->get_field_sql($sql, $params);
            // If we haven't found the newitemid, something has gone really wrong, question in DB
            // is missing hints, exception
            if (!$newitemid) {
                $info = new stdClass();
                $info->filequestionid = $oldquestionid;
                $info->dbquestionid   = $newquestionid;
                $info->hint           = $data->hint;
                throw new restore_step_exception('error_question_hint_missing_in_db', $info);
            }
        }
        // Create mapping (I'm not sure if this is really needed?)
        $this->set_mapping('question_hint', $oldid, $newitemid);
    }

    protected function after_execute() {
        global $DB;

        // First of all, recode all the created question_categories->parent fields
        $qcats = $DB->get_records('backup_ids_temp', array(
                     'backupid' => $this->get_restoreid(),
                     'itemname' => 'question_category_created'));
        foreach ($qcats as $qcat) {
            $newparent = 0;
            $dbcat = $DB->get_record('question_categories', array('id' => $qcat->newitemid));
            // Get new parent (mapped or created, so we look in quesiton_category mappings)
            if ($newparent = $DB->get_field('backup_ids_temp', 'newitemid', array(
                                 'backupid' => $this->get_restoreid(),
                                 'itemname' => 'question_category',
                                 'itemid'   => $dbcat->parent))) {
                // contextids must match always, as far as we always include complete qbanks, just check it
                $newparentctxid = $DB->get_field('question_categories', 'contextid', array('id' => $newparent));
                if ($dbcat->contextid == $newparentctxid) {
                    $DB->set_field('question_categories', 'parent', $newparent, array('id' => $dbcat->id));
                } else {
                    $newparent = 0; // No ctx match for both cats, no parent relationship
                }
            }
            // Here with $newparent empty, problem with contexts or remapping, set it to top cat
            if (!$newparent) {
                $DB->set_field('question_categories', 'parent', 0, array('id' => $dbcat->id));
            }
        }

        // Now, recode all the created question->parent fields
        $qs = $DB->get_records('backup_ids_temp', array(
                  'backupid' => $this->get_restoreid(),
                  'itemname' => 'question_created'));
        foreach ($qs as $q) {
            $newparent = 0;
            $dbq = $DB->get_record('question', array('id' => $q->newitemid));
            // Get new parent (mapped or created, so we look in question mappings)
            if ($newparent = $DB->get_field('backup_ids_temp', 'newitemid', array(
                                 'backupid' => $this->get_restoreid(),
                                 'itemname' => 'question',
                                 'itemid'   => $dbq->parent))) {
                $DB->set_field('question', 'parent', $newparent, array('id' => $dbq->id));
            }
        }

        // Note, we don't restore any question files yet
        // as far as the CONTEXT_MODULE categories still
        // haven't their contexts to be restored to
        // The {@link restore_create_question_files}, executed in the final step
        // step will be in charge of restoring all the question files
    }
}

/**
 * Execution step that will move all the CONTEXT_MODULE question categories
 * created at early stages of restore in course context (because modules weren't
 * created yet) to their target module (matching by old-new-contextid mapping)
 */
class restore_move_module_questions_categories extends restore_execution_step {

    protected function define_execution() {
        global $DB;

        $contexts = restore_dbops::restore_get_question_banks($this->get_restoreid(), CONTEXT_MODULE);
        foreach ($contexts as $contextid => $contextlevel) {
            // Only if context mapping exists (i.e. the module has been restored)
            if ($newcontext = restore_dbops::get_backup_ids_record($this->get_restoreid(), 'context', $contextid)) {
                // Update all the qcats having their parentitemid set to the original contextid
                $modulecats = $DB->get_records_sql("SELECT itemid, newitemid
                                                      FROM {backup_ids_temp}
                                                     WHERE backupid = ?
                                                       AND itemname = 'question_category'
                                                       AND parentitemid = ?", array($this->get_restoreid(), $contextid));
                foreach ($modulecats as $modulecat) {
                    $DB->set_field('question_categories', 'contextid', $newcontext->newitemid, array('id' => $modulecat->newitemid));
                    // And set new contextid also in question_category mapping (will be
                    // used by {@link restore_create_question_files} later
                    restore_dbops::set_backup_ids_record($this->get_restoreid(), 'question_category', $modulecat->itemid, $modulecat->newitemid, $newcontext->newitemid);
                }
            }
        }
    }
}

/**
 * Execution step that will create all the question/answers/qtype-specific files for the restored
 * questions. It must be executed after {@link restore_move_module_questions_categories}
 * because only then each question is in its final category and only then the
 * context can be determined
 *
 * TODO: Improve this. Instead of looping over each question, it can be reduced to
 *       be done by contexts (this will save a huge ammount of queries)
 */
class restore_create_question_files extends restore_execution_step {

    protected function define_execution() {
        global $DB;

        // Let's process only created questions
        $questionsrs = $DB->get_recordset_sql("SELECT bi.itemid, bi.newitemid, bi.parentitemid, q.qtype
                                               FROM {backup_ids_temp} bi
                                               JOIN {question} q ON q.id = bi.newitemid
                                              WHERE bi.backupid = ?
                                                AND bi.itemname = 'question_created'", array($this->get_restoreid()));
        foreach ($questionsrs as $question) {
            // Get question_category mapping, it contains the target context for the question
            if (!$qcatmapping = restore_dbops::get_backup_ids_record($this->get_restoreid(), 'question_category', $question->parentitemid)) {
                // Something went really wrong, cannot find the question_category for the question
                debugging('Error fetching target context for question', DEBUG_DEVELOPER);
                continue;
            }
            // Calculate source and target contexts
            $oldctxid = $qcatmapping->info->contextid;
            $newctxid = $qcatmapping->parentitemid;

            // Add common question files (question and question_answer ones)
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'questiontext',
                                              $oldctxid, $this->task->get_userid(), 'question_created', $question->itemid, $newctxid, true);
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'generalfeedback',
                                              $oldctxid, $this->task->get_userid(), 'question_created', $question->itemid, $newctxid, true);
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'answer',
                                              $oldctxid, $this->task->get_userid(), 'question_answer', null, $newctxid, true);
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'answerfeedback',
                                              $oldctxid, $this->task->get_userid(), 'question_answer', null, $newctxid, true);
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'hint',
                                              $oldctxid, $this->task->get_userid(), 'question_hint', null, $newctxid, true);
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'correctfeedback',
                                              $oldctxid, $this->task->get_userid(), 'question_created', $question->itemid, $newctxid, true);
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'partiallycorrectfeedback',
                                              $oldctxid, $this->task->get_userid(), 'question_created', $question->itemid, $newctxid, true);
            restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), 'question', 'incorrectfeedback',
                                              $oldctxid, $this->task->get_userid(), 'question_created', $question->itemid, $newctxid, true);
            // Add qtype dependent files
            $components = backup_qtype_plugin::get_components_and_fileareas($question->qtype);
            foreach ($components as $component => $fileareas) {
                foreach ($fileareas as $filearea => $mapping) {
                    // Use itemid only if mapping is question_created
                    $itemid = ($mapping == 'question_created') ? $question->itemid : null;
                    restore_dbops::send_files_to_pool($this->get_basepath(), $this->get_restoreid(), $component, $filearea,
                                                      $oldctxid, $this->task->get_userid(), $mapping, $itemid, $newctxid, true);
                }
            }
        }
        $questionsrs->close();
    }
}

/**
 * Abstract structure step, to be used by all the activities using core questions stuff
 * (like the quiz module), to support qtype plugins, states and sessions
 */
abstract class restore_questions_activity_structure_step extends restore_activity_structure_step {
    /** @var array question_attempt->id to qtype. */
    protected $qtypes = array();
    /** @var array question_attempt->id to questionid. */
    protected $newquestionids = array();

    /**
     * Attach below $element (usually attempts) the needed restore_path_elements
     * to restore question_usages and all they contain.
     */
    protected function add_question_usages($element, &$paths) {
        // Check $element is restore_path_element
        if (! $element instanceof restore_path_element) {
            throw new restore_step_exception('element_must_be_restore_path_element', $element);
        }
        // Check $paths is one array
        if (!is_array($paths)) {
            throw new restore_step_exception('paths_must_be_array', $paths);
        }
        $paths[] = new restore_path_element('question_usage',
                $element->get_path() . '/question_usage');
        $paths[] = new restore_path_element('question_attempt',
                $element->get_path() . '/question_usage/question_attempts/question_attempt');
        $paths[] = new restore_path_element('question_attempt_step',
                $element->get_path() . '/question_usage/question_attempts/question_attempt/steps/step',
                true);
        $paths[] = new restore_path_element('question_attempt_step_data',
                $element->get_path() . '/question_usage/question_attempts/question_attempt/steps/step/response/variable');
    }

    /**
     * Process question_usages
     */
    protected function process_question_usage($data) {
        global $DB;

        // Clear our caches.
        $this->qtypes = array();
        $this->newquestionids = array();

        $data = (object)$data;
        $oldid = $data->id;

        $oldcontextid = $this->get_task()->get_old_contextid();
        $data->contextid  = $this->get_mappingid('context', $this->task->get_old_contextid());

        // Everything ready, insert (no mapping needed)
        $newitemid = $DB->insert_record('question_usages', $data);

        $this->inform_new_usage_id($newitemid);

        $this->set_mapping('question_usage', $oldid, $newitemid, false);
    }

    /**
     * When process_question_usage creates the new usage, it calls this method
     * to let the activity link to the new usage. For example, the quiz uses
     * this method to set quiz_attempts.uniqueid to the new usage id.
     * @param integer $newusageid
     */
    abstract protected function inform_new_usage_id($newusageid);

    /**
     * Process question_attempts
     */
    protected function process_question_attempt($data) {
        global $DB;

        $data = (object)$data;
        $oldid = $data->id;
        $question = $this->get_mapping('question', $data->questionid);

        $data->questionusageid = $this->get_new_parentid('question_usage');
        $data->questionid      = $question->newitemid;
        $data->timemodified    = $this->apply_date_offset($data->timemodified);

        $newitemid = $DB->insert_record('question_attempts', $data);

        $this->set_mapping('question_attempt', $oldid, $newitemid);
        $this->qtypes[$newitemid] = $question->info->qtype;
        $this->newquestionids[$newitemid] = $data->questionid;
    }

    /**
     * Process question_attempt_steps
     */
    protected function process_question_attempt_step($data) {
        global $DB;

        $data = (object)$data;
        $oldid = $data->id;

        // Pull out the response data.
        $response = array();
        if (!empty($data->response['variable'])) {
            foreach ($data->response['variable'] as $variable) {
                $response[$variable['name']] = $variable['value'];
            }
        }
        unset($data->response);

        $data->questionattemptid = $this->get_new_parentid('question_attempt');
        $data->timecreated = $this->apply_date_offset($data->timecreated);
        $data->userid      = $this->get_mappingid('user', $data->userid);

        // Everything ready, insert and create mapping (needed by question_sessions)
        $newitemid = $DB->insert_record('question_attempt_steps', $data);
        $this->set_mapping('question_attempt_step', $oldid, $newitemid, true);

        // Now process the response data.
        $response = $this->questions_recode_response_data(
                $this->qtypes[$data->questionattemptid],
                $this->newquestionids[$data->questionattemptid],
                $data->sequencenumber, $response);
        foreach ($response as $name => $value) {
            $row = new stdClass();
            $row->attemptstepid = $newitemid;
            $row->name = $name;
            $row->value = $value;
            $DB->insert_record('question_attempt_step_data', $row, false);
        }
    }

    /**
     * Recode the respones data for a particular step of an attempt at at particular question.
     * @param string $qtype the question type.
     * @param int $newquestionid the question id.
     * @param int $sequencenumber the sequence number.
     * @param array $response the response data to recode.
     */
    public function questions_recode_response_data(
            $qtype, $newquestionid, $sequencenumber, array $response) {
        $qtyperestorer = $this->get_qtype_restorer($qtype);
        if ($qtyperestorer) {
            $response = $qtyperestorer->recode_response($newquestionid, $sequencenumber, $response);
        }
        return $response;
    }

    /**
     * Given a list of question->ids, separated by commas, returns the
     * recoded list, with all the restore question mappings applied.
     * Note: Used by quiz->questions and quiz_attempts->layout
     * Note: 0 = page break (unconverted)
     */
    protected function questions_recode_layout($layout) {
        // Extracts question id from sequence
        if ($questionids = explode(',', $layout)) {
            foreach ($questionids as $id => $questionid) {
                if ($questionid) { // If it is zero then this is a pagebreak, don't translate
                    $newquestionid = $this->get_mappingid('question', $questionid);
                    $questionids[$id] = $newquestionid;
                }
            }
        }
        return implode(',', $questionids);
    }

    /**
     * Get the restore_qtype_plugin subclass for a specific question type.
     * @param string $qtype e.g. multichoice.
     * @return restore_qtype_plugin instance.
     */
    protected function get_qtype_restorer($qtype) {
        // Build one static cache to store {@link restore_qtype_plugin}
        // while we are needing them, just to save zillions of instantiations
        // or using static stuff that will break our nice API
        static $qtypeplugins = array();

        if (!isset($qtypeplugins[$qtype])) {
            $classname = 'restore_qtype_' . $qtype . '_plugin';
            if (class_exists($classname)) {
                $qtypeplugins[$qtype] = new $classname('qtype', $qtype, $this);
            } else {
                $qtypeplugins[$qtype] = null;
            }
        }
        return $qtypeplugins[$qtype];
    }

    protected function after_execute() {
        parent::after_execute();

        // Restore any files belonging to responses.
        foreach (question_engine::get_all_response_file_areas() as $filearea) {
            $this->add_related_files('question', $filearea, 'question_attempt_step');
        }
    }

    /**
     * Attach below $element (usually attempts) the needed restore_path_elements
     * to restore question attempt data from Moodle 2.0.
     *
     * When using this method, the parent element ($element) must be defined with
     * $grouped = true. Then, in that elements process method, you must call
     * {@link process_legacy_attempt_data()} with the groupded data. See, for
     * example, the usage of this method in {@link restore_quiz_activity_structure_step}.
     * @param restore_path_element $element the parent element. (E.g. a quiz attempt.)
     * @param array $paths the paths array that is being built to describe the
     *      structure.
     */
    protected function add_legacy_question_attempt_data($element, &$paths) {
        global $CFG;
        require_once($CFG->dirroot . '/question/engine/upgrade/upgradelib.php');

        // Check $element is restore_path_element
        if (!($element instanceof restore_path_element)) {
            throw new restore_step_exception('element_must_be_restore_path_element', $element);
        }
        // Check $paths is one array
        if (!is_array($paths)) {
            throw new restore_step_exception('paths_must_be_array', $paths);
        }

        $paths[] = new restore_path_element('question_state',
                $element->get_path() . '/states/state');
        $paths[] = new restore_path_element('question_session',
                $element->get_path() . '/sessions/session');
    }

    protected function get_attempt_upgrader() {
        if (empty($this->attemptupgrader)) {
            $this->attemptupgrader = new question_engine_attempt_upgrader();
            $this->attemptupgrader->prepare_to_restore();
        }
        return $this->attemptupgrader;
    }

    /**
     * Process the attempt data defined by {@link add_legacy_question_attempt_data()}.
     * @param object $data contains all the grouped attempt data ot process.
     * @param pbject $quiz data about the activity the attempts belong to. Required
     * fields are (basically this only works for the quiz module):
     *      oldquestions => list of question ids in this activity - using old ids.
     *      preferredbehaviour => the behaviour to use for questionattempts.
     */
    protected function process_legacy_quiz_attempt_data($data, $quiz) {
        global $DB;
        $upgrader = $this->get_attempt_upgrader();

        $data = (object)$data;

        $layout = explode(',', $data->layout);
        $newlayout = $layout;

        // Convert each old question_session into a question_attempt.
        $qas = array();
        foreach (explode(',', $quiz->oldquestions) as $questionid) {
            if ($questionid == 0) {
                continue;
            }

            $newquestionid = $this->get_mappingid('question', $questionid);
            if (!$newquestionid) {
                throw new restore_step_exception('questionattemptreferstomissingquestion',
                        $questionid, $questionid);
            }

            $question = $upgrader->load_question($newquestionid, $quiz->id);

            foreach ($layout as $key => $qid) {
                if ($qid == $questionid) {
                    $newlayout[$key] = $newquestionid;
                }
            }

            list($qsession, $qstates) = $this->find_question_session_and_states(
                    $data, $questionid);

            if (empty($qsession) || empty($qstates)) {
                throw new restore_step_exception('questionattemptdatamissing',
                        $questionid, $questionid);
            }

            list($qsession, $qstates) = $this->recode_legacy_response_data(
                    $question, $qsession, $qstates);

            $data->layout = implode(',', $newlayout);
            $qas[$newquestionid] = $upgrader->convert_question_attempt(
                    $quiz, $data, $question, $qsession, $qstates);
        }

        // Now create a new question_usage.
        $usage = new stdClass();
        $usage->component = 'mod_quiz';
        $usage->contextid = $this->get_mappingid('context', $this->task->get_old_contextid());
        $usage->preferredbehaviour = $quiz->preferredbehaviour;
        $usage->id = $DB->insert_record('question_usages', $usage);

        $this->inform_new_usage_id($usage->id);

        $data->uniqueid = $usage->id;
        $upgrader->save_usage($quiz->preferredbehaviour, $data, $qas, $quiz->questions);
    }

    protected function find_question_session_and_states($data, $questionid) {
        $qsession = null;
        foreach ($data->sessions['session'] as $session) {
            if ($session['questionid'] == $questionid) {
                $qsession = (object) $session;
                break;
            }
        }

        $qstates = array();
        foreach ($data->states['state'] as $state) {
            if ($state['question'] == $questionid) {
                // It would be natural to use $state['seq_number'] as the array-key
                // here, but it seems that buggy behaviour in 2.0 and early can
                // mean that that is not unique, so we use id, which is guaranteed
                // to be unique.
                $qstates[$state['id']] = (object) $state;
            }
        }
        ksort($qstates);
        $qstates = array_values($qstates);

        return array($qsession, $qstates);
    }

    /**
     * Recode any ids in the response data
     * @param object $question the question data
     * @param object $qsession the question sessions.
     * @param array $qstates the question states.
     */
    protected function recode_legacy_response_data($question, $qsession, $qstates) {
        $qsession->questionid = $question->id;

        foreach ($qstates as &$state) {
            $state->question = $question->id;
            $state->answer = $this->restore_recode_legacy_answer($state, $question->qtype);
        }

        return array($qsession, $qstates);
    }

    /**
     * Recode the legacy answer field.
     * @param object $state the state to recode the answer of.
     * @param string $qtype the question type.
     */
    public function restore_recode_legacy_answer($state, $qtype) {
        $restorer = $this->get_qtype_restorer($qtype);
        if ($restorer) {
            return $restorer->recode_legacy_state_answer($state);
        } else {
            return $state->answer;
        }
    }
}||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_METHOD_CALL
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR)
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_VAR)
                        (SCALAR)))
                (SCALAR)
                (AST_CONST))))
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)
                        (SCALAR)
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (SCALAR)
                                (AST_PROP
                                    (AST_VAR))))
                        (AST_ARRAY
                            (AST_ARRAY_ELEM
                                (AST_VAR)
                                (SCALAR))))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR)
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_VAR)
                        (SCALAR)))
                (SCALAR)
                (AST_CONST))))
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_UNARY_OP
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_PROP
                                    (AST_VAR))
                                (AST_CONST)))))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_UNARY_OP
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_PROP
                                    (AST_VAR))
                                (AST_CONST)))))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)
                        (AST_VAR)))
                (AST_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_METHOD_CALL
                                (AST_VAR)))
                        (AST_CONST)))))))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_METHOD_CALL
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR)
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_VAR)
                        (SCALAR)))
                (SCALAR)
                (AST_CONST))))
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_UNARY_OP
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_PROP
                                    (AST_VAR))
                                (AST_CONST)))))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR)))))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_UNARY_OP
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_PROP
                                    (AST_VAR))
                                (AST_CONST)))))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)
                        (AST_VAR)))))))