  public function loadUserForSession($session_type, $session_token) {
    $session_kind = self::getSessionKindFromToken($session_token);
    switch ($session_kind) {
      case self::KIND_ANONYMOUS:
        // Don't bother trying to load a user for an anonymous session, since
        // neither the session nor the user exist.
        return null;
      case self::KIND_UNKNOWN:
        // If we don't know what kind of session this is, don't go looking for
        // it.
        return null;
      case self::KIND_USER:
        break;
      case self::KIND_EXTERNAL:
        // TODO: Implement these (T4310).
        return null;
    }

    $session_table = new PhabricatorAuthSession();
    $user_table = new PhabricatorUser();
    $conn_r = $session_table->establishConnection('r');
    $session_key = PhabricatorHash::digest($session_token);

    // NOTE: We're being clever here because this happens on every page load,
    // and by joining we can save a query. This might be getting too clever
    // for its own good, though...

    $info = queryfx_one(
      $conn_r,
      'SELECT
          s.id AS s_id,
          s.sessionExpires AS s_sessionExpires,
          s.sessionStart AS s_sessionStart,
          s.highSecurityUntil AS s_highSecurityUntil,
          s.isPartial AS s_isPartial,
          s.signedLegalpadDocuments as s_signedLegalpadDocuments,
          u.*
        FROM %T u JOIN %T s ON u.phid = s.userPHID
        AND s.type = %s AND s.sessionKey = %s',
      $user_table->getTableName(),
      $session_table->getTableName(),
      $session_type,
      $session_key);

    if (!$info) {
      return null;
    }

    $session_dict = array(
      'userPHID' => $info['phid'],
      'sessionKey' => $session_key,
      'type' => $session_type,
    );
    foreach ($info as $key => $value) {
      if (strncmp($key, 's_', 2) === 0) {
        unset($info[$key]);
        $session_dict[substr($key, 2)] = $value;
      }
    }

    $user = $user_table->loadFromArray($info);
    switch ($session_type) {
      case PhabricatorAuthSession::TYPE_WEB:
        // Explicitly prevent bots and mailing lists from establishing web
        // sessions. It's normally impossible to attach authentication to these
        // accounts, and likewise impossible to generate sessions, but it's
        // technically possible that a session could exist in the database. If
        // one does somehow, refuse to load it.
        if (!$user->canEstablishWebSessions()) {
          return null;
        }
        break;
    }

    $session = id(new PhabricatorAuthSession())->loadFromArray($session_dict);

    $ttl = PhabricatorAuthSession::getSessionTypeTTL($session_type);

    // If more than 20% of the time on this session has been used, refresh the
    // TTL back up to the full duration. The idea here is that sessions are
    // good forever if used regularly, but get GC'd when they fall out of use.

    // NOTE: If we begin rotating session keys when extending sessions, the
    // CSRF code needs to be updated so CSRF tokens survive session rotation.

    if (time() + (0.80 * $ttl) > $session->getSessionExpires()) {
      $unguarded = AphrontWriteGuard::beginScopedUnguardedWrites();
        $conn_w = $session_table->establishConnection('w');
        queryfx(
          $conn_w,
          'UPDATE %T SET sessionExpires = UNIX_TIMESTAMP() + %d WHERE id = %d',
          $session->getTableName(),
          $ttl,
          $session->getID());
      unset($unguarded);
    }

    $user->attachSession($session);
    return $user;
  }


  /**
   * Issue a new session key for a given identity. Phabricator supports
   * different types of sessions (like "web" and "conduit") and each session
   * type may have multiple concurrent sessions (this allows a user to be
   * logged in on multiple browsers at the same time, for instance).
   *
   * Note that this method is transport-agnostic and does not set cookies or
   * issue other types of tokens, it ONLY generates a new session key.
   *
   * You can configure the maximum number of concurrent sessions for various
   * session types in the Phabricator configuration.
   *
   * @param   const     Session type constant (see
   *                    @{class:PhabricatorAuthSession}).
   * @param   phid|null Identity to establish a session for, usually a user
   *                    PHID. With `null`, generates an anonymous session.
   * @param   bool      True to issue a partial session.
   * @return  string    Newly generated session key.
   */
||||||||  public function loadUserForSession($session_type, $session_token) {
    $session_kind = self::getSessionKindFromToken($session_token);
    switch ($session_kind) {
      case self::KIND_ANONYMOUS:
        // Don't bother trying to load a user for an anonymous session, since
        // neither the session nor the user exist.
        return null;
      case self::KIND_UNKNOWN:
        // If we don't know what kind of session this is, don't go looking for
        // it.
        return null;
      case self::KIND_USER:
        break;
      case self::KIND_EXTERNAL:
        // TODO: Implement these (T4310).
        return null;
    }

    $session_table = new PhabricatorAuthSession();
    $user_table = new PhabricatorUser();
    $conn_r = $session_table->establishConnection('r');
    $session_key = PhabricatorHash::digest($session_token);

    $cache_parts = $this->getUserCacheQueryParts($conn_r);
    list($cache_selects, $cache_joins, $cache_map) = $cache_parts;

    $info = queryfx_one(
      $conn_r,
      'SELECT
          s.id AS s_id,
          s.sessionExpires AS s_sessionExpires,
          s.sessionStart AS s_sessionStart,
          s.highSecurityUntil AS s_highSecurityUntil,
          s.isPartial AS s_isPartial,
          s.signedLegalpadDocuments as s_signedLegalpadDocuments,
          u.*
          %Q
        FROM %T u JOIN %T s ON u.phid = s.userPHID
        AND s.type = %s AND s.sessionKey = %s %Q',
      $cache_selects,
      $user_table->getTableName(),
      $session_table->getTableName(),
      $session_type,
      $session_key,
      $cache_joins);

    if (!$info) {
      return null;
    }

    $session_dict = array(
      'userPHID' => $info['phid'],
      'sessionKey' => $session_key,
      'type' => $session_type,
    );

    $cache_raw = array_fill_keys($cache_map, null);
    foreach ($info as $key => $value) {
      if (strncmp($key, 's_', 2) === 0) {
        unset($info[$key]);
        $session_dict[substr($key, 2)] = $value;
        continue;
      }

      if (isset($cache_map[$key])) {
        unset($info[$key]);
        $cache_raw[$cache_map[$key]] = $value;
        continue;
      }
    }

    $user = $user_table->loadFromArray($info);

    $user->attachRawCacheData($cache_raw);

    switch ($session_type) {
      case PhabricatorAuthSession::TYPE_WEB:
        // Explicitly prevent bots and mailing lists from establishing web
        // sessions. It's normally impossible to attach authentication to these
        // accounts, and likewise impossible to generate sessions, but it's
        // technically possible that a session could exist in the database. If
        // one does somehow, refuse to load it.
        if (!$user->canEstablishWebSessions()) {
          return null;
        }
        break;
    }

    $session = id(new PhabricatorAuthSession())->loadFromArray($session_dict);

    $ttl = PhabricatorAuthSession::getSessionTypeTTL($session_type);

    // If more than 20% of the time on this session has been used, refresh the
    // TTL back up to the full duration. The idea here is that sessions are
    // good forever if used regularly, but get GC'd when they fall out of use.

    // NOTE: If we begin rotating session keys when extending sessions, the
    // CSRF code needs to be updated so CSRF tokens survive session rotation.

    if (time() + (0.80 * $ttl) > $session->getSessionExpires()) {
      $unguarded = AphrontWriteGuard::beginScopedUnguardedWrites();
        $conn_w = $session_table->establishConnection('w');
        queryfx(
          $conn_w,
          'UPDATE %T SET sessionExpires = UNIX_TIMESTAMP() + %d WHERE id = %d',
          $session->getTableName(),
          $ttl,
          $session->getID());
      unset($unguarded);
    }

    $user->attachSession($session);
    return $user;
  }


  /**
   * Issue a new session key for a given identity. Phabricator supports
   * different types of sessions (like "web" and "conduit") and each session
   * type may have multiple concurrent sessions (this allows a user to be
   * logged in on multiple browsers at the same time, for instance).
   *
   * Note that this method is transport-agnostic and does not set cookies or
   * issue other types of tokens, it ONLY generates a new session key.
   *
   * You can configure the maximum number of concurrent sessions for various
   * session types in the Phabricator configuration.
   *
   * @param   const     Session type constant (see
   *                    @{class:PhabricatorAuthSession}).
   * @param   phid|null Identity to establish a session for, usually a user
   *                    PHID. With `null`, generates an anonymous session.
   * @param   bool      True to issue a partial session.
   * @return  string    Newly generated session key.
   */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR))))
    (AST_SWITCH
        (AST_VAR)
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_RETURN
                        (AST_CONST))))
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_RETURN
                        (AST_CONST))))
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_BREAK
                        (NULL))))
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_RETURN
                        (AST_CONST))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR)
                (SCALAR)
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_VAR)
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_DIM
                    (AST_VAR)
                    (SCALAR))
                (SCALAR))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (SCALAR))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (SCALAR))))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_CALL
                            (
                                (AST_VAR)
                                (SCALAR)
                                (SCALAR)))
                        (SCALAR))
                    (
                        (AST_UNSET
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR)))
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_VAR)
                                (AST_CALL
                                    (
                                        (AST_VAR)
                                        (SCALAR))))
                            (AST_VAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_SWITCH
        (AST_VAR)
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_IF
                        (AST_IF_ELEM
                            (AST_UNARY_OP
                                (AST_METHOD_CALL
                                    (AST_VAR)))
                            (
                                (AST_RETURN
                                    (AST_CONST)))))
                    (AST_BREAK
                        (NULL))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_CALL
                (
                    (AST_NEW)))
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_CALL)
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_VAR)))
                (AST_METHOD_CALL
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (SCALAR))))
                (AST_CALL
                    (
                        (AST_VAR)
                        (SCALAR)
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR)
                        (AST_METHOD_CALL
                            (AST_VAR))))
                (AST_UNSET
                    (AST_VAR)))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR))))
    (AST_SWITCH
        (AST_VAR)
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_RETURN
                        (AST_CONST))))
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_RETURN
                        (AST_CONST))))
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_BREAK
                        (NULL))))
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_RETURN
                        (AST_CONST))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL)))
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR)
                (SCALAR)
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_VAR)
                (AST_VAR)
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_DIM
                    (AST_VAR)
                    (SCALAR))
                (SCALAR))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (SCALAR))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (SCALAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR)
                (AST_CONST))))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_CALL
                            (
                                (AST_VAR)
                                (SCALAR)
                                (SCALAR)))
                        (SCALAR))
                    (
                        (AST_UNSET
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR)))
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_VAR)
                                (AST_CALL
                                    (
                                        (AST_VAR)
                                        (SCALAR))))
                            (AST_VAR))
                        (AST_CONTINUE
                            (NULL)))))
            (AST_IF
                (AST_IF_ELEM
                    (AST_ISSET
                        (AST_DIM
                            (AST_VAR)
                            (AST_VAR)))
                    (
                        (AST_UNSET
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR)))
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_VAR)
                                (AST_DIM
                                    (AST_VAR)
                                    (AST_VAR)))
                            (AST_VAR))
                        (AST_CONTINUE
                            (NULL)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)))
    (AST_SWITCH
        (AST_VAR)
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (AST_CLASS_CONST
                    (SCALAR))
                (
                    (AST_IF
                        (AST_IF_ELEM
                            (AST_UNARY_OP
                                (AST_METHOD_CALL
                                    (AST_VAR)))
                            (
                                (AST_RETURN
                                    (AST_CONST)))))
                    (AST_BREAK
                        (NULL))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_CALL
                (
                    (AST_NEW)))
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_CALL)
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_VAR)))
                (AST_METHOD_CALL
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (SCALAR))))
                (AST_CALL
                    (
                        (AST_VAR)
                        (SCALAR)
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR)
                        (AST_METHOD_CALL
                            (AST_VAR))))
                (AST_UNSET
                    (AST_VAR)))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)))
    (AST_RETURN
        (AST_VAR)))