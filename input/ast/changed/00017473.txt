	private static function _removeAllButCode( $source )
	{
		$newStr = '';
		$tokens = token_get_all( $source );

		$commentTokens = array( T_COMMENT => true, T_INLINE_HTML => true, );
		if ( defined( 'T_DOC_COMMENT' ) ) {
			$commentTokens[constant( 'T_DOC_COMMENT' )] = true;
		}
		if ( defined( 'T_ML_COMMENT' ) ) {
			$commentTokens[constant( 'T_ML_COMMENT' )] = true;
		}

		$whiteSpaceTokens = array(
			T_WHITESPACE => true, T_CLOSE_TAG => true, T_OPEN_TAG => true, T_OPEN_TAG_WITH_ECHO => true,
		);

		foreach ( $tokens as $token ) {
			if ( is_array( $token ) ) {
				if ( isset( $commentTokens[$token[0]] ) ) continue;

				if ( isset( $whiteSpaceTokens[$token[0]] ) ) {
					$token = "\x07";
				} else {
					$token = $token[1];
				}
			} elseif ( $token === ';' ) {
				$token = "\x07";
			}

			$newStr .= $token;
		}
		return $newStr;
	}
}


if ( !function_exists( 'd' ) ) {
	/**
	 * Alias of Kint::dump()
	 *
	 * @return string
	 */
	function d()
	{
		if ( !Kint::enabled() ) return null;

		$args = func_get_args();
		return call_user_func_array( array( 'Kint', 'dump' ), $args );
	}
}

if ( !function_exists( 'dd' ) ) {
	/**
	 * Alias of Kint::dump()
	 * [!!!] IMPORTANT: execution will halt after call to this function
	 *
	 * @return string
	 */
	function dd()
	{
		if ( !Kint::enabled() ) return;

		$args = func_get_args();
		call_user_func_array( array( 'Kint', 'dump' ), $args );
		die;
	}
}

if ( !function_exists( 's' ) ) {

	/**
	 * Alias of kintLite()
	 *
	 * @return string
	 */
	function s()
	{
		if ( !Kint::enabled() ) return;

		$argv = func_get_args();
		echo '<pre>';
		foreach ( $argv as $k => $v ) {
			$k && print( "\n\n" );
			echo kintLite( $v );
		}
		echo '</pre>';
	}

	/**
	 * Alias of kintLite()
	 * [!!!] IMPORTANT: execution will halt after call to this function
	 *
	 * @return string
	 */
	function sd()
	{
		if ( !Kint::enabled() ) return;

		echo '<pre>';
		foreach ( func_get_args() as $k => $v ) {
			$k && print( "\n\n" );
			echo kintLite( $v );
		}
		echo '</pre>';
		die;

	}

}


/**
 * lightweight version of Kint::dump(). Uses whitespace for formatting instead of html
 * sadly not DRY yet
 *
 * @param     $var
 * @param int $level
 *
 * @return string
 */
function kintLite( &$var, $level = 0 )
{

	// initialize function names into variables for prettier string output (html and implode are also DRY)
	$html     = "htmlspecialchars";
	$implode  = "implode";
	$strlen   = "strlen";
	$count    = "count";
	$getClass = "get_class";


	if ( $var === null ) {
		return 'NULL';
	} elseif ( is_bool( $var ) ) {
		return 'bool ' . ( $var ? 'TRUE' : 'FALSE' );
	} elseif ( is_float( $var ) ) {
		return 'float ' . $var;
	} elseif ( is_int( $var ) ) {
		return 'integer ' . $var;
	} elseif ( is_resource( $var ) ) {
		if ( ( $type = get_resource_type( $var ) ) === 'stream' AND $meta = stream_get_meta_data( $var ) ) {

			if ( isset( $meta['uri'] ) ) {
				$file = $meta['uri'];

				return "resource ({$type}) {$html( $file, 0 )}";
			} else {
				return "resource ({$type})";
			}
		} else {
			return "resource ({$type})";
		}
	} elseif ( is_string( $var ) ) {
		return "string ({$strlen( $var )}) \"{$html( $var )}\"";
	} elseif ( is_array( $var ) ) {
		$output = array();
		$space  = str_repeat( $s = '    ', $level );

		static $marker;

		if ( $marker === null ) {
			// Make a unique marker
			$marker = uniqid( "\x00" );
		}

		if ( empty( $var ) ) {
			return "array()";
		} elseif ( isset( $var[$marker] ) ) {
			$output[] = "[\n$space$s*RECURSION*\n$space]";
		} elseif ( $level < 7 ) {
			$isSeq = array_keys( $var ) === range( 0, count( $var ) - 1 );

			$output[] = "[";

			$var[$marker] = true;


			foreach ( $var as $key => &$val ) {
				if ( $key === $marker ) continue;

				$key = $space . $s . ( $isSeq ? "" : "'{$html( $key, 0 )}' => " );

				$dump     = kintLite( $val, $level + 1 );
				$output[] = "{$key}{$dump}";
			}

			unset( $var[$marker] );
			$output[] = "$space]";

		} else {
			$output[] = "[\n$space$s*depth too great*\n$space]";
		}
		return "array({$count( $var )}) {$implode( "\n", $output )}";
	} elseif ( is_object( $var ) ) {
		if ( $var instanceof SplFileInfo ) {
			return "object SplFileInfo " . $var->getRealPath();
		}

		// Copy the object as an array
		$array = (array)$var;

		$output = array();
		$space  = str_repeat( $s = '    ', $level );

		$hash = spl_object_hash( $var );

		// Objects that are being dumped
		static $objects = array();

		if ( empty( $array ) ) {
			return "object {$getClass( $var )} {}";
		} elseif ( isset( $objects[$hash] ) ) {
			$output[] = "{\n$space$s*RECURSION*\n$space}";
		} elseif ( $level < 7 ) {
			$output[]       = "{";
			$objects[$hash] = true;

			foreach ( $array as $key => & $val ) {
				if ( $key[0] === "\x00" ) {

					$access = $key[1] === "*" ? "protected" : "private";

					// Remove the access level from the variable name
					$key = substr( $key, strrpos( $key, "\x00" ) + 1 );
				} else {
					$access = "public";
				}

				$output[] = "$space$s$access $key -> " . kintLite( $val, $level + 1 );
			}
			unset( $objects[$hash] );
			$output[] = "$space}";

		} else {
			$output[] = "{\n$space$s*depth too great*\n$space}";
		}

		return "object {$getClass( $var )} ({$count( $array )}) {$implode( "\n", $output )}";
	} else {
		return gettype( $var ) . htmlspecialchars( var_export( $var, true ), ENT_NOQUOTES );
	}
}

Kint::_init();||||||||	private static function _removeAllButCode( $source )
	{
		$newStr        = '';
		$tokens        = token_get_all( $source );
		$commentTokens = array( T_COMMENT => true, T_INLINE_HTML => true, );
		if ( defined( 'T_DOC_COMMENT' ) ) {
			$commentTokens[constant( 'T_DOC_COMMENT' )] = true;
		}
		if ( defined( 'T_ML_COMMENT' ) ) {
			$commentTokens[constant( 'T_ML_COMMENT' )] = true;
		}

		$whiteSpaceTokens = array(
			T_WHITESPACE => true, T_CLOSE_TAG => true, T_OPEN_TAG => true, T_OPEN_TAG_WITH_ECHO => true,
		);

		foreach ( $tokens as $token ) {
			if ( is_array( $token ) ) {
				if ( isset( $commentTokens[$token[0]] ) ) continue;

				if ( $token[0] === T_NEW ) {
					$token = 'new ';
				} elseif ( isset( $whiteSpaceTokens[$token[0]] ) ) {
					$token = "\x07";
				} else {
					$token = $token[1];
				}
			} elseif ( $token === ';' ) {
				$token = "\x07";
			}

			$newStr .= $token;
		}
		return $newStr;
	}
}


if ( !function_exists( 'd' ) ) {
	/**
	 * Alias of Kint::dump()
	 *
	 * @return string
	 */
	function d()
	{
		if ( !Kint::enabled() ) return null;

		$args = func_get_args();
		return call_user_func_array( array( 'Kint', 'dump' ), $args );
	}
}

if ( !function_exists( 'dd' ) ) {
	/**
	 * Alias of Kint::dump()
	 * [!!!] IMPORTANT: execution will halt after call to this function
	 *
	 * @return string
	 */
	function dd()
	{
		if ( !Kint::enabled() ) return;

		$args = func_get_args();
		call_user_func_array( array( 'Kint', 'dump' ), $args );
		die;
	}
}

if ( !function_exists( 's' ) ) {

	/**
	 * Alias of kintLite()
	 *
	 * @return string
	 */
	function s()
	{
		if ( !Kint::enabled() ) return;

		$argv = func_get_args();
		echo '<pre>';
		foreach ( $argv as $k => $v ) {
			$k && print( "\n\n" );
			echo kintLite( $v );
		}
		echo '</pre>';
	}

	/**
	 * Alias of kintLite()
	 * [!!!] IMPORTANT: execution will halt after call to this function
	 *
	 * @return string
	 */
	function sd()
	{
		if ( !Kint::enabled() ) return;

		echo '<pre>';
		foreach ( func_get_args() as $k => $v ) {
			$k && print( "\n\n" );
			echo kintLite( $v );
		}
		echo '</pre>';
		die;

	}

}


/**
 * lightweight version of Kint::dump(). Uses whitespace for formatting instead of html
 * sadly not DRY yet
 *
 * @param     $var
 * @param int $level
 *
 * @return string
 */
function kintLite( &$var, $level = 0 )
{

	// initialize function names into variables for prettier string output (html and implode are also DRY)
	$html     = "htmlspecialchars";
	$implode  = "implode";
	$strlen   = "strlen";
	$count    = "count";
	$getClass = "get_class";


	if ( $var === null ) {
		return 'NULL';
	} elseif ( is_bool( $var ) ) {
		return 'bool ' . ( $var ? 'TRUE' : 'FALSE' );
	} elseif ( is_float( $var ) ) {
		return 'float ' . $var;
	} elseif ( is_int( $var ) ) {
		return 'integer ' . $var;
	} elseif ( is_resource( $var ) ) {
		if ( ( $type = get_resource_type( $var ) ) === 'stream' AND $meta = stream_get_meta_data( $var ) ) {

			if ( isset( $meta['uri'] ) ) {
				$file = $meta['uri'];

				return "resource ({$type}) {$html( $file, 0 )}";
			} else {
				return "resource ({$type})";
			}
		} else {
			return "resource ({$type})";
		}
	} elseif ( is_string( $var ) ) {
		return "string ({$strlen( $var )}) \"{$html( $var )}\"";
	} elseif ( is_array( $var ) ) {
		$output = array();
		$space  = str_repeat( $s = '    ', $level );

		static $marker;

		if ( $marker === null ) {
			// Make a unique marker
			$marker = uniqid( "\x00" );
		}

		if ( empty( $var ) ) {
			return "array()";
		} elseif ( isset( $var[$marker] ) ) {
			$output[] = "[\n$space$s*RECURSION*\n$space]";
		} elseif ( $level < 7 ) {
			$isSeq = array_keys( $var ) === range( 0, count( $var ) - 1 );

			$output[] = "[";

			$var[$marker] = true;


			foreach ( $var as $key => &$val ) {
				if ( $key === $marker ) continue;

				$key = $space . $s . ( $isSeq ? "" : "'{$html( $key, 0 )}' => " );

				$dump     = kintLite( $val, $level + 1 );
				$output[] = "{$key}{$dump}";
			}

			unset( $var[$marker] );
			$output[] = "$space]";

		} else {
			$output[] = "[\n$space$s*depth too great*\n$space]";
		}
		return "array({$count( $var )}) {$implode( "\n", $output )}";
	} elseif ( is_object( $var ) ) {
		if ( $var instanceof SplFileInfo ) {
			return "object SplFileInfo " . $var->getRealPath();
		}

		// Copy the object as an array
		$array = (array)$var;

		$output = array();
		$space  = str_repeat( $s = '    ', $level );

		$hash = spl_object_hash( $var );

		// Objects that are being dumped
		static $objects = array();

		if ( empty( $array ) ) {
			return "object {$getClass( $var )} {}";
		} elseif ( isset( $objects[$hash] ) ) {
			$output[] = "{\n$space$s*RECURSION*\n$space}";
		} elseif ( $level < 7 ) {
			$output[]       = "{";
			$objects[$hash] = true;

			foreach ( $array as $key => & $val ) {
				if ( $key[0] === "\x00" ) {

					$access = $key[1] === "*" ? "protected" : "private";

					// Remove the access level from the variable name
					$key = substr( $key, strrpos( $key, "\x00" ) + 1 );
				} else {
					$access = "public";
				}

				$output[] = "$space$s$access $key -> " . kintLite( $val, $level + 1 );
			}
			unset( $objects[$hash] );
			$output[] = "$space}";

		} else {
			$output[] = "{\n$space$s*depth too great*\n$space}";
		}

		return "object {$getClass( $var )} ({$count( $array )}) {$implode( "\n", $output )}";
	} else {
		return gettype( $var ) . htmlspecialchars( var_export( $var, true ), ENT_NOQUOTES );
	}
}

Kint::_init();||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (SCALAR)))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (AST_CALL
                            (
                                (SCALAR))))
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (SCALAR)))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (AST_CALL
                            (
                                (SCALAR))))
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (NULL)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_CALL
                        (
                            (AST_VAR)))
                    (
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_ISSET
                                    (AST_DIM
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))
                                (
                                    (AST_CONTINUE
                                        (NULL)))))
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_ISSET
                                    (AST_DIM
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (SCALAR))))
                            (AST_IF_ELEM
                                (NULL)
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))))))
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR))
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (SCALAR)))))
            (AST_ASSIGN_OP
                (AST_VAR)
                (AST_VAR))))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (SCALAR)))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (AST_CALL
                            (
                                (SCALAR))))
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (SCALAR)))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (AST_CALL
                            (
                                (SCALAR))))
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))
            (AST_ARRAY_ELEM
                (AST_CONST)
                (AST_CONST))))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (NULL)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_CALL
                        (
                            (AST_VAR)))
                    (
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_ISSET
                                    (AST_DIM
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))
                                (
                                    (AST_CONTINUE
                                        (NULL)))))
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_BINARY_OP
                                    (AST_DIM
                                        (AST_VAR)
                                        (SCALAR))
                                    (AST_CONST))
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (SCALAR))))
                            (AST_IF_ELEM
                                (AST_ISSET
                                    (AST_DIM
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (SCALAR))))
                            (AST_IF_ELEM
                                (NULL)
                                (
                                    (AST_ASSIGN
                                        (AST_VAR)
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))))))))
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR))
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (SCALAR)))))
            (AST_ASSIGN_OP
                (AST_VAR)
                (AST_VAR))))
    (AST_RETURN
        (AST_VAR)))