    protected function convert_child($child, $depth=1) {
        global $OUTPUT;

        if (!$child->display) {
            return '';
        }
        $attributes = array();
        $attributes['id'] = $child->id;
        $attributes['type'] = $child->type;
        $attributes['key'] = $child->key;
        $attributes['icon'] = $child->icon;
        $attributes['class'] = $child->get_css_type();
        if ($child->forcetitle || $child->title !== $child->text) {
            $attributes['title'] = htmlentities($child->title);
        }
        if (array_key_exists((string)$child->key, $this->expandable)) {
            $attributes['expandable'] = $child->key;
            $child->add_class($this->expandable[$child->key]['id']);
        } else if ($child->type >= $this->expansionceiling) {
            $attributes['expansionceiling'] = $child->key;
        }

        if (count($child->classes)>0) {
            $attributes['class'] .= ' '.join(' ',$child->classes);
        }
        if (is_string($child->action)) {
            $attributes['link'] = $child->action;
        } else if ($child->action instanceof moodle_url) {
            $attributes['link'] = $child->action->out();
        }
        $attributes['hidden'] = ($child->hidden);
        $attributes['haschildren'] = (count($child->children)>0 || $child->type == navigation_node::TYPE_CATEGORY);

        $xml = '<'.$this->nodetype[$child->nodetype];
        if (count($attributes)>0) {
            foreach ($attributes as $key=>$value) {
                if (is_bool($value)) {
                    if ($value) {
                        $xml .= ' '.$key.'="true"';
                    } else {
                        $xml .= ' '.$key.'="false"';
                    }
                } else if ($value instanceof pix_icon) {
                    $xml .= ' '.$key.'="'.$OUTPUT->pix_url($value->pix, $value->component).'"';
                } else if ($value !== null) {
                    $xml .= ' '.$key.'="'.$value.'"';
                }
            }
        }
        $xml .= '>';
        $xml .= '<name>'.htmlentities($child->text).'</name>';
        if (count($child->children)>0) {
            $xml .= '<children>';
            foreach ($child->children as $subchild) {
                $xml .= $this->convert_child($subchild, $depth+1);
            }
            $xml .= '</children>';
        }
        $xml .= '</'.$this->nodetype[$child->nodetype].'>';
        return $xml;
    }
}

/**
 * The cache class used by global navigation and settings navigation to cache bits
 * and bobs that are used during their generation.
 *
 * It is basically an easy access point to session with a bit of smarts to make
 * sure that the information that is cached is valid still.
 *
 * Example use:
 * <code php>
 * if (!$cache->viewdiscussion()) {
 *     // Code to do stuff and produce cachable content
 *     $cache->viewdiscussion = has_capability('mod/forum:viewdiscussion', $coursecontext);
 * }
 * $content = $cache->viewdiscussion;
 * </code>
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navigation_cache {
    /** @var int */
    protected $creation;
    /** @var array */
    protected $session;
    /** @var string */
    protected $area;
    /** @var int */
    protected $timeout;
    /** @var stdClass */
    protected $currentcontext;
    /** @var int */
    const CACHETIME = 0;
    /** @var int */
    const CACHEUSERID = 1;
    /** @var int */
    const CACHEVALUE = 2;
    /** @var null|array An array of navigation cache areas to expire on shutdown */
    public static $volatilecaches;

    /**
     * Contructor for the cache. Requires two arguments
     *
     * @param string $area The string to use to segregate this particular cache
     *                it can either be unique to start a fresh cache or if you want
     *                to share a cache then make it the string used in the original
     *                cache
     * @param int $timeout The number of seconds to time the information out after
     */
    public function __construct($area, $timeout=60) {
        global $SESSION, $PAGE;
        $this->creation = time();
        $this->area = $area;

        if (!isset($SESSION->navcache)) {
            $SESSION->navcache = new stdClass;
        }

        if (!isset($SESSION->navcache->{$area})) {
            $SESSION->navcache->{$area} = array();
        }
        $this->session = &$SESSION->navcache->{$area};
        $this->timeout = time()-$timeout;
        if (rand(0,10)===0) {
            $this->garbage_collection();
        }
    }

    /**
     * Magic Method to retrieve something by simply calling using = cache->key
     *
     * @param mixed $key The identifier for the information you want out again
     * @return void|mixed Either void or what ever was put in
     */
    public function __get($key) {
        if (!$this->cached($key)) {
            return;
        }
        $information = $this->session[$key][self::CACHEVALUE];
        return unserialize($information);
    }

    /**
     * Magic method that simply uses {@link set();} to store something in the cache
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function __set($key, $information) {
        $this->set($key, $information);
    }

    /**
     * Sets some information against the cache (session) for later retrieval
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function set($key, $information) {
        global $USER;
        $information = serialize($information);
        $this->session[$key]= array(self::CACHETIME=>time(), self::CACHEUSERID=>$USER->id, self::CACHEVALUE=>$information);
    }
    /**
     * Check the existence of the identifier in the cache
     *
     * @param string|int $key
     * @return bool
     */
    public function cached($key) {
        global $USER;
        if (!array_key_exists($key, $this->session) || !is_array($this->session[$key]) || $this->session[$key][self::CACHEUSERID]!=$USER->id || $this->session[$key][self::CACHETIME] < $this->timeout) {
            return false;
        }
        return true;
    }
    /**
     * Compare something to it's equivilant in the cache
     *
     * @param string $key
     * @param mixed $value
     * @param bool $serialise Whether to serialise the value before comparison
     *              this should only be set to false if the value is already
     *              serialised
     * @return bool If the value is the same false if it is not set or doesn't match
     */
    public function compare($key, $value, $serialise=true) {
        if ($this->cached($key)) {
            if ($serialise) {
                $value = serialize($value);
            }
            if ($this->session[$key][self::CACHEVALUE] === $value) {
                return true;
            }
        }
        return false;
    }
    /**
     * Wipes the entire cache, good to force regeneration
     */
    public function clear() {
        $this->session = array();
    }
    /**
     * Checks all cache entries and removes any that have expired, good ole cleanup
     */
    protected function garbage_collection() {
        foreach ($this->session as $key=>$cachedinfo) {
            if (is_array($cachedinfo) && $cachedinfo[self::CACHETIME]<$this->timeout) {
                unset($this->session[$key]);
            }
        }
    }

    /**
     * Marks the cache as being volatile (likely to change)
     *
     * Any caches marked as volatile will be destroyed at the on shutdown by
     * {@link navigation_node::destroy_volatile_caches()} which is registered
     * as a shutdown function if any caches are marked as volatile.
     *
     * @param bool $setting True to destroy the cache false not too
     */
    public function volatile($setting = true) {
        if (self::$volatilecaches===null) {
            self::$volatilecaches = array();
            register_shutdown_function(array('navigation_cache','destroy_volatile_caches'));
        }

        if ($setting) {
            self::$volatilecaches[$this->area] = $this->area;
        } else if (array_key_exists($this->area, self::$volatilecaches)) {
            unset(self::$volatilecaches[$this->area]);
        }
    }

    /**
     * Destroys all caches marked as volatile
     *
     * This function is static and works in conjunction with the static volatilecaches
     * property of navigation cache.
     * Because this function is static it manually resets the cached areas back to an
     * empty array.
     */
    public static function destroy_volatile_caches() {
        global $SESSION;
        if (is_array(self::$volatilecaches) && count(self::$volatilecaches)>0) {
            foreach (self::$volatilecaches as $area) {
                $SESSION->navcache->{$area} = array();
            }
        }
    }
}||||||||    protected function convert_child($child, $depth=1) {
        global $OUTPUT;

        if (!$child->display) {
            return '';
        }
        $attributes = array();
        $attributes['id'] = $child->id;
        $attributes['name'] = $child->text;
        $attributes['type'] = $child->type;
        $attributes['key'] = $child->key;
        $attributes['icon'] = $child->icon;
        $attributes['class'] = $child->get_css_type();
        if ($child->forcetitle || $child->title !== $child->text) {
            $attributes['title'] = htmlentities($child->title);
        }
        if (array_key_exists((string)$child->key, $this->expandable)) {
            $attributes['expandable'] = $child->key;
            $child->add_class($this->expandable[$child->key]['id']);
        } else if ($child->type >= $this->expansionceiling) {
            $attributes['expansionceiling'] = $child->key;
        }

        if (count($child->classes)>0) {
            $attributes['class'] .= ' '.join(' ',$child->classes);
        }
        if (is_string($child->action)) {
            $attributes['link'] = $child->action;
        } else if ($child->action instanceof moodle_url) {
            $attributes['link'] = $child->action->out();
        }
        $attributes['hidden'] = ($child->hidden);
        $attributes['haschildren'] = (count($child->children)>0 || $child->type == navigation_node::TYPE_CATEGORY);

        if ($attributes['icon'] instanceof pix_icon) {
            $attributes['icon'] = $OUTPUT->pix_url($attributes['icon']->pix, $attributes['icon']->component);
        }

        if (count($child->children)>0) {
            $attributes['children'] = array();
            foreach ($child->children as $subchild) {
                $attributes['children'][] = $this->convert_child($subchild, $depth+1);
            }
        }

        if ($depth > 1) {
            return $attributes;
        } else {
            return json_encode($attributes);
        }
    }
}

/**
 * The cache class used by global navigation and settings navigation to cache bits
 * and bobs that are used during their generation.
 *
 * It is basically an easy access point to session with a bit of smarts to make
 * sure that the information that is cached is valid still.
 *
 * Example use:
 * <code php>
 * if (!$cache->viewdiscussion()) {
 *     // Code to do stuff and produce cachable content
 *     $cache->viewdiscussion = has_capability('mod/forum:viewdiscussion', $coursecontext);
 * }
 * $content = $cache->viewdiscussion;
 * </code>
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navigation_cache {
    /** @var int */
    protected $creation;
    /** @var array */
    protected $session;
    /** @var string */
    protected $area;
    /** @var int */
    protected $timeout;
    /** @var stdClass */
    protected $currentcontext;
    /** @var int */
    const CACHETIME = 0;
    /** @var int */
    const CACHEUSERID = 1;
    /** @var int */
    const CACHEVALUE = 2;
    /** @var null|array An array of navigation cache areas to expire on shutdown */
    public static $volatilecaches;

    /**
     * Contructor for the cache. Requires two arguments
     *
     * @param string $area The string to use to segregate this particular cache
     *                it can either be unique to start a fresh cache or if you want
     *                to share a cache then make it the string used in the original
     *                cache
     * @param int $timeout The number of seconds to time the information out after
     */
    public function __construct($area, $timeout=60) {
        global $SESSION;
        $this->creation = time();
        $this->area = $area;

        if (!isset($SESSION->navcache)) {
            $SESSION->navcache = new stdClass;
        }

        if (!isset($SESSION->navcache->{$area})) {
            $SESSION->navcache->{$area} = array();
        }
        $this->session = &$SESSION->navcache->{$area};
        $this->timeout = time()-$timeout;
        if (rand(0,10)===0) {
            $this->garbage_collection();
        }
    }

    /**
     * Magic Method to retrieve something by simply calling using = cache->key
     *
     * @param mixed $key The identifier for the information you want out again
     * @return void|mixed Either void or what ever was put in
     */
    public function __get($key) {
        if (!$this->cached($key)) {
            return;
        }
        $information = $this->session[$key][self::CACHEVALUE];
        return unserialize($information);
    }

    /**
     * Magic method that simply uses {@link set();} to store something in the cache
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function __set($key, $information) {
        $this->set($key, $information);
    }

    /**
     * Sets some information against the cache (session) for later retrieval
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function set($key, $information) {
        global $USER;
        $information = serialize($information);
        $this->session[$key]= array(self::CACHETIME=>time(), self::CACHEUSERID=>$USER->id, self::CACHEVALUE=>$information);
    }
    /**
     * Check the existence of the identifier in the cache
     *
     * @param string|int $key
     * @return bool
     */
    public function cached($key) {
        global $USER;
        if (!array_key_exists($key, $this->session) || !is_array($this->session[$key]) || $this->session[$key][self::CACHEUSERID]!=$USER->id || $this->session[$key][self::CACHETIME] < $this->timeout) {
            return false;
        }
        return true;
    }
    /**
     * Compare something to it's equivilant in the cache
     *
     * @param string $key
     * @param mixed $value
     * @param bool $serialise Whether to serialise the value before comparison
     *              this should only be set to false if the value is already
     *              serialised
     * @return bool If the value is the same false if it is not set or doesn't match
     */
    public function compare($key, $value, $serialise=true) {
        if ($this->cached($key)) {
            if ($serialise) {
                $value = serialize($value);
            }
            if ($this->session[$key][self::CACHEVALUE] === $value) {
                return true;
            }
        }
        return false;
    }
    /**
     * Wipes the entire cache, good to force regeneration
     */
    public function clear() {
        $this->session = array();
    }
    /**
     * Checks all cache entries and removes any that have expired, good ole cleanup
     */
    protected function garbage_collection() {
        foreach ($this->session as $key=>$cachedinfo) {
            if (is_array($cachedinfo) && $cachedinfo[self::CACHETIME]<$this->timeout) {
                unset($this->session[$key]);
            }
        }
    }

    /**
     * Marks the cache as being volatile (likely to change)
     *
     * Any caches marked as volatile will be destroyed at the on shutdown by
     * {@link navigation_node::destroy_volatile_caches()} which is registered
     * as a shutdown function if any caches are marked as volatile.
     *
     * @param bool $setting True to destroy the cache false not too
     */
    public function volatile($setting = true) {
        if (self::$volatilecaches===null) {
            self::$volatilecaches = array();
            register_shutdown_function(array('navigation_cache','destroy_volatile_caches'));
        }

        if ($setting) {
            self::$volatilecaches[$this->area] = $this->area;
        } else if (array_key_exists($this->area, self::$volatilecaches)) {
            unset(self::$volatilecaches[$this->area]);
        }
    }

    /**
     * Destroys all caches marked as volatile
     *
     * This function is static and works in conjunction with the static volatilecaches
     * property of navigation cache.
     * Because this function is static it manually resets the cached areas back to an
     * empty array.
     */
    public static function destroy_volatile_caches() {
        global $SESSION;
        if (is_array(self::$volatilecaches) && count(self::$volatilecaches)>0) {
            foreach (self::$volatilecaches as $area) {
                $SESSION->navcache->{$area} = array();
            }
        }
    }
}||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_PROP
                    (AST_VAR)))
            (
                (AST_RETURN
                    (SCALAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (AST_BINARY_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_CALL
                        (
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_CAST
                        (AST_PROP
                            (AST_VAR)))
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_PROP
                        (AST_VAR)))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_DIM
                            (AST_DIM
                                (AST_PROP
                                    (AST_VAR))
                                (AST_PROP
                                    (AST_VAR)))
                            (SCALAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_BINARY_OP
                            (AST_PROP
                                (AST_VAR))
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR))
                                (AST_PROP
                                    (AST_VAR)))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))))
                (SCALAR))
            (
                (AST_ASSIGN_OP
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_CALL
                            (
                                (SCALAR)
                                (AST_PROP
                                    (AST_VAR)))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_PROP
                        (AST_VAR)))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_INSTANCEOF
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR))
                                (AST_METHOD_CALL
                                    (AST_PROP
                                        (AST_VAR))))))))))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))))
                (SCALAR))
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (AST_CLASS_CONST
                    (SCALAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (SCALAR)
            (AST_DIM
                (AST_PROP
                    (AST_VAR))
                (AST_PROP
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_VAR)))
                (SCALAR))
            (
                (AST_FOREACH
                    (AST_VAR)
                    (AST_VAR)
                    (AST_VAR)
                    (
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_CALL
                                    (
                                        (AST_VAR)))
                                (
                                    (AST_IF
                                        (AST_IF_ELEM
                                            (AST_VAR)
                                            (
                                                (AST_ASSIGN_OP
                                                    (AST_VAR)
                                                    (AST_BINARY_OP
                                                        (AST_BINARY_OP
                                                            (SCALAR)
                                                            (AST_VAR))
                                                        (SCALAR)))))
                                        (AST_IF_ELEM
                                            (NULL)
                                            (
                                                (AST_ASSIGN_OP
                                                    (AST_VAR)
                                                    (AST_BINARY_OP
                                                        (AST_BINARY_OP
                                                            (SCALAR)
                                                            (AST_VAR))
                                                        (SCALAR))))))))
                            (AST_IF_ELEM
                                (NULL)
                                (
                                    (AST_IF
                                        (AST_IF_ELEM
                                            (AST_INSTANCEOF
                                                (AST_VAR))
                                            (
                                                (AST_ASSIGN_OP
                                                    (AST_VAR)
                                                    (AST_BINARY_OP
                                                        (AST_BINARY_OP
                                                            (AST_BINARY_OP
                                                                (AST_BINARY_OP
                                                                    (SCALAR)
                                                                    (AST_VAR))
                                                                (SCALAR))
                                                            (AST_METHOD_CALL
                                                                (AST_VAR)
                                                                (
                                                                    (AST_PROP
                                                                        (AST_VAR))
                                                                    (AST_PROP
                                                                        (AST_VAR)))))
                                                        (SCALAR)))))
                                        (AST_IF_ELEM
                                            (NULL)
                                            (
                                                (AST_IF
                                                    (AST_IF_ELEM
                                                        (AST_BINARY_OP
                                                            (AST_VAR)
                                                            (AST_CONST))
                                                        (
                                                            (AST_ASSIGN_OP
                                                                (AST_VAR)
                                                                (AST_BINARY_OP
                                                                    (AST_BINARY_OP
                                                                        (AST_BINARY_OP
                                                                            (AST_BINARY_OP
                                                                                (SCALAR)
                                                                                (AST_VAR))
                                                                            (SCALAR))
                                                                        (AST_VAR))
                                                                    (SCALAR)))))))))))))))))
    (AST_ASSIGN_OP
        (AST_VAR)
        (SCALAR))
    (AST_ASSIGN_OP
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (SCALAR)
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR)))))
            (SCALAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))))
                (SCALAR))
            (
                (AST_ASSIGN_OP
                    (AST_VAR)
                    (SCALAR))
                (AST_FOREACH
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)
                    (NULL)
                    (
                        (AST_ASSIGN_OP
                            (AST_VAR)
                            (AST_METHOD_CALL
                                (AST_VAR)
                                (
                                    (AST_VAR)
                                    (AST_BINARY_OP
                                        (AST_VAR)
                                        (SCALAR)))))))
                (AST_ASSIGN_OP
                    (AST_VAR)
                    (SCALAR)))))
    (AST_ASSIGN_OP
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (SCALAR)
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_PROP
                        (AST_VAR))))
            (SCALAR)))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_PROP
                    (AST_VAR)))
            (
                (AST_RETURN
                    (SCALAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (AST_BINARY_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_CALL
                        (
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_CAST
                        (AST_PROP
                            (AST_VAR)))
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_PROP
                        (AST_VAR)))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_DIM
                            (AST_DIM
                                (AST_PROP
                                    (AST_VAR))
                                (AST_PROP
                                    (AST_VAR)))
                            (SCALAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_BINARY_OP
                            (AST_PROP
                                (AST_VAR))
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR))
                                (AST_PROP
                                    (AST_VAR)))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))))
                (SCALAR))
            (
                (AST_ASSIGN_OP
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_CALL
                            (
                                (SCALAR)
                                (AST_PROP
                                    (AST_VAR)))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_PROP
                        (AST_VAR)))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_INSTANCEOF
                            (AST_PROP
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR))
                                (AST_METHOD_CALL
                                    (AST_PROP
                                        (AST_VAR))))))))))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))))
                (SCALAR))
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (AST_CLASS_CONST
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_INSTANCEOF
                (AST_DIM
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_PROP
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR)))
                            (AST_PROP
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR)))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))))
                (SCALAR))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))
                    (AST_ARRAY))
                (AST_FOREACH
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)
                    (NULL)
                    (
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_DIM
                                    (AST_VAR)
                                    (SCALAR))
                                (NULL))
                            (AST_METHOD_CALL
                                (AST_VAR)
                                (
                                    (AST_VAR)
                                    (AST_BINARY_OP
                                        (AST_VAR)
                                        (SCALAR))))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (
                (AST_RETURN
                    (AST_VAR))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_RETURN
                    (AST_CALL
                        (
                            (AST_VAR))))))))