 namespace TokenReflection;use RuntimeException;abstract class ReflectionFunctionBase extends ReflectionBase implements IReflectionFunctionBase{protected$modifiers=0;private$staticVariables=array();protected$namespaceName;private$returnsReference=false;private$parameters=array();public function getModifiers(){return$this->modifiers;}public function inNamespace(){return null !==$this->getNamespaceName();}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function getNumberOfParameters(){return count($this->parameters);}public function getNumberOfRequiredParameters(){$count=0;array_walk($this->parameters,function(ReflectionParameter$parameter)use(&$count){if(!$parameter->isOptional()){$count++;}});return$count;}public function getParameters(){return$this->parameters;}public function getParameter($parameter){if(is_numeric($parameter)){if(isset($this->parameters[$parameter])){return$this->parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($this->parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getStaticVariables(){return$this->staticVariables;}public function isClosure(){return false;}public function returnsReference(){return$this->returnsReference;}public function getName(){if(null !==$this->namespaceName &&ReflectionNamespace::NO_NAMESPACE_NAME !==$this->namespaceName){return$this->namespaceName.'\\'.$this->name;}return$this->name;}public function getShortName(){return$this->name;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw new RuntimeException('Could not determine the method/function name');}$this->name=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();return$this;}final protected function parseChildren(Stream$tokenStream){return$this ->parseParameters($tokenStream)->parseStaticVariables($tokenStream);}final protected function parseParameters(Stream$tokenStream){if(!$tokenStream->is('(')){throw new RuntimeException('Could not determine parameters start');}$tokenStream->skipWhitespaces();while(null !==($type=$tokenStream->getType())&&')' !==$type){if(T_VARIABLE ===$type){$parameter=new ReflectionParameter($tokenStream->getParameterStream(),$this->getBroker(),$this);$this->parameters[]=$parameter;}if($tokenStream->is(')')){break;}else{$tokenStream->skipWhitespaces();}}return$this;}final protected function parseStaticVariables(Stream$tokenStream){return$this;}final protected function parseReturnsReference(Stream$tokenStream){if(!$tokenStream->is(T_FUNCTION)){throw new RuntimeException('Could not find the function keyword.');}$tokenStream->skipWhitespaces();$type=$tokenStream->getType();if('&' ===$type){$this->returnsReference=true;$tokenStream->skipWhitespaces();}elseif(!T_STRING ===$type){throw new RuntimeException(sprintf('Unexpected token type: %s',$tokenStream->getTokenName()));}return$this;}}
 namespace TokenReflection;use RuntimeException;class ReflectionNamespace implements IReflectionNamespace{const NO_NAMESPACE_NAME='no-namespace';private$broker;private$name;private$classes=array();private$functions=array();private$constants=array();public function __construct($name,Broker$broker){$this->name=$name;$this->broker=$broker;}public function getClass($className){$className=ltrim($className,'\\');if(false === strpos($className,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$className=$this->getName().'\\'.$className;}if(!isset($this->classes[$className])){throw new Exception(sprintf('Class %s does not exist',$className),Exception::DOES_NOT_EXIST);}return$this->classes[$className];}public function getClasses(){return$this->classes;}public function getClassNames(){return array_keys($this->classes);}public function getClassShortNames(){return array_map(function(IReflectionClass$class){return$class->getShortName();},$this->classes);}public function getFunction($functionName){$functionName=ltrim($functionName,'\\');if(false === strpos($functionName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$functionName=$this->getName().'\\'.$functionName;}if(!isset($this->functions[$functionName])){throw new Exception(sprintf('Function %s does not exist',$functionName),Exception::DOES_NOT_EXIST);}return$this->functions[$functionName];}public function getFunctions(){return$this->functions;}public function getFunctionNames(){return array_keys($this->functions);}public function getFunctionShortNames(){return array_map(function(IReflectionFunction$function){return$function->getShortName();},$this->functions);}public function getConstant($constantName){$constantName=ltrim($constantName,'\\');if(false === strpos($constantName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$constantName=$this->getName().'\\'.$constantName;}if(!isset($this->constants[$constantName])){throw new Exception(sprintf('Constant %s does not exist',$constantName),Exception::DOES_NOT_EXIST);}return$this->constants[$constantName];}public function getConstants(){return$this->constants;}public function getConstantNames(){return array_keys($this->constants);}public function getConstantShortNames(){return array_map(function(IReflectionConstant$constant){return$constant->getShortName();},$this->constants);}public function getName(){return$this->name;}public function getBroker(){return$this->broker;}public function isTokenized(){return true;}public function isInternal(){return false;}public function isUserDefined(){return true;}public function addFileNamespace(ReflectionFileNamespace$namespace){$classes=$namespace->getClasses();foreach($this->classes as$className =>$reflection){if(isset($classes[$className])){throw new RuntimeException(sprintf('Class %s was defined multiple times',$className));}}$this->classes=array_merge($this->classes,$classes);$functions=$namespace->getFunctions();foreach($this->functions as$functionName =>$reflection){if(isset($functions[$functionName])){throw new RuntimeException(sprintf('Function %s was defined multiple times',$functionName));}}$this->functions=array_merge($this->functions,$functions);$constants=$namespace->getConstants();foreach($this->constants as$constantName =>$reflection){if(isset($constants[$constantName])){throw new RuntimeException(sprintf('Constant %s was defined multiple times',$constantName));}}$this->constants=array_merge($this->constants,$constants);}public function __toString(){return '';}public static function export($argument,$return=false){return ReflectionBase::export($argument,$return);}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}}
 namespace TokenReflection;use RuntimeException,TokenReflection\Exception;class ReflectionParameter extends ReflectionBase implements IReflectionParameter{CONST ARRAY_CONSTRAINT='array';private static$parseValueDefinitions=false;private$valueConstraint;private$originalValueConstraint;private$defaultValueDefinition;private$defaultValue;private$declaringClassName;private$declaringFunctionName;private$passedByReference=false;private$isOptional;private$position;public function allowsNull(){return true;}public function getClass(){$name=$this->getClassName();if(null ===$name){return null;}return$this->getBroker()->getClass($name);}public function getClassName(){if($this->isArray()){return null;}if(null ===$this->valueConstraint &&null !==$this->originalValueConstraint){if(null !==$this->declaringClassName){$parent=$this->getDeclaringClass();if(null ===$parent ||!$parent->isTokenized()){throw new Exception(sprintf('Could not load class %s reflection',$this->declaringClassName));}}else{$parent=$this->getDeclaringFunction();if(null ===$parent ||!$parent->isTokenized()){throw new Exception(sprintf('Could not load function %s reflection',$this->declaringFunctionName));}}$this->valueConstraint=self::resolveClassFQN($this->originalValueConstraint,$parent->getNamespaceAliases(),$parent->getNamespaceName());}return$this->valueConstraint;}public function getOriginalClassName(){return!$this->isArray()?ltrim($this->originalValueConstraint,'\\'):null;}public function getDeclaringClass(){return null ===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getDeclaringFunction(){if(null !==$this->declaringClassName){$class=$this->getBroker()->getClass($this->declaringClassName);if(null !==$class){return$class->getMethod($this->declaringFunctionName);}}else{return$this->getBroker()->getFunction($this->declaringFunctionName);}}public function getDeclaringFunctionName(){return$this->declaringFunctionName;}public function getDefaultValue(){if(null ===$this->defaultValueDefinition){throw new Exception('Property has no default value',Exception::DOES_NOT_EXIST);}return$this->defaultValue;}public function getDefaultValueDefinition(){return$this->defaultValueDefinition;}public function getPosition(){return$this->position;}public function isArray(){return$this->valueConstraint === self::ARRAY_CONSTRAINT;}public function isDefaultValueAvailable(){return null !==$this->defaultValueDefinition;}public function getInheritedDocComment(){return$this->getDocComment();}public function isOptional(){if(null ===$this->isOptional){$function=$this->getDeclaringFunction();if(null ===$function){throw new RuntimeException(sprintf('Could not get the declaring function %s reflection.',$this->declaringFunctionName));}$this->isOptional=true;foreach(array_slice($function->getParameters(),$this->position)as$reflectionParameter){if(!$reflectionParameter->isDefaultValueAvailable()){$this->isOptional=false;break;}}}return$this->isOptional;}public function isPassedByReference(){return$this->passedByReference;}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFunctionBase){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFunctionBase descendant class, %s given.',get_class($parent)));}$this->declaringFunctionName=$parent->getName();$this->position=count($parent->getParameters());if($parent instanceof ReflectionMethod){$this->declaringClassName=$parent->getDeclaringClassName();}return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return$this ->parseConstraint($tokenStream)->parsePassedByReference($tokenStream)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw new RuntimeException('Could not find the parameter variable definition');}$token=$tokenStream->current();$this->name=substr($token[1],1);$tokenStream->skipWhitespaces();return$this;}private function parseConstraint(Stream$tokenStream){$type=$tokenStream->getType();if(T_ARRAY ===$type){$this->valueConstraint=self::ARRAY_CONSTRAINT;$this->originalValueConstraint=self::ARRAY_CONSTRAINT;$tokenStream->skipWhitespaces();}elseif(T_STRING ===$type || T_NS_SEPARATOR ===$type){$className='';do{$token=$tokenStream->current();$className .=$token[1];$tokenStream->skipWhitespaces();$type=$tokenStream->getType();}while(T_STRING ===$type || T_NS_SEPARATOR ===$type);if('' === ltrim($className,'\\')){throw new RuntimeException('Invalid value constraint definition');}$this->originalValueConstraint=$className;}return$this;}private function parsePassedByReference(Stream$tokenStream){if($tokenStream->is('&')){$this->passedByReference=true;$tokenStream->skipWhitespaces();}return$this;}private function parseDefaultValue(Stream$tokenStream){if($tokenStream->is('=')){$tokenStream->skipWhitespaces();$this->defaultValueDefinition=Stream::tokensToCode(array_slice($tokenStream->getArrayCopy(),$tokenStream->key()));if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}}return$this;}public static function setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public static function getParseValueDefinitions(){return self::$parseValueDefinitions;}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionFunction,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionFunction as InternalReflectionFunction,ReflectionParameter as InternalReflectionParameter;use RuntimeException;class ReflectionFunction extends InternalReflectionFunction implements IReflection,IReflectionFunction{private$broker;private$parameters;public function __construct($functionName,Broker$broker){parent::__construct($functionName);$this->broker=$broker;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getExtension(){return ReflectionExtension::create(parent::getExtension(),$this->broker);}public function getParameters(){if(null ===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public function getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getInheritedDocComment(){return$this->getDocComment();}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){if(!$internalReflection instanceof InternalReflectionFunction){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionFunction expected.',get_class($internalReflection)));}return$broker->getFunction($internalReflection->getName());}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionMethod,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionMethod as InternalReflectionMethod,ReflectionParameter as InternalReflectionParameter;use RuntimeException;class ReflectionMethod extends InternalReflectionMethod implements IReflection,IReflectionMethod{private$broker;private$parameters;public function __construct($class,$methodName,Broker$broker){parent::__construct($class,$methodName);$this->broker=$broker;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getParameters(){if(null ===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if($parent &&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return false;}public function getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getDeclaringClass(){return ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public function getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public function getClass(){return$this->getDeclaringClassName();}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function getPrototype(){return self::create(parent::getPrototype(),$this->broker);}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection instanceof InternalReflectionMethod){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionMethod expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}
 namespace TokenReflection;use RuntimeException;class ReflectionFunction extends ReflectionFunctionBase implements IReflectionFunction{private$aliases=array();public function isDisabled(){return$this->hasAnnotation('disabled');}public function getInheritedDocComment(){return$this->getDocComment();}public function invoke(){return$this->invokeArgs(func_get_args());}public function invokeArgs(array$args=array()){if(!function_exists($this->getName())){throw new RuntimeException('Function %s is not defined in the current scope.',$this->getName());}return call_user_func_array($this->getName(),$args);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseReturnsReference($tokenStream)->parseName($tokenStream);}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFileNamespace){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return parent::processParent($parent);}public function getNamespaceAliases(){return$this->aliases;}}
 namespace TokenReflection;use ReflectionMethod as InternalReflectionMethod,ReflectionClass as InternalReflectionClass;use RuntimeException,InvalidArgumentException;class ReflectionMethod extends ReflectionFunctionBase implements IReflectionMethod{const IS_IMPLEMENTED_ABSTRACT=0x08;const ACCESS_LEVEL_CHANGED=0x800;const IS_CONSTRUCTOR=0x2000;const IS_DESTRUCTOR=0x4000;const IS_CLONE=0x8000;const IS_ALLOWED_STATIC=0x10000;private$declaringClassName;private$accessible=false;public function getDeclaringClass(){return null ===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getClass(){return$this->getDeclaringClassName();}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())&&false === strpos($docComment,'@inheritdoc')){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null !==$parent &&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return false;}public function getModifiers(){if(!($this->modifiers&(self::ACCESS_LEVEL_CHANGED|self::IS_IMPLEMENTED_ABSTRACT))){$declaringClass=$this->getDeclaringClass();if(null ===$declaringClass){throw new RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null !==$parentClass){$parentClassMethods=$parentClass->getMethods();if($this->modifiers&InternalReflectionMethod::IS_PUBLIC){if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::ACCESS_LEVEL_CHANGED|InternalReflectionMethod::IS_PRIVATE))){$this->modifiers |= self::ACCESS_LEVEL_CHANGED;}}if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::IS_IMPLEMENTED_ABSTRACT|InternalReflectionMethod::IS_ABSTRACT))){$this->modifiers |= self::IS_IMPLEMENTED_ABSTRACT;}}}return$this->modifiers;}public function invoke($object,$args){$params=func_get_args();return$this->invokeArgs(array_shift($params),$params);}public function invokeArgs($object,array$args=array()){$declaringClass=$this->getDeclaringClass();if(!$declaringClass->isInstance($object)){throw new InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return call_user_func_array(array($object,$this->getName()),$args);}elseif($this->isAccessible()){$refClass=new InternalReflectionClass($object);$refMethod=$refClass->getMethod($this->name);$refMethod->setAccessible(true);$value=$refMethod->invokeArgs($object,$args);$refMethod->setAccessible(false);return$value;}throw new RuntimeException('Only public methods can be invoked.');}public function isAbstract(){return (bool)($this->modifiers&InternalReflectionMethod::IS_ABSTRACT);}public function isConstructor(){return (bool)($this->modifiers&self::IS_CONSTRUCTOR);}public function isDestructor(){return (bool)($this->modifiers&self::IS_DESTRUCTOR);}public function isFinal(){return (bool)($this->modifiers&InternalReflectionMethod::IS_FINAL);}public function isPrivate(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PRIVATE);}public function isProtected(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PROTECTED);}public function isPublic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PUBLIC);}public function isStatic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_STATIC);}public function setAccessible($accessible){$this->accessible=$accessible;}public function isAccessible(){return$this->accessible;}public function getPrototype(){$declaring=$this->getDeclaringClass();if($declaring->getParentClassName()){foreach($declaring->getParentClass()->getMethods()as$method){if($method->getName()===$this->name &&!$method->isPrivate()){return$method;}}}foreach($declaring->getInterfaces()as$interface){if($interface->hasMethod($this->name)){return$interface->getMethod($this->name);}}throw new Exception('Method has no prototype',Exception::DOES_NOT_EXIST);}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionClass){throw new RuntimeException('The parent object has to be either an instance of TokenReflection\ReflectionClass or NULL, %s given.',get_class($parent));}$this->declaringClassName=$parent->getName();return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseBaseModifiers($tokenStream)->parseReturnsReference($tokenStream)->parseName($tokenStream)->parseInternalModifiers($parent);}private function parseBaseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case T_ABSTRACT:$this->modifiers |= InternalReflectionMethod::IS_ABSTRACT;break;case T_FINAL:$this->modifiers |= InternalReflectionMethod::IS_FINAL;break;case T_PUBLIC:$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;break;case T_PRIVATE:$this->modifiers |= InternalReflectionMethod::IS_PRIVATE;break;case T_PROTECTED:$this->modifiers |= InternalReflectionMethod::IS_PROTECTED;break;case T_STATIC:$this->modifiers |= InternalReflectionMethod::IS_STATIC;break;case T_FUNCTION:case null:break 2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&InternalReflectionMethod::IS_PRIVATE)&&!($this->modifiers&InternalReflectionMethod::IS_PROTECTED)){$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;}return$this;}private function parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct' ===$name ||($class &&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers |= self::IS_CONSTRUCTOR;}elseif('__destruct' ===$name){$this->modifiers |= self::IS_DESTRUCTOR;}elseif('__clone' ===$name){$this->modifiers |= self::IS_CLONE;}if(!$this->isConstructor()&&!$this->isDestructor()&&!in_array($name,array('__clone','__tostring','__get','__set','__isset','__unset'),true)){$this->modifiers |= self::IS_ALLOWED_STATIC;}return$this;}}||||||||function
parseReturnsReference(Stream$tokenStream){if(!$tokenStream->is(T_FUNCTION)){throw
new
RuntimeException('Could not find the function keyword.');}$tokenStream->skipWhitespaces();$type=$tokenStream->getType();if('&'
===$type){$this->returnsReference=true;$tokenStream->skipWhitespaces();}elseif(T_STRING
!==$type){throw
new
RuntimeException(sprintf('Unexpected token type: %s',$tokenStream->getTokenName()));}return$this;}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionNamespace
implements
IReflectionNamespace{const
NO_NAMESPACE_NAME='no-namespace';private$broker;private$name;private$classes=array();private$functions=array();private$constants=array();public
function
__construct($name,Broker$broker){$this->name=$name;$this->broker=$broker;}public
function
getClass($className){$className=ltrim($className,'\\');if(false
===
strpos($className,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$className=$this->getName().'\\'.$className;}if(!isset($this->classes[$className])){throw
new
Exception(sprintf('Class %s does not exist',$className),Exception::DOES_NOT_EXIST);}return$this->classes[$className];}public
function
getClasses(){return$this->classes;}public
function
getClassNames(){return
array_keys($this->classes);}public
function
getClassShortNames(){return
array_map(function(IReflectionClass$class){return$class->getShortName();},$this->classes);}public
function
getFunction($functionName){$functionName=ltrim($functionName,'\\');if(false
===
strpos($functionName,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$functionName=$this->getName().'\\'.$functionName;}if(!isset($this->functions[$functionName])){throw
new
Exception(sprintf('Function %s does not exist',$functionName),Exception::DOES_NOT_EXIST);}return$this->functions[$functionName];}public
function
getFunctions(){return$this->functions;}public
function
getFunctionNames(){return
array_keys($this->functions);}public
function
getFunctionShortNames(){return
array_map(function(IReflectionFunction$function){return$function->getShortName();},$this->functions);}public
function
getConstant($constantName){$constantName=ltrim($constantName,'\\');if(false
===
strpos($constantName,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$constantName=$this->getName().'\\'.$constantName;}if(!isset($this->constants[$constantName])){throw
new
Exception(sprintf('Constant %s does not exist',$constantName),Exception::DOES_NOT_EXIST);}return$this->constants[$constantName];}public
function
getConstants(){return$this->constants;}public
function
getConstantNames(){return
array_keys($this->constants);}public
function
getConstantShortNames(){return
array_map(function(IReflectionConstant$constant){return$constant->getShortName();},$this->constants);}public
function
getName(){return$this->name;}public
function
getBroker(){return$this->broker;}public
function
isTokenized(){return
true;}public
function
isInternal(){return
false;}public
function
isUserDefined(){return
true;}public
function
addFileNamespace(ReflectionFileNamespace$namespace){$classes=$namespace->getClasses();foreach($this->classes
as$className
=>$reflection){if(isset($classes[$className])){throw
new
RuntimeException(sprintf('Class %s was defined multiple times',$className));}}$this->classes=array_merge($this->classes,$classes);$functions=$namespace->getFunctions();foreach($this->functions
as$functionName
=>$reflection){if(isset($functions[$functionName])){throw
new
RuntimeException(sprintf('Function %s was defined multiple times',$functionName));}}$this->functions=array_merge($this->functions,$functions);$constants=$namespace->getConstants();foreach($this->constants
as$constantName
=>$reflection){if(isset($constants[$constantName])){throw
new
RuntimeException(sprintf('Constant %s was defined multiple times',$constantName));}}$this->constants=array_merge($this->constants,$constants);}public
function
__toString(){return
'';}public
static
function
export($argument,$return=false){return
ReflectionBase::export($argument,$return);}final
public
function
__get($key){return
ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
ReflectionBase::exists($this,$key);}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionParameter
extends
ReflectionBase
implements
IReflectionParameter{CONST
ARRAY_CONSTRAINT='array';private
static$parseValueDefinitions=false;private$valueConstraint;private$originalValueConstraint;private$defaultValueDefinition;private$defaultValue;private$declaringClassName;private$declaringFunctionName;private$passedByReference=false;private$isOptional;private$position;public
function
allowsNull(){return
true;}public
function
getClass(){$name=$this->getClassName();if(null
===$name){return
null;}return$this->getBroker()->getClass($name);}public
function
getClassName(){if($this->isArray()){return
null;}if(null
===$this->valueConstraint
&&null
!==$this->originalValueConstraint){if(null
!==$this->declaringClassName){$parent=$this->getDeclaringClass();if(null
===$parent
||!$parent->isTokenized()){throw
new
Exception(sprintf('Could not load class %s reflection',$this->declaringClassName));}}else{$parent=$this->getDeclaringFunction();if(null
===$parent
||!$parent->isTokenized()){throw
new
Exception(sprintf('Could not load function %s reflection',$this->declaringFunctionName));}}$this->valueConstraint=self::resolveClassFQN($this->originalValueConstraint,$parent->getNamespaceAliases(),$parent->getNamespaceName());}return$this->valueConstraint;}public
function
getOriginalClassName(){return!$this->isArray()?ltrim($this->originalValueConstraint,'\\'):null;}public
function
getDeclaringClass(){return
null
===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getDeclaringFunction(){if(null
!==$this->declaringClassName){$class=$this->getBroker()->getClass($this->declaringClassName);if(null
!==$class){return$class->getMethod($this->declaringFunctionName);}}else{return$this->getBroker()->getFunction($this->declaringFunctionName);}}public
function
getDeclaringFunctionName(){return$this->declaringFunctionName;}public
function
getDefaultValue(){if(null
===$this->defaultValueDefinition){throw
new
Exception('Property has no default value',Exception::DOES_NOT_EXIST);}return$this->defaultValue;}public
function
getDefaultValueDefinition(){return$this->defaultValueDefinition;}public
function
getPosition(){return$this->position;}public
function
isArray(){return$this->valueConstraint
===
self::ARRAY_CONSTRAINT;}public
function
isDefaultValueAvailable(){return
null
!==$this->defaultValueDefinition;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
isOptional(){if(null
===$this->isOptional){$function=$this->getDeclaringFunction();if(null
===$function){throw
new
RuntimeException(sprintf('Could not get the declaring function %s reflection.',$this->declaringFunctionName));}$this->isOptional=true;foreach(array_slice($function->getParameters(),$this->position)as$reflectionParameter){if(!$reflectionParameter->isDefaultValueAvailable()){$this->isOptional=false;break;}}}return$this->isOptional;}public
function
isPassedByReference(){return$this->passedByReference;}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFunctionBase){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFunctionBase descendant class, %s given.',get_class($parent)));}$this->declaringFunctionName=$parent->getName();$this->position=count($parent->getParameters());if($parent
instanceof
ReflectionMethod){$this->declaringClassName=$parent->getDeclaringClassName();}return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseConstraint($tokenStream)->parsePassedByReference($tokenStream)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw
new
RuntimeException('Could not find the parameter variable definition');}$this->name=substr($tokenStream->getTokenValue(),1);$tokenStream->skipWhitespaces();return$this;}private
function
parseConstraint(Stream$tokenStream){$type=$tokenStream->getType();if(T_ARRAY
===$type){$this->valueConstraint=self::ARRAY_CONSTRAINT;$this->originalValueConstraint=self::ARRAY_CONSTRAINT;$tokenStream->skipWhitespaces();}elseif(T_STRING
===$type
||
T_NS_SEPARATOR
===$type){$className='';do{$className
.=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();$type=$tokenStream->getType();}while(T_STRING
===$type
||
T_NS_SEPARATOR
===$type);if(''
===
ltrim($className,'\\')){throw
new
RuntimeException('Invalid value constraint definition');}$this->originalValueConstraint=$className;}return$this;}private
function
parsePassedByReference(Stream$tokenStream){if($tokenStream->is('&')){$this->passedByReference=true;$tokenStream->skipWhitespaces();}return$this;}private
function
parseDefaultValue(Stream$tokenStream){if($tokenStream->is('=')){$tokenStream->skipWhitespaces();$level=0;while(null
!==($type=$tokenStream->getType())){switch($type){case
')':if(0
===$level){break
2;}case
'}':case
']':$level--;break;case
'(':case
'{':case
'[':$level++;break;case
',':if(0
===$level){break
2;}}$this->defaultValueDefinition
.=$tokenStream->getTokenValue();$tokenStream->next();}if(','
===$type){$tokenStream->next();}elseif(')'
!==$type){throw
new
RuntimeException('Parameter default value definition is not terminated properly');}if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}}return$this;}public
static
function
setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public
static
function
getParseValueDefinitions(){return
self::$parseValueDefinitions;}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionFunction
as
InternalReflectionFunction,ReflectionParameter
as
InternalReflectionParameter;use
RuntimeException;class
ReflectionFunction
extends
InternalReflectionFunction
implements
IReflection,TokenReflection\IReflectionFunction{private$broker;private$parameters;public
function
__construct($functionName,Broker$broker){parent::__construct($functionName);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getExtension(){return
ReflectionExtension::create(parent::getExtension(),$this->broker);}public
function
getParameters(){if(null
===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return
ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public
function
getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
isTokenized(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){if(!$internalReflection
instanceof
InternalReflectionFunction){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionFunction expected.',get_class($internalReflection)));}return$broker->getFunction($internalReflection->getName());}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionMethod
as
InternalReflectionMethod,ReflectionParameter
as
InternalReflectionParameter;use
RuntimeException;class
ReflectionMethod
extends
InternalReflectionMethod
implements
IReflection,TokenReflection\IReflectionMethod{private$broker;private$parameters;public
function
__construct($class,$methodName,Broker$broker){parent::__construct($class,$methodName);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getParameters(){if(null
===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return
ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if($parent
&&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return
false;}public
function
getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getDeclaringClass(){return
ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public
function
getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
getPrototype(){return
self::create(parent::getPrototype(),$this->broker);}public
function
isTokenized(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection
instanceof
InternalReflectionMethod){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionMethod expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new
self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionFunction
extends
ReflectionFunctionBase
implements
IReflectionFunction{private$aliases=array();public
function
isDisabled(){return$this->hasAnnotation('disabled');}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
invoke(){return$this->invokeArgs(func_get_args());}public
function
invokeArgs(array$args=array()){if(!function_exists($this->getName())){throw
new
RuntimeException('Function %s is not defined in the current scope.',$this->getName());}return
call_user_func_array($this->getName(),$args);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseReturnsReference($tokenStream)->parseName($tokenStream);}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFileNamespace){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return
parent::processParent($parent);}public
function
getNamespaceAliases(){return$this->aliases;}}}

namespace
TokenReflection{use
ReflectionMethod
as
InternalReflectionMethod,ReflectionClass
as
InternalReflectionClass;use
RuntimeException,InvalidArgumentException;class
ReflectionMethod
extends
ReflectionFunctionBase
implements
IReflectionMethod{const
IS_IMPLEMENTED_ABSTRACT=0x08;const
ACCESS_LEVEL_CHANGED=0x800;const
IS_CONSTRUCTOR=0x2000;const
IS_DESTRUCTOR=0x4000;const
IS_CLONE=0x8000;const
IS_ALLOWED_STATIC=0x10000;private$declaringClassName;private$accessible=false;public
function
getDeclaringClass(){return
null
===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())&&false
===
strpos($docComment,'@inheritdoc')){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null
!==$parent
&&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return
false;}public
function
getModifiers(){if(!($this->modifiers&(self::ACCESS_LEVEL_CHANGED|self::IS_IMPLEMENTED_ABSTRACT))){$declaringClass=$this->getDeclaringClass();if(null
===$declaringClass){throw
new
RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null
!==$parentClass){$parentClassMethods=$parentClass->getMethods();if($this->modifiers&InternalReflectionMethod::IS_PUBLIC){if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::ACCESS_LEVEL_CHANGED|InternalReflectionMethod::IS_PRIVATE))){$this->modifiers
|=
self::ACCESS_LEVEL_CHANGED;}}if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::IS_IMPLEMENTED_ABSTRACT|InternalReflectionMethod::IS_ABSTRACT))){$this->modifiers
|=
self::IS_IMPLEMENTED_ABSTRACT;}}}return$this->modifiers;}public
function
invoke($object,$args){$params=func_get_args();return$this->invokeArgs(array_shift($params),$params);}public
function
invokeArgs($object,array$args=array()){$declaringClass=$this->getDeclaringClass();if(!$declaringClass->isInstance($object)){throw
new
InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return
call_user_func_array(array($object,$this->getName()),$args);}elseif($this->isAccessible()){$refClass=new
InternalReflectionClass($object);$refMethod=$refClass->getMethod($this->name);$refMethod->setAccessible(true);$value=$refMethod->invokeArgs($object,$args);$refMethod->setAccessible(false);return$value;}throw
new
RuntimeException('Only public methods can be invoked.');}public
function
isAbstract(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_ABSTRACT);}public
function
isConstructor(){return
(bool)($this->modifiers&self::IS_CONSTRUCTOR);}public
function
isDestructor(){return
(bool)($this->modifiers&self::IS_DESTRUCTOR);}public
function
isFinal(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_FINAL);}public
function
isPrivate(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PRIVATE);}public
function
isProtected(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PROTECTED);}public
function
isPublic(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PUBLIC);}public
function
isStatic(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_STATIC);}public
function
setAccessible($accessible){$this->accessible=$accessible;}public
function
isAccessible(){return$this->accessible;}public
function
getPrototype(){$declaring=$this->getDeclaringClass();if($declaring->getParentClassName()){foreach($declaring->getParentClass()->getMethods()as$method){if($method->getName()===$this->name
&&!$method->isPrivate()){return$method;}}}foreach($declaring->getInterfaces()as$interface){if($interface->hasMethod($this->name)){return$interface->getMethod($this->name);}}throw
new
Exception('Method has no prototype',Exception::DOES_NOT_EXIST);}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionClass){throw
new
RuntimeException('The parent object has to be either an instance of TokenReflection\ReflectionClass or NULL, %s given.',get_class($parent));}$this->declaringClassName=$parent->getName();return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseBaseModifiers($tokenStream)->parseReturnsReference($tokenStream)->parseName($tokenStream)->parseInternalModifiers($parent);}private
function
parseBaseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case
T_ABSTRACT:$this->modifiers
|=
InternalReflectionMethod::IS_ABSTRACT;break;case
T_FINAL:$this->modifiers
|=
InternalReflectionMethod::IS_FINAL;break;case
T_PUBLIC:$this->modifiers
|=
InternalReflectionMethod::IS_PUBLIC;break;case
T_PRIVATE:$this->modifiers
|=
InternalReflectionMethod::IS_PRIVATE;break;case
T_PROTECTED:$this->modifiers
|=
InternalReflectionMethod::IS_PROTECTED;break;case
T_STATIC:$this->modifiers
|=
InternalReflectionMethod::IS_STATIC;break;case
T_FUNCTION:case
null:break
2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&(InternalReflectionMethod::IS_PRIVATE|InternalReflectionMethod::IS_PROTECTED))){$this->modifiers
|=
InternalReflectionMethod::IS_PUBLIC;}return$this;}private
function
parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct'
===$name
||($class
&&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers
|=
self::IS_CONSTRUCTOR;}elseif('__destruct'
===$name){$this->modifiers
|=
self::IS_DESTRUCTOR;}elseif('__clone'
===$name){$this->modifiers
|=
self::IS_CLONE;}static$notAllowed;if(null
===$notAllowed){$notAllowed=array_flip(array('__clone','__tostring','__get','__set','__isset','__unset'));}if(!$this->isConstructor()&&!$this->isDestructor()&&!isset($notAllowed[$name])){$this->modifiers
|=
self::IS_ALLOWED_STATIC;}return$this;}}}||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_CONST))))
            (
                (AST_THROW
                    (AST_NEW
                        (
                            (SCALAR)))))))
    (AST_METHOD_CALL
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_CONST))
                (AST_METHOD_CALL
                    (AST_VAR))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_UNARY_OP
                    (AST_CONST))
                (AST_VAR))
            (
                (AST_THROW
                    (AST_NEW
                        (
                            (AST_CALL
                                (
                                    (SCALAR)
                                    (AST_METHOD_CALL
                                        (AST_VAR))))))))))
    (AST_RETURN
        (AST_VAR)))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_CONST))))
            (
                (AST_THROW
                    (AST_NEW
                        (
                            (SCALAR)))))))
    (AST_METHOD_CALL
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_CONST))
                (AST_METHOD_CALL
                    (AST_VAR))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (AST_VAR))
            (
                (AST_THROW
                    (AST_NEW
                        (
                            (AST_CALL
                                (
                                    (SCALAR)
                                    (AST_METHOD_CALL
                                        (AST_VAR))))))))))
    (AST_RETURN
        (AST_VAR)))