    function insert_element($element, $destination_sortorder, $position='before') {
        if (empty($this->first_sortorder)) {
            $this->reset_first_sortorder();
        }

        if ($position == 'before') {
            $offset = -1;
        } elseif ($position == 'after') {
            $offset = 0;
        } else {
            debugging('move_element(..... $position) can only be "before" or "after", you gave ' . $position);
            return false;
        }

        if (is_array($element)) {
            $new_element = new stdClass();
            $new_element->element = $element;
        } elseif (is_object($element)) {
            $new_element = $element;
        }

        $new_element_class = get_class($new_element->element['object']);
        $has_final_grades = !empty($new_element->element['final_grades']);

        // If the object is a grade_item, but the final_grades index isn't yet loaded, make the switch now. Same for grade_category and children
        if ($new_element_class == 'grade_item' && !$has_final_grades && $this->include_grades) {
            $new_element->element['final_grades'] = $new_element->element['object']->get_final();

        } elseif ($new_element_class == 'grade_category' && empty($new_element->element['children']) && $new_element->element['object']->has_children()) {
            $new_element->element['children'] = $new_element->element['object']->get_children(1);
            unset($new_element->element['object']->children);
        }

        $destination_array = array($destination_sortorder => $new_element->element);

        // Get the position of the destination element
        $destination_element = $this->locate_element($destination_sortorder);
        $position = $destination_element->position;

        // Decompose the element's index and build string for eval(array_splice) statement to follow
        $indices = explode('/', $destination_element->index);

        if (empty($indices)) {
            debugging("The destination element did not have a valid index (as assigned by grade_tree::locate_element).");
            return false;
        }

        $element_to_splice = '$this->tree_array';

        if (isset($indices[1])) {
            $element_to_splice .= '[' . $indices[0] . "]['children']";
        }

        if (isset($indices[2])) {
            $element_to_splice .= '[' . $indices[1] . "]['children']";
        }

        eval("array_splice($element_to_splice, \$position + \$offset, 0, \$destination_array);");

        if (!is_object($new_element)) {
            debugging("Could not insert this element into the DB due to missing information.");
            return false;
        }

        $this->need_insert[$new_element->element['object']->id] = $new_element->element['object'];

        return true;
    }

    /**
     * Moves an existing element in the tree to another position OF EQUAL LEVEL. This
     * constraint is essential and very important.
     * @param int $source_sortorder The sortorder of the element to move
     * @param int $destination_sortorder The sortorder where the element will go
     * @param string $position Either 'before' the destination_sortorder or 'after' it
     * @return boolean
     */
||||||||    function insert_element($element, $destination_sortorder, $position='before') {
        //TODO: fix me
        return false;
/*        if (empty($this->first_sortorder)) {
            $this->reset_first_sortorder();
        }

        if ($position == 'before') {
            $offset = -1;
        } elseif ($position == 'after') {
            $offset = 0;
        } else {
            debugging('move_element(..... $position) can only be "before" or "after", you gave ' . $position);
            return false;
        }

        if (is_array($element)) {
            $new_element = new stdClass();
            $new_element->element = $element;
        } elseif (is_object($element)) {
            $new_element = $element;
        }

        $new_element_class = get_class($new_element->element['object']);
        $has_final_grades = !empty($new_element->element['final_grades']);

        // If the object is a grade_item, but the final_grades index isn't yet loaded, make the switch now. Same for grade_category and children
        if ($new_element_class == 'grade_item' && !$has_final_grades && $this->include_grades) {
            $new_element->element['final_grades'] = $new_element->element['object']->get_final();

        } elseif ($new_element_class == 'grade_category' && empty($new_element->element['children']) && $new_element->element['object']->has_children()) {
            $new_element->element['children'] = $new_element->element['object']->get_children(1);
            unset($new_element->element['object']->children);
        }

        $destination_array = array($destination_sortorder => $new_element->element);

        // Get the position of the destination element
        $destination_element = $this->locate_element($destination_sortorder);
        $position = $destination_element->position;

        // Decompose the element's index and build string for eval(array_splice) statement to follow
        $indices = explode('/', $destination_element->index);

        if (empty($indices)) {
            debugging("The destination element did not have a valid index (as assigned by grade_tree::locate_element).");
            return false;
        }

        $element_to_splice = '$this->tree_array';

        if (isset($indices[1])) {
            $element_to_splice .= '[' . $indices[0] . "]['children']";
        }

        if (isset($indices[2])) {
            $element_to_splice .= '[' . $indices[1] . "]['children']";
        }

        eval("array_splice($element_to_splice, \$position + \$offset, 0, \$destination_array);");

        if (!is_object($new_element)) {
            debugging("Could not insert this element into the DB due to missing information.");
            return false;
        }

        $this->need_insert[$new_element->element['object']->id] = $new_element->element['object'];

        return true;*/
    }

    /**
     * Moves an existing element in the tree to another position OF EQUAL LEVEL. This
     * constraint is essential and very important.
     * @param int $source_sortorder The sortorder of the element to move
     * @param int $destination_sortorder The sortorder where the element will go
     * @param string $position Either 'before' the destination_sortorder or 'after' it
     * @return boolean
     */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_EMPTY
                (AST_PROP
                    (AST_VAR)))
            (
                (AST_METHOD_CALL
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_UNARY_OP
                        (SCALAR)))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_CALL
                    (
                        (AST_BINARY_OP
                            (SCALAR)
                            (AST_VAR))))
                (AST_RETURN
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR))))
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_UNARY_OP
            (AST_EMPTY
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR))
                    (AST_UNARY_OP
                        (AST_VAR)))
                (AST_PROP
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR))
                    (AST_METHOD_CALL
                        (AST_DIM
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR))))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR))
                    (AST_EMPTY
                        (AST_DIM
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR))))
                (AST_METHOD_CALL
                    (AST_DIM
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR))
                    (AST_METHOD_CALL
                        (AST_DIM
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR))
                        (
                            (SCALAR))))
                (AST_UNSET
                    (AST_PROP
                        (AST_DIM
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_PROP
                    (AST_VAR))
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (SCALAR)
                (AST_PROP
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_EMPTY
                (AST_VAR))
            (
                (AST_CALL
                    (
                        (SCALAR)))
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_ISSET
                (AST_DIM
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_ASSIGN_OP
                    (AST_VAR)
                    (AST_BINARY_OP
                        (AST_BINARY_OP
                            (SCALAR)
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR)))
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ISSET
                (AST_DIM
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_ASSIGN_OP
                    (AST_VAR)
                    (AST_BINARY_OP
                        (AST_BINARY_OP
                            (SCALAR)
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR)))
                        (SCALAR))))))
    (AST_INCLUDE_OR_EVAL
        (AST_ENCAPS_LIST
            (SCALAR)
            (AST_VAR)
            (SCALAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_CALL
                    (
                        (AST_VAR))))
            (
                (AST_CALL
                    (
                        (SCALAR)))
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_DIM
            (AST_PROP
                (AST_VAR))
            (AST_PROP
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR))))
        (AST_DIM
            (AST_PROP
                (AST_VAR))
            (SCALAR)))
    (AST_RETURN
        (AST_CONST)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_RETURN
        (AST_CONST)))