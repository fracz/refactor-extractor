	public static function route($method, $uri)
	{
		// First we will make sure the bundle that handles the given URI has
		// been started for the current request. Bundles may handle any URI
		// as long as it begins with the string in the "handles" item of
		// the bundle's registration array.
		Bundle::start($bundle = Bundle::handles($uri));

		// All route URIs begin with the request method and have a leading
		// slash before the URI. We'll put the request method and URI in
		// that format so we can easily check for literal matches.
		$destination = $method.' /'.trim($uri, '/');

		if (array_key_exists($destination, static::$routes))
		{
			return new Route($destination, static::$routes[$destination], array());
		}

		// If we can't find a literal match, we'll iterate through all of
		// the registered routes to find a matching route that uses some
		// regular expressions or wildcards.
		if ( ! is_null($route = static::match($destination)))
		{
			return $route;
		}

		// If the bundle handling the request is not the default bundle,
		// we want to remove the root "handles" string from the URI so
		// it will not interfere with searching for a controller.
		//
		// If we left it on the URI, the root controller for the bundle
		// would need to be nested in directories matching the clause.
		// This will not intefere with the Route::handles method
		// as the destination is used to set the route's URIs.
		if ($bundle !== DEFAULT_BUNDLE)
		{
			$uri = str_replace(Bundle::get($bundle)->handles, '', $uri);

			$uri = ltrim($uri, '/');
		}

		return static::controller($bundle, $method, $destination, Str::segments($uri));
	}

	/**
	 * Iterate through every route to find a matching route.
	 *
	 * @param  string  $destination
	 * @return Route
	 */
||||||||	public static function route($method, $uri)
	{
		// First we will make sure the bundle that handles the given URI has
		// been started for the current request. Bundles may handle any URI
		// as long as it begins with the string in the "handles" item of
		// the bundle's registration array.
		Bundle::start($bundle = Bundle::handles($uri));

		// All route URIs begin with the request method and have a leading
		// slash before the URI. We'll put the request method and URI in
		// that format so we can easily check for literal matches.
		$destination = $method.' /'.trim($uri, '/');

		if (array_key_exists($destination, static::$routes))
		{
			return new Route($destination, static::$routes[$destination], array());
		}

		// If we can't find a literal match, we'll iterate through all of
		// the registered routes to find a matching route that uses some
		// regular expressions or wildcards.
		if ( ! is_null($route = static::match($destination)))
		{
			return $route;
		}

		// If the bundle handling the request is not the default bundle,
		// we want to remove the root "handles" string from the URI so
		// it will not interfere with searching for a controller.
		//
		// If we left it on the URI, the root controller for the bundle
		// would need to be nested in directories matching the clause.
		// This will not intefere with the Route::handles method
		// as the destination is used to set the route's URIs.
		if ($bundle !== DEFAULT_BUNDLE)
		{
			$uri = str_replace(Bundle::get($bundle)->handles, '', $uri);

			$uri = ltrim($uri, '/');
		}

		$segments = Str::segments($uri);

		return static::controller($bundle, $method, $destination, $segments);
	}

	/**
	 * Iterate through every route to find a matching route.
	 *
	 * @param  string  $destination
	 * @return Route
	 */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_STATIC_CALL
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (AST_CALL
                (
                    (AST_VAR)
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)
                    (AST_STATIC_PROP)))
            (
                (AST_RETURN
                    (AST_NEW
                        (
                            (AST_VAR)
                            (AST_DIM
                                (AST_STATIC_PROP)
                                (AST_VAR))
                            (AST_ARRAY)))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_CALL
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_STATIC_CALL
                                (
                                    (AST_VAR)))))))
            (
                (AST_RETURN
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_CONST))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_PROP
                                (AST_STATIC_CALL
                                    (
                                        (AST_VAR))))
                            (SCALAR)
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_VAR)
                            (SCALAR)))))))
    (AST_RETURN
        (AST_STATIC_CALL
            (
                (AST_VAR)
                (AST_VAR)
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR)))))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_STATIC_CALL
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (AST_CALL
                (
                    (AST_VAR)
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)
                    (AST_STATIC_PROP)))
            (
                (AST_RETURN
                    (AST_NEW
                        (
                            (AST_VAR)
                            (AST_DIM
                                (AST_STATIC_PROP)
                                (AST_VAR))
                            (AST_ARRAY)))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_CALL
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_STATIC_CALL
                                (
                                    (AST_VAR)))))))
            (
                (AST_RETURN
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_CONST))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_PROP
                                (AST_STATIC_CALL
                                    (
                                        (AST_VAR))))
                            (SCALAR)
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_VAR)
                            (SCALAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR))))
    (AST_RETURN
        (AST_STATIC_CALL
            (
                (AST_VAR)
                (AST_VAR)
                (AST_VAR)
                (AST_VAR)))))