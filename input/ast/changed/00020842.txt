    protected function load_activity($instanceid) {
        global $DB, $CFG;
        $cm = $DB->get_record('course_modules', array('id'=>$instanceid));
        if (!$cm) {
            echo "Invalid Course Module ID";
            return;
        }
        $module = $DB->get_record('modules', array('id'=>$cm->module));
        if (!$module) {
            echo "Invalid Module ID";
            return;
        }
        $course = $DB->get_record('course', array('id'=>$cm->course));
        if (!$course) {
            echo "Invalid Course ID";
            return;
        }
        $this->context = get_context_instance(CONTEXT_COURSE, $course->id);

        $key = $this->add($module->name, null, self::TYPE_ACTIVITY, null, $instanceid);

        $file = $CFG->dirroot.'/mod/'.$module->name.'/lib.php';
        $function = $module->name.'_extend_navigation';

        if (file_exists($file)) {
            require_once($file);
            if (function_exists($function)) {
                $node = $this->get($key);
                $function($node, $course, $module, $cm);
            }
        }
    }
}

/**
 * Navbar class
 *
 * This class is used to manage the navbar, which is initialised from the navigation
 * object held by PAGE
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navbar extends navigation_node {
    /** @var bool */
    protected $initialised = false;
    /** @var mixed */
    protected $keys = array();
    /** @var null|string */
    protected $content = null;
    /** @var page object */
    protected $page;
    /** @var bool */
    protected $ignoreactive = false;
    /** @var bool */
    protected $duringinstall = false;
    /** @var bool */
    protected $hasitems = false;

    /**
     * The almighty constructor
     */
    public function __construct(&$page) {
        global $SITE, $CFG;
        if (during_initial_install()) {
            $this->duringinstall = true;
            return false;
        }
        $this->page = $page;
        $this->text = get_string('home');
        $this->shorttext = get_string('home');
        $this->action = new moodle_url($CFG->wwwroot);
        $this->nodetype = self::NODETYPE_BRANCH;
        $this->type = self::TYPE_SYSTEM;
    }

    /**
     * Quick check to see if the navbar will have items in.
     *
     * @return bool Returns true if the navbar will have items, false otherwise
     */
    public function has_items() {
        if ($this->duringinstall) {
            return false;
        } else if ($this->hasitems !== false) {
            return true;
        }
        $this->page->navigation->initialise();

        $activenodefound = ($this->page->navigation->contains_active_node() ||
                            $this->page->settingsnav->contains_active_node() ||
                            $this->page->navigation->reiterate_active_nodes(URL_MATCH_BASE) ||
                            $this->page->settingsnav->reiterate_active_nodes(URL_MATCH_BASE));

        $outcome = (count($this->page->navbar->children)>0 || (!$this->ignoreactive && $activenodefound));
        $this->hasitems = $outcome;
        return $outcome;
    }

    public function ignore_active($setting=true) {
        $this->ignoreactive = ($setting);
    }

    /**
     * Generate the XHTML content for the navbar and return it
     *
     * We are lucky in that we can rely on PAGE->navigation for the structure
     * we simply need to look for the `active` path through the tree. We make this
     * easier by calling {@link strip_down_to_final_active()}.
     *
     * This function should in the future be refactored to work with a copy of the
     * PAGE->navigation object and strip it down to just this the active nodes using
     * a function that could be written again navigation_node called something like
     * strip_inactive_nodes(). I wrote this originally but currently the navigation
     * object is managed via references.
     *
     * @return string XHTML navbar content
     */
    public function content() {
        if ($this->duringinstall) {
            return '';
        }

        // Make sure that navigation is initialised
        if (!$this->has_items()) {
            return '';
        }

        if ($this->content !== null) {
            return $this->content;
        }

        // For screen readers
        $output = get_accesshide(get_string('youarehere','access'), 'h2')."<ul>\n";

        $customchildren = (count($this->children) > 0);
        // Check if navigation contains the active node
        if (!$this->ignoreactive) {
            if ($this->page->navigation->contains_active_node()) {
                // Parse the navigation tree to get the active node
                $output .= $this->parse_branch_to_html($this->page->navigation->children, true, $customchildren);
            } else if ($this->page->settingsnav->contains_active_node()) {
                // Parse the settings navigation to get the active node
                $output .= $this->parse_branch_to_html($this->page->settingsnav->children, true, $customchildren);
            } else if ($this->page->navigation->reiterate_active_nodes(URL_MATCH_BASE)) {
                // Parse the navigation tree to get the active node
                $output .= $this->parse_branch_to_html($this->page->navigation->children, true, $customchildren);
            } else if ($this->page->settingsnav->reiterate_active_nodes(URL_MATCH_BASE)) {
                // Parse the settings navigation to get the active node
                $output .= $this->parse_branch_to_html($this->page->settingsnav->children, true, $customchildren);
            } else {
                $output .= $this->parse_branch_to_html($this, true, $customchildren);
            }

        } else {
            $output .= $this->parse_branch_to_html($this, true, $customchildren);
        }
        // Check if there are any children added by code
        if ($customchildren) {
            // Add the custom children
            $output .= $this->parse_branch_to_html($this->children, false, false);
        }
        $output .= "</ul>\n";
        $this->content = $output;
        return $output;
    }
    /**
     * This function converts an array of nodes into XHTML for the navbar
     *
     * @param array $navarray
     * @param bool $firstnode
     * @return string HTML
     */
    protected function parse_branch_to_html($navarray, $firstnode=true, $moreafterthis=false) {
        global $CFG;
        $separator = get_separator();
        $output = '';
        if ($firstnode===true) {
            // If this is the first node add the class first and display the
            // navbar properties (normally sitename)
            $output .= '<li class="first">'.parent::content(true).'</li>';
        }
        $count = 0;
        if (!is_array($navarray)) return $output;
        // Iterate the navarray and display each node
        while (count($navarray)>0) {
            // Sanity check make sure we don't display WAY too much information
            // on the navbar. If we get to 20 items just stop!
            $count++;
            if ($count>20) {
                // Maximum number of nodes in the navigation branch
                return $output;
            }
            $child = false;
            // Iterate the nodes in navarray and find the active node
            foreach ($navarray as $tempchild) {
                if ($tempchild->isactive || $tempchild->contains_active_node()) {
                    $child = $tempchild;
                    // We've got the first child we can break out of this foreach
                    break;
                }
            }
            // Check if we found the child
            if ($child===false || $child->mainnavonly) {
                // Set navarray to an empty array so that we complete the while
                $navarray = array();
            } else {
                // We found an/the active node, set navarray to it's children so that
                // we come back through this while with the children of the active node
                $navarray = $child->children;
                // If there are not more arrays being processed after this AND this is the last element
                // then we want to set the action to null so that it is not used
                if (!$moreafterthis && (!$child->contains_active_node() || ($child->find_active_node()==false || $child->find_active_node()->mainnavonly))) {
                    $oldaction = $child->action;
                    $child->action = null;
                }
                if ($child->type !== navigation_node::TYPE_CATEGORY || !isset($CFG->navshowcategories) || !empty($CFG->navshowcategories)) {
                    // Now display the node
                    $output .= '<li>'.$separator.' '.$child->content(true).'</li>';
                }
                if (isset($oldaction)) {
                    $child->action = $oldaction;
                }
            }
        }
        // XHTML
        return $output;
    }
    /**
     * Add a new node to the navbar, overrides parent::add
     *
     * This function overrides {@link navigation_node::add()} so that we can change
     * the way nodes get added to allow us to simply call add and have the node added to the
     * end of the navbar
     *
     * @param string $text
     * @param string|moodle_url $action
     * @param int $type
     * @param string|int $key
     * @param string $shorttext
     * @param string $icon
     * @return string|int Identifier for this particular node
     */
    public function add($text, $action=null, $type=self::TYPE_CUSTOM, $shorttext=null, $key=null, pix_icon $icon=null) {
        // Check if there are any keys in the objects keys array
        if (count($this->keys)===0) {
            // If there are no keys then we can use the add method
            $key = parent::add($text, $action, $type, $shorttext, $key, $icon);
        } else {
            $key = $this->add_to_path($this->keys, $key, $text, $shorttext, $type, $action, $icon);
        }
        $this->keys[] = $key;
        $child = $this->get_by_path($this->keys);
        if ($child!==false) {
            // This ensure that the child will be shown
            $child->make_active();
        }
        return $key;
    }
}

/**
 * Class used to manage the settings option for the current page
 *
 * This class is used to manage the settings options in a tree format (recursively)
 * and was created initially for use with the settings blocks.
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class settings_navigation extends navigation_node {
    /** @var stdClass */
    protected $context;
    /** @var cache */
    protected $cache;
    /** @var page object */
    protected $page;
    /**
     * Sets up the object with basic settings and preparse it for use
     */
    public function __construct(&$page) {
        if (during_initial_install()) {
            return false;
        }
        static $settingsnavcount;
        $this->page = $page;
        // Initialise the main navigation. It is most important that this is done
        // before we try anything
        $this->page->navigation->initialise();
        // Initialise the navigation cache
        $this->cache = new navigation_cache(NAVIGATION_CACHE_NAME);
    }
    /**
     * Initialise the settings navigation based on the current context
     *
     * This function initialises the settings navigation tree for a given context
     * by calling supporting functions to generate major parts of the tree.
     */
    public function initialise() {
        global $SITE, $OUTPUT, $CFG;
        if (during_initial_install()) {
            return false;
        }
        $this->id = 'settingsnav';
        $this->context = $this->page->context;
        switch ($this->context->contextlevel) {
            case CONTEXT_SYSTEM:
                $this->cache->volatile();
                $adminkey = $this->load_administration_settings();
                $settingskey = $this->load_user_settings(SITEID);
                break;
            case CONTEXT_COURSECAT:
                $adminkey = $this->load_administration_settings();
                $adminnode = $this->get($adminkey);
                if ($adminnode!==false) {
                    $adminnode->forceopen =  true;
                }
                $settingskey = $this->load_user_settings(SITEID);
                break;
            case CONTEXT_COURSE:
                if ($this->page->course->id!==SITEID) {
                    $coursekey = $this->load_course_settings();
                    $coursenode = $this->get($coursekey);
                    if ($coursenode!==false) {
                        $coursenode->forceopen =  true;
                    }
                    $settingskey = $this->load_user_settings($this->page->course->id);
                    $adminkey = $this->load_administration_settings();
                } else {
                    $this->load_front_page_settings();
                    $settingskey = $this->load_user_settings($SITE->id);
                    $adminkey = $this->load_administration_settings();
                }
                break;
            case CONTEXT_MODULE:
                $modulekey = $this->load_module_settings();
                $modulenode = $this->get($modulekey);
                if ($modulenode!==false) {
                    $modulenode->forceopen =  true;
                }
                $coursekey = $this->load_course_settings();
                $settingskey = $this->load_user_settings($this->page->course->id);
                $adminkey = $this->load_administration_settings();
                break;
            case CONTEXT_USER:
                $settingskey = $this->load_user_settings($this->page->course->id);
                $settingsnode = $this->get($settingskey);
                if ($settingsnode!==false) {
                    $settingsnode->forceopen =  true;
                }
                if ($this->page->course->id!==SITEID) {
                    $coursekey = $this->load_course_settings();
                }
                $adminkey = $this->load_administration_settings();
                break;
            default:
                debugging('An unknown context has passed into settings_navigation::initialise', DEBUG_DEVELOPER);
                break;
        }

        // Check if the user is currently logged in as another user
        if (session_is_loggedinas()) {
            // Get the actual user, we need this so we can display an informative return link
            $realuser = session_get_realuser();
            // Add the informative return to original user link
            $url = new moodle_url('/course/loginas.php',array('id'=>$this->page->course->id, 'return'=>1,'sesskey'=>sesskey()));
            $this->add(get_string('returntooriginaluser', 'moodle', fullname($realuser, true)), $url, self::TYPE_SETTING, null, null, new pix_icon('t/left', ''));
        }

        // Make sure the first child doesnt have proceed with hr set to true
        reset($this->children);
        current($this->children)->preceedwithhr = false;

        $this->remove_empty_root_branches();
        $this->respect_forced_open();
    }
    /**
     * Override the parent function so that we can add preceeding hr's and set a
     * root node class against all first level element
     *
     * It does this by first calling the parent's add method {@link navigation_node::add()}
     * and then proceeds to use the key to set class and hr
     *
     * @param string $text
     * @param sting|moodle_url $url
     * @param string $shorttext
     * @param string|int $key
     * @param int $type
     * @param string $icon
     * @return sting|int A key that can be used to reference the newly added node
     */
    public function add($text, $url=null, $type=null, $shorttext=null, $key=null, pix_icon $icon=null) {
        $key = parent::add($text, $url, $type, $shorttext, $key, $icon);
        $this->get($key)->add_class('root_node');
        $this->get($key)->preceedwithhr = true;
        return $key;
    }

    /**
     * This function allows the user to add something to the start of the settings
     * navigation, which means it will be at the top of the settings navigation block
     *
     * @param string $text
     * @param sting|moodle_url $url
     * @param string $shorttext
     * @param string|int $key
     * @param int $type
     * @param string $icon
     * @return sting|int A key that can be used to reference the newly added node
     */
    public function prepend($text, $url=null, $type=null, $shorttext=null, $key=null, pix_icon $icon=null) {
        $key = $this->add($text, $url, $type, $shorttext, $key, $icon);
        $children = $this->children;
        $this->children = array();
        $this->children[$key] = array_pop($children);
        foreach ($children as $k=>$child) {
            $this->children[$k] = $child;
            $this->get($k)->add_class('root_node');
            $this->get($k)->preceedwithhr = true;
        }
        return $key;
    }
    /**
     * Load the site administration tree
     *
     * This function loads the site administration tree by using the lib/adminlib library functions
     *
     * @param null|navigation_node $referencebranch A reference to a branch in the settings
     *      navigation tree
     * @param null|part_of_admin_tree $adminbranch The branch to add, if null generate the admin
     *      tree and start at the beginning
     * @return mixed A key to access the admin tree by
     */
    protected function load_administration_settings(navigation_node $referencebranch=null, part_of_admin_tree $adminbranch=null) {
        global $CFG, $OUTPUT, $FULLME, $PAGE;

        // Check if we are just starting to generate this navigation.
        if ($referencebranch === null) {

            if (!function_exists('admin_get_root')) {
                require_once($CFG->dirroot.'/lib/adminlib.php');
            }
            $adminroot = admin_get_root(false, false);
            $branchkey = $this->add(get_string('administrationsite'), null, self::TYPE_SETTING);
            $referencebranch = $this->get($branchkey);
            foreach ($adminroot->children as $adminbranch) {
                $this->load_administration_settings($referencebranch, $adminbranch);
            }

            if (!$this->contains_active_node()) {
                $section = $PAGE->url->param('section');
                if ($current = $adminroot->locate($section, true)) {
                    if ($child = $this->find_child($current->name, self::TYPE_SETTING)) {
                        $child->make_active();
                    }
                }
            }

            return $branchkey;
        } else if ($adminbranch->check_access()) {
            // We have a reference branch that we can access and is not hidden `hurrah`
            // Now we need to display it and any children it may have
            $url = null;
            $icon = null;
            if ($adminbranch instanceof admin_settingpage) {
                $url = new moodle_url('/admin/settings.php', array('section'=>$adminbranch->name));
            } else if ($adminbranch instanceof admin_externalpage) {
                $url = $adminbranch->url;
            }

            // Add the branch
            $branchkey = $referencebranch->add($adminbranch->visiblename, $url, self::TYPE_SETTING, null, $adminbranch->name, $icon);
            $reference = $referencebranch->get($branchkey);

            if ($adminbranch->is_hidden()) {
                $reference->display = false;
            }

            // Check if we are generating the admin notifications and whether notificiations exist
            if ($adminbranch->name === 'adminnotifications' && admin_critical_warnings_present()) {
                $reference->add_class('criticalnotification');
            }
            // Check if this branch has children
            if ($reference && isset($adminbranch->children) && is_array($adminbranch->children) && count($adminbranch->children)>0) {
                foreach ($adminbranch->children as $branch) {
                    // Generate the child branches as well now using this branch as the reference
                    $this->load_administration_settings($reference, $branch);
                }
            } else {
                $reference->icon = new pix_icon('i/settings', '');
            }
        }
    }

    /**
     * Generate the list of modules for the given course.
     *
     * The array of resources and activities that can be added to a course is then
     * stored in the cache so that we can access it for anywhere.
     * It saves us generating it all the time
     *
     * <code php>
     * // To get resources:
     * $this->cache->{'course'.$courseid.'resources'}
     * // To get activities:
     * $this->cache->{'course'.$courseid.'activities'}
     * </code>
     *
     * @param stdClass $course The course to get modules for
     */
    protected function get_course_modules($course) {
        global $CFG;
        $mods = $modnames = $modnamesplural = $modnamesused = array();
        // This function is included when we include course/lib.php at the top
        // of this file
        get_all_mods($course->id, $mods, $modnames, $modnamesplural, $modnamesused);
        $resources = array();
        $activities = array();
        foreach($modnames as $modname=>$modnamestr) {
            if (!course_allowed_module($course, $modname)) {
                continue;
            }

            $libfile = "$CFG->dirroot/mod/$modname/lib.php";
            if (!file_exists($libfile)) {
                continue;
            }
            include_once($libfile);
            $gettypesfunc =  $modname.'_get_types';
            if (function_exists($gettypesfunc)) {
                $types = $gettypesfunc();
                foreach($types as $type) {
                    if (!isset($type->modclass) || !isset($type->typestr)) {
                        debugging('Incorrect activity type in '.$modname);
                        continue;
                    }
                    if ($type->modclass == MOD_CLASS_RESOURCE) {
                        $resources[html_entity_decode($type->type)] = $type->typestr;
                    } else {
                        $activities[html_entity_decode($type->type)] = $type->typestr;
                    }
                }
            } else {
                $archetype = plugin_supports('mod', $modname, FEATURE_MOD_ARCHETYPE, MOD_ARCHETYPE_OTHER);
                if ($archetype == MOD_ARCHETYPE_RESOURCE) {
                    $resources[$modname] = $modnamestr;
                } else {
                    // all other archetypes are considered activity
                    $activities[$modname] = $modnamestr;
                }
            }
        }
        $this->cache->{'course'.$course->id.'resources'} = $resources;
        $this->cache->{'course'.$course->id.'activities'} = $activities;
    }

    /**
     * This function loads the course settings that are available for the user
     *
     * @return bool|mixed Either false of a key to access the course tree by
     */
    protected function load_course_settings() {
        global $CFG, $OUTPUT, $USER, $SESSION;

        $course = $this->page->course;
        if (empty($course->context)) {
            if (!$this->cache->cached('coursecontext'.$course->id)) {
                $this->cache->{'coursecontext'.$course->id} = get_context_instance(CONTEXT_COURSE, $course->id);   // Course context
            }
            $course->context = $this->cache->{'coursecontext'.$course->id};
        }
        if (!$this->cache->cached('canviewcourse'.$course->id)) {
            $this->cache->{'canviewcourse'.$course->id} = has_capability('moodle/course:view', $course->context);
        }
        if ($course->id === SITEID || !$this->cache->{'canviewcourse'.$course->id}) {
            return false;
        }

        $coursenode = $this->page->navigation->find_child($course->id, global_navigation::TYPE_COURSE);

        $coursenodekey = $this->add(get_string('courseadministration'), null, $coursenode->type, null, 'courseadmin');
        $coursenode = $this->get($coursenodekey);

        if (has_capability('moodle/course:update', $course->context)) {
            // Add the turn on/off settings
            $url = new moodle_url('/course/view.php', array('id'=>$course->id, 'sesskey'=>sesskey()));
            if ($this->page->user_is_editing()) {
                $url->param('edit', 'off');
                $editstring = get_string('turneditingoff');
            } else {
                $url->param('edit', 'on');
                $editstring = get_string('turneditingon');
            }
            $coursenode->add($editstring, $url, self::TYPE_SETTING, null, null, new pix_icon('i/edit', ''));

            if ($this->page->user_is_editing()) {
                // Add `add` resources|activities branches
                $structurefile = $CFG->dirroot.'/course/format/'.$course->format.'/lib.php';
                if (file_exists($structurefile)) {
                    require_once($structurefile);
                    $formatstring = call_user_func('callback_'.$course->format.'_definition');
                    $formatidentifier = optional_param(call_user_func('callback_'.$course->format.'_request_key'), 0, PARAM_INT);
                } else {
                    $formatstring = get_string('topic');
                    $formatidentifier = optional_param('topic', 0, PARAM_INT);
                }
                if (!$this->cache->cached('coursesections'.$course->id)) {
                    $this->cache->{'coursesections'.$course->id} = get_all_sections($course->id);
                }
                $sections = $this->cache->{'coursesections'.$course->id};

                $addresource = $this->get($this->add(get_string('addresource')));
                $addactivity = $this->get($this->add(get_string('addactivity')));
                if ($formatidentifier!==0) {
                    $addresource->forceopen = true;
                    $addactivity->forceopen = true;
                }

                if (!$this->cache->cached('course'.$course->id.'resources')) {
                    $this->get_course_modules($course);
                }
                $resources = $this->cache->{'course'.$course->id.'resources'};
                $activities = $this->cache->{'course'.$course->id.'activities'};

                $textlib = textlib_get_instance();

                foreach ($sections as $section) {
                    if ($formatidentifier !== 0 && $section->section != $formatidentifier) {
                        continue;
                    }
                    $sectionurl = new moodle_url('/course/view.php', array('id'=>$course->id, $formatstring=>$section->section));
                    if ($section->section == 0) {
                        $sectionresources = $addresource->add(get_string('course'), $sectionurl, self::TYPE_SETTING);
                        $sectionactivities = $addactivity->add(get_string('course'), $sectionurl, self::TYPE_SETTING);
                    } else {
                        $sectionresources = $addresource->add($formatstring.' '.$section->section, $sectionurl, self::TYPE_SETTING);
                        $sectionactivities = $addactivity->add($formatstring.' '.$section->section, $sectionurl, self::TYPE_SETTING);
                    }
                    foreach ($resources as $value=>$resource) {
                        $url = new moodle_url('/course/mod.php', array('id'=>$course->id, 'sesskey'=>sesskey(), 'section'=>$section->section));
                        $pos = strpos($value, '&type=');
                        if ($pos!==false) {
                            $url->param('add', $textlib->substr($value, 0,$pos));
                            $url->param('type', $textlib->substr($value, $pos+6));
                        } else {
                            $url->param('add', $value);
                        }
                        $addresource->get($sectionresources)->add($resource, $url, self::TYPE_SETTING);
                    }
                    $subbranch = false;
                    foreach ($activities as $activityname=>$activity) {
                        if ($activity==='--') {
                            $subbranch = false;
                            continue;
                        }
                        if (strpos($activity, '--')===0) {
                            $subbranch = $addactivity->get($sectionactivities)->add(trim($activity, '-'));
                            continue;
                        }
                        $url = new moodle_url('/course/mod.php', array('id'=>$course->id, 'sesskey'=>sesskey(), 'section'=>$section->section));
                        $pos = strpos($activityname, '&type=');
                        if ($pos!==false) {
                            $url->param('add', $textlib->substr($activityname, 0,$pos));
                            $url->param('type', $textlib->substr($activityname, $pos+6));
                        } else {
                            $url->param('add', $activityname);
                        }
                        if ($subbranch !== false) {
                            $addactivity->get($sectionactivities)->get($subbranch)->add($activity, $url, self::TYPE_SETTING);
                        } else {
                            $addactivity->get($sectionactivities)->add($activity, $url, self::TYPE_SETTING);
                        }
                    }
                }
            }

            // Add the course settings link
            $url = new moodle_url('/course/edit.php', array('id'=>$course->id));
            $coursenode->add(get_string('settings'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/settings', ''));
        }

        // Add assign or override roles if allowed
        if (has_capability('moodle/role:assign', $course->context)) {
            $url = new moodle_url('/admin/roles/assign.php', array('contextid'=>$course->context->id));
            $coursenode->add(get_string('assignroles', 'role'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/roles', ''));
        } else if (get_overridable_roles($course->context, ROLENAME_ORIGINAL)) {
            $url = new moodle_url('/admin/roles/override.php', array('contextid'=>$course->context->id));
            $coursenode->add(get_string('overridepermissions', 'role'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/roles', ''));
        }

        // Add view grade report is permitted
        $reportavailable = false;
        if (has_capability('moodle/grade:viewall', $course->context)) {
            $reportavailable = true;
        } else if (!empty($course->showgrades)) {
            $reports = get_plugin_list('gradereport');
            if (is_array($reports) && count($reports)>0) {     // Get all installed reports
                arsort($reports); // user is last, we want to test it first
                foreach ($reports as $plugin => $plugindir) {
                    if (has_capability('gradereport/'.$plugin.':view', $course->context)) {
                        //stop when the first visible plugin is found
                        $reportavailable = true;
                        break;
                    }
                }
            }
        }
        if ($reportavailable) {
            $url = new moodle_url('/grade/report/index.php', array('id'=>$course->id));
            $coursenode->add(get_string('grades'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/grades', ''));
        }

        //  Add outcome if permitted
        if (!empty($CFG->enableoutcomes) && has_capability('moodle/course:update', $course->context)) {
            $url = new moodle_url('/grade/edit/outcome/course.php', array('id'=>$course->id));
            $coursenode->add(get_string('outcomes', 'grades'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/outcomes', ''));
        }

        // Add meta course links
        if ($course->metacourse) {
            if (has_capability('moodle/course:managemetacourse', $course->context)) {
                $url = new moodle_url('/course/importstudents.php', array('id'=>$course->id));
                $coursenode->add(get_string('childcourses'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/course', ''));
            } else if (has_capability('moodle/role:assign', $course->context)) {
                $key = $coursenode->add(get_string('childcourses'), null,  self::TYPE_SETTING, null, null, new pix_icon('i/course', ''));
                $coursenode->get($key)->hidden = true;;
            }
        }

        // Manage groups in this course
        if (($course->groupmode || !$course->groupmodeforce) && has_capability('moodle/course:managegroups', $course->context)) {
            $url = new moodle_url('/group/index.php', array('id'=>$course->id));
            $coursenode->add(get_string('groups'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/group', ''));
        }

        // Backup this course
        if (has_capability('moodle/site:backup', $course->context)) {
            $url = new moodle_url('/backup/backup.php', array('id'=>$course->id));
            $coursenode->add(get_string('backup'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/backup', ''));
        }

        // Restore to this course
        if (has_capability('moodle/site:restore', $course->context)) {
            $url = new moodle_url('/files/index.php', array('id'=>$course->id, 'wdir'=>'/backupdata'));
            $coursenode->add(get_string('restore'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/restore', ''));
        }

        // Import data from other courses
        if (has_capability('moodle/site:import', $course->context)) {
            $url = new moodle_url('/course/import.php', array('id'=>$course->id));
            $coursenode->add(get_string('import'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/restore', ''));
        }

        // Reset this course
        if (has_capability('moodle/course:reset', $course->context)) {
            $url = new moodle_url('/course/reset.php', array('id'=>$course->id));
            $coursenode->add(get_string('reset'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/return', ''));
        }

        // Manage questions
        $questioncaps = array('moodle/question:add',
                              'moodle/question:editmine',
                              'moodle/question:editall',
                              'moodle/question:viewmine',
                              'moodle/question:viewall',
                              'moodle/question:movemine',
                              'moodle/question:moveall');
        if (has_any_capability($questioncaps, $this->context)) {
            $questionlink = $CFG->wwwroot.'/question/edit.php';
        } else if (has_capability('moodle/question:managecategory', $this->context)) {
            $questionlink = $CFG->wwwroot.'/question/category.php';
        }
        if (isset($questionlink)) {
            $url = new moodle_url($questionlink, array('courseid'=>$course->id));
            $coursenode->add(get_string('questions','quiz'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/questions', ''));
        }

        // Repository Instances
        require_once($CFG->dirroot.'/repository/lib.php');
        $editabletypes = repository::get_editable_types($this->context);
        if (has_capability('moodle/course:update', $this->context) && !empty($editabletypes)) {
            $url = new moodle_url('/repository/manage_instances.php', array('contextid'=>$this->context->id));
            $coursenode->add(get_string('repositories'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/repository', ''));
        }

        // Manage files
        if (has_capability('moodle/course:managefiles', $this->context)) {
            $url = new moodle_url('/files/index.php', array('id'=>$course->id));
            $coursenode->add(get_string('files'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/files', ''));
        }

        // Authorize hooks
        if ($course->enrol == 'authorize' || (empty($course->enrol) && $CFG->enrol == 'authorize')) {
            require_once($CFG->dirroot.'/enrol/authorize/const.php');
            $url = new moodle_url('/enrol/authorize/index.php', array('course'=>$course->id));
            $coursenode->add(get_string('payments'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/payment', ''));
            if (has_capability('enrol/authorize:managepayments', $this->page->context)) {
                $cnt = $DB->count_records('enrol_authorize', array('status'=>AN_STATUS_AUTH, 'courseid'=>$course->id));
                if ($cnt) {
                    $url = new moodle_url('/enrol/authorize/index.php', array('course'=>$course->id,'status'=>AN_STATUS_AUTH));
                    $coursenode->add(get_string('paymentpending', 'moodle', $cnt), $url, self::TYPE_SETTING, null, null, new pix_icon('i/payment', ''));
                }
            }
        }

        // Unenrol link
        if (empty($course->metacourse)) {
            if (has_capability('moodle/legacy:guest', $this->context, NULL, false)) {   // Are a guest now
                $url = new moodle_url('/course/enrol.php', array('id'=>$course->id));
                $coursenode->add(get_string('enrolme', '', format_string($course->shortname)), $url, self::TYPE_SETTING, null, null, new pix_icon('i/user', ''));
            } else if (has_capability('moodle/role:unassignself', $this->context, NULL, false) && get_user_roles($this->context, 0, false)) {  // Have some role
                $url = new moodle_url('/course/unenrol.php', array('id'=>$course->id));
                $coursenode->add(get_string('unenrolme', '', format_string($course->shortname)), $url, self::TYPE_SETTING, null, null, new pix_icon('i/user', ''));
            }
        }

        // Link to the user own profile (except guests)
        if (!isguestuser() and isloggedin()) {
            $url = new moodle_url('/user/view.php', array('id'=>$USER->id, 'course'=>$course->id));
            $coursenode->add(get_string('profile'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/user', ''));
        }

        // Switch roles
        $roles = array();
        $assumedrole = $this->in_alternative_role();
        if ($assumedrole!==false) {
            $roles[0] = get_string('switchrolereturn');
        }
        if (has_capability('moodle/role:switchroles', $this->context)) {
            $availableroles = get_switchable_roles($this->context);
            if (is_array($availableroles)) {
                foreach ($availableroles as $key=>$role) {
                    if ($key == $CFG->guestroleid || $assumedrole===(int)$key) {
                        continue;
                    }
                    $roles[$key] = $role;
                }
            }
        }
        if (is_array($roles) && count($roles)>0) {
            $switchroleskey = $this->add(get_string('switchroleto'));
            if ((count($roles)==1 && array_key_exists(0, $roles))|| $assumedrole!==false) {
                $this->get($switchroleskey)->forceopen = true;
            }
            $returnurl = $this->page->url;
            $returnurl->param('sesskey', sesskey());
            $SESSION->returnurl = serialize($returnurl);
            foreach ($roles as $key=>$name) {
                $url = new moodle_url('/course/switchrole.php', array('id'=>$course->id,'sesskey'=>sesskey(), 'switchrole'=>$key, 'returnurl'=>'1'));
                $this->get($switchroleskey)->add($name, $url, self::TYPE_SETTING, null, $key, new pix_icon('i/roles', ''));
            }
        }
        // Return we are done
        return $coursenodekey;
    }

    /**
     * This function calls the module function to inject module settings into the
     * settings navigation tree.
     *
     * This only gets called if there is a corrosponding function in the modules
     * lib file.
     *
     * For examples mod/forum/lib.php ::: forum_extend_settings_navigation()
     *
     * @return void|mixed The key to access the module method by
     */
    protected function load_module_settings() {
        global $CFG, $DB;

        if (!$this->page->cm && $this->context->contextlevel == CONTEXT_MODULE && $this->context->instanceid) {
            $cm = get_coursemodule_from_id('chat', $this->context->instanceid);
            $cm->context = $this->context;
            if ($cm) {
                $this->page->set_cm($cm, $this->page->course);
            } else {
                debugging('The module has not been set against the page but we are attempting to generate module specific information for navigation', DEBUG_DEVELOPER);
                return;
            }
        }

        if (!$this->page->cm) {
            debugging('The module has not been set against the page but we are attempting to generate module specific information for navigation', DEBUG_DEVELOPER);
            return;
        }

        if (empty($this->page->cm->context)) {
            if ($this->context->instanceid === $this->page->cm->id) {
                $this->page->cm->context = $this->context;
            } else {
                $this->page->cm->context = get_context_instance(CONTEXT_MODULE, $this->page->cm->instance);
            }
        }

        $module = $DB->get_record('modules', array('id'=>$this->page->cm->module));
        if (!$module) {
            debugging('Invalid Module ID picked up while attempting to load the activity for the navigation', DEBUG_DEVELOPER);
            return;
        }

        $file = $CFG->dirroot.'/mod/'.$module->name.'/lib.php';
        $function = $module->name.'_extend_settings_navigation';

        if (file_exists($file)) {
            require_once($file);
        }
        if (!function_exists($function)) {
            return;
        }
        return $function($this,$module);
    }

    /**
     * Loads the user settings block of the settings nav
     *
     * This function is simply works out the userid and whether we need to load
     * just the current users profile settings, or the current user and the user the
     * current user is viewing.
     *
     * This function has some very ugly code to work out the user, if anyone has
     * any bright ideas please feel free to intervene.
     *
     * @param int $courseid The course id of the current course
     */
    protected function load_user_settings($courseid=SITEID) {
        global $USER, $FULLME;

        if (isguestuser() || !isloggedin()) {
            return false;
        }

        // This is terribly ugly code, but I couldn't see a better way around it
        // we need to pick up the user id, it can be the current user or someone else
        // and the key depends on the current location
        // Default to look at id
        $userkey='id';
        if ($this->context->contextlevel >= CONTEXT_COURSECAT && strpos($FULLME, '/message/')===false && strpos($FULLME, '/mod/forum/user')===false) {
            // If we have a course context and we are not in message or forum
            // Message and forum both pick the user up from `id`
            $userkey = 'user';
        } else if (strpos($FULLME,'/blog/') || strpos($FULLME, '/roles/')) {
            // And blog and roles just do thier own thing using `userid`
            $userkey = 'userid';
        }

        $userid = optional_param($userkey, $USER->id, PARAM_INT);
        if ($userid!=$USER->id) {
            $this->generate_user_settings($courseid,$userid,'userviewingsettings');
            $this->generate_user_settings($courseid,$USER->id);
        } else {
            $this->generate_user_settings($courseid,$USER->id);
        }
    }

    /**
     * This function gets called by {@link load_user_settings()} and actually works out
     * what can be shown/done
     *
     * @param int $courseid The current course' id
     * @param int $userid The user id to load for
     * @param string $gstitle The string to pass to get_string for the branch title
     * @return string|int The key to reference this user's settings
     */
    protected function generate_user_settings($courseid, $userid, $gstitle='usercurrentsettings') {
        global $DB, $CFG, $USER;

        if (!$course = $DB->get_record("course", array("id"=>$courseid))) {
            return false;
        }

        $coursecontext = get_context_instance(CONTEXT_COURSE, $course->id);   // Course context
        $systemcontext   = get_context_instance(CONTEXT_SYSTEM);
        $currentuser = ($USER->id == $userid);

        if ($currentuser) {
            $user = $USER;
            $usercontext = get_context_instance(CONTEXT_USER, $user->id);       // User context
        } else {
            if (!$user = $DB->get_record('user', array('id'=>$userid))) {
                return false;
            }
            // Check that the user can view the profile
            $usercontext = get_context_instance(CONTEXT_USER, $user->id);       // User context
            if ($course->id==SITEID) {
                if ($CFG->forceloginforprofiles && !isteacherinanycourse() && !isteacherinanycourse($user->id) && !has_capability('moodle/user:viewdetails', $usercontext)) {  // Reduce possibility of "browsing" userbase at site level
                    // Teachers can browse and be browsed at site level. If not forceloginforprofiles, allow access (bug #4366)
                    return false;
                }
            } else {
                if ((!has_capability('moodle/user:viewdetails', $coursecontext) && !has_capability('moodle/user:viewdetails', $usercontext)) || !has_capability('moodle/course:view', $coursecontext, $user->id, false)) {
                    return false;
                }
                if (groups_get_course_groupmode($course) == SEPARATEGROUPS && !has_capability('moodle/site:accessallgroups', $coursecontext)) {
                    // If groups are in use, make sure we can see that group
                    return false;
                }
            }
        }

        $fullname = fullname($user, has_capability('moodle/site:viewfullnames', $this->page->context));

        // Add a user setting branch
        $usersettingskey = $this->add(get_string($gstitle, 'moodle', $fullname));
        $usersetting = $this->get($usersettingskey);
        $usersetting->id = 'usersettings';

        // Check if the user has been deleted
        if ($user->deleted) {
            if (!has_capability('moodle/user:update', $coursecontext)) {
                // We can't edit the user so just show the user deleted message
                $usersetting->add(get_string('userdeleted'), null, self::TYPE_SETTING);
            } else {
                // We can edit the user so show the user deleted message and link it to the profile
                $profileurl = new moodle_url('/user/view.php', array('id'=>$user->id, 'course'=>$course->id));
                $usersetting->add(get_string('userdeleted'), $profileurl, self::TYPE_SETTING);
            }
            return true;
        }

        // Add the profile edit link
        if (isloggedin() && !isguestuser($user) && !is_mnet_remote_user($user)) {
            if (($currentuser || !is_primary_admin($user->id)) && has_capability('moodle/user:update', $systemcontext)) {
                $url = new moodle_url('/user/editadvanced.php', array('id'=>$user->id, 'course'=>$course->id));
                $usersetting->add(get_string('editmyprofile'), $url, self::TYPE_SETTING);
            } else if ((has_capability('moodle/user:editprofile', $usercontext) && !is_primary_admin($user->id)) || ($currentuser && has_capability('moodle/user:editownprofile', $systemcontext))) {
                $url = new moodle_url('/user/edit.php', array('id'=>$user->id, 'course'=>$course->id));
                $usersetting->add(get_string('editmyprofile'), $url, self::TYPE_SETTING);
            }
        }

        // Change password link
        if (!empty($user->auth)) {
            $userauth = get_auth_plugin($user->auth);
            if ($currentuser && !session_is_loggedinas() && $userauth->can_change_password() && !isguestuser() && has_capability('moodle/user:changeownpassword', $systemcontext)) {
                $passwordchangeurl = $userauth->change_password_url();
                if (!$passwordchangeurl) {
                    if (empty($CFG->loginhttps)) {
                        $wwwroot = $CFG->wwwroot;
                    } else {
                        $wwwroot = str_replace('http:', 'https:', $CFG->wwwroot);
                    }
                    $passwordchangeurl = new moodle_url('/login/change_password.php');
                } else {
                    $urlbits = explode($passwordchangeurl. '?', 1);
                    $passwordchangeurl = new moodle_url($urlbits[0]);
                    if (count($urlbits)==2 && preg_match_all('#\&([^\=]*?)\=([^\&]*)#si', '&'.$urlbits[1], $matches)) {
                        foreach ($matches as $pair) {
                            $fullmeurl->param($pair[1],$pair[2]);
                        }
                    }
                }
                $passwordchangeurl->param('id', $course->id);
                $usersetting->add(get_string("changepassword"), $passwordchangeurl, self::TYPE_SETTING);
            }
        }

        // View the roles settings
        if (has_any_capability(array('moodle/role:assign', 'moodle/role:safeoverride','moodle/role:override', 'moodle/role:manage'), $usercontext)) {
            $roleskey = $usersetting->add(get_string('roles'), null, self::TYPE_SETTING);

            $url = new moodle_url('/admin/roles/usersroles.php', array('userid'=>$user->id, 'courseid'=>$course->id));
            $usersetting->get($roleskey)->add(get_string('thisusersroles', 'role'), $url, self::TYPE_SETTING);

            $assignableroles = get_assignable_roles($usercontext, ROLENAME_BOTH);
            $overridableroles = get_overridable_roles($usercontext, ROLENAME_BOTH);

            if (!empty($assignableroles)) {
                $url = new moodle_url('/admin/roles/assign.php', array('contextid'=>$usercontext->id,'userid'=>$user->id, 'courseid'=>$course->id));
                $usersetting->get($roleskey)->add(get_string('assignrolesrelativetothisuser', 'role'), $url, self::TYPE_SETTING);
            }

            if (!empty($overridableroles)) {
                $url = new moodle_url('/admin/roles/override.php', array('contextid'=>$usercontext->id,'userid'=>$user->id, 'courseid'=>$course->id));
                $usersetting->get($roleskey)->add(get_string('overridepermissions', 'role'), $url, self::TYPE_SETTING);
            }

            $url = new moodle_url('/admin/roles/check.php', array('contextid'=>$usercontext->id,'userid'=>$user->id, 'courseid'=>$course->id));
            $usersetting->get($roleskey)->add(get_string('checkpermissions', 'role'), $url, self::TYPE_SETTING);
        }

        // Portfolio
        if ($currentuser && !empty($CFG->enableportfolios) && has_capability('moodle/portfolio:export', $systemcontext)) {
            require_once($CFG->libdir . '/portfoliolib.php');
            if (portfolio_instances(true, false)) {
                $portfoliokey = $usersetting->add(get_string('portfolios', 'portfolio'), null, self::TYPE_SETTING);
                $usersetting->get($portfoliokey)->add(get_string('configure', 'portfolio'), new moodle_url('/user/portfolio.php'), self::TYPE_SETTING);
                $usersetting->get($portfoliokey)->add(get_string('logs', 'portfolio'), new moodle_url('/user/portfoliologs.php'), self::TYPE_SETTING);
            }
        }

        // Security keys
        if ($currentuser && !is_siteadmin($USER->id) && !empty($CFG->enablewebservices) && has_capability('moodle/webservice:createtoken', $systemcontext)) {
            $url = new moodle_url('/user/managetoken.php', array('sesskey'=>sesskey()));
            $usersetting->add(get_string('securitykeys', 'webservice'), $url, self::TYPE_SETTING);
        }

        // Repository
        if (!$currentuser) {
            require_once($CFG->dirroot . '/repository/lib.php');
            $editabletypes = repository::get_editable_types($usercontext);
            if ($usercontext->contextlevel == CONTEXT_USER && !empty($editabletypes)) {
                $url = new moodle_url('/repository/manage_instances.php', array('contextid'=>$usercontext->id));
                $usersetting->add(get_string('repositories', 'repository'), $url, self::TYPE_SETTING);
            }
        }

        // Messaging
        if (has_capability('moodle/user:editownmessageprofile', $systemcontext)) {
            $url = new moodle_url('/message/edit.php', array('id'=>$user->id, 'course'=>$course->id));
            $usersetting->add(get_string('editmymessage', 'message'), $url, self::TYPE_SETTING);
        }

        return $usersettingskey;
    }

    /**
     * Determine whether the user is assuming another role
     *
     * This function checks to see if the user is assuming another role by means of
     * role switching. In doing this we compare each RSW key (context path) against
     * the current context path. This ensures that we can provide the switching
     * options against both the course and any page shown under the course.
     *
     * @return bool|int The role(int) if the user is in another role, false otherwise
     */
    protected function in_alternative_role() {
        global $USER;
        if (!empty($USER->access['rsw']) && is_array($USER->access['rsw'])) {
            if (!empty($this->page->context) && !empty($USER->access['rsw'][$this->page->context->path])) {
                return $USER->access['rsw'][$this->page->context->path];
            }
            foreach ($USER->access['rsw'] as $key=>$role) {
                if (strpos($this->context->path,$key)===0) {
                    return $role;
                }
            }
        }
        return false;
    }

    /**
     * This function loads all of the front page settings into the settings navigation.
     * This function is called when the user is on the front page, or $COURSE==$SITE
     */
    protected function load_front_page_settings() {
        global $CFG, $USER, $OUTPUT, $SITE;

        $course = $SITE;
        if (empty($course->context)) {
            $course->context = get_context_instance(CONTEXT_COURSE, $course->id);   // Course context
        }
        if (has_capability('moodle/course:update', $course->context)) {

            $frontpage = $this->add(get_string('frontpagesettings'), null, self::TYPE_SETTING, null, 'frontpage');
            $this->get($frontpage)->id = 'frontpagesettings';
            $this->get($frontpage)->forceopen = true;

            // Add the turn on/off settings
            $url = new moodle_url('/course/view.php', array('id'=>$course->id, 'sesskey'=>sesskey()));
            if ($this->page->user_is_editing()) {
                $url->param('edit', 'off');
                $editstring = get_string('turneditingoff');
            } else {
                $url->param('edit', 'on');
                $editstring = get_string('turneditingon');
            }
            $this->get($frontpage)->add($editstring, $url, self::TYPE_SETTING, null, null, new pix_icon('i/edit', ''));

            // Add the course settings link
            $url = new moodle_url('/admin/settings.php', array('section'=>'frontpagesettings'));
            $this->get($frontpage)->add(get_string('settings'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/settings', ''));
        }

        //Participants
        if (has_capability('moodle/site:viewparticipants', $course->context)) {
            $url = new moodle_url('/user/index.php?contextid='.$course->context->id);
            $this->get($frontpage)->add(get_string('participants'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/users', ''));
        }
    }


    /**
     * This function removes all root branches that have no children
     */
    public function remove_empty_root_branches() {
        foreach ($this->children as $key=>$node) {
            if ($node->nodetype != self::NODETYPE_BRANCH || count($node->children)===0) {
                $this->remove_child($key);
            }
        }
    }

    /**
     * This function marks the cache as volatile so it is cleared during shutdown
     */
    public function clear_cache() {
        $this->cache->volatile();
    }
}

/**
 * Simple class used to output a navigation branch in XML
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navigation_xml {
    /** @var array */
    protected $nodetype = array('node','branch');
    /** @var array */
    protected $expandable = array();
    /** @var int */
    protected $expansionceiling = array();
    /**
     * Turns a branch and all of its children into XML
     *
     * @param navigation_node $branch
     * @return string XML string
     */
    public function convert($branch) {
        $xml = $this->convert_child($branch);
        return $xml;
    }
    /**
     * Set the expandable items in the array so that we have enough information
     * to attach AJAX events
     */
    public function set_expandable($expandable) {
        foreach ($expandable as $node) {
            $this->expandable[(string)$node['branchid']] = $node;
        }
    }
    /**
     * Sets the upper limit for expandable nodes. Any nodes that are of the specified
     * type or larger will not be expandable
     *
     * @param int $expansionceiling One of navigation_node::TYPE_*
     */
    public function set_expansionceiling($expansionceiling) {
        $tihs->expansionceiling = $expansionceiling;
    }
    /**
     * Recusively converts a child node and its children to XML for output
     *
     * @param navigation_node $child The child to convert
     * @param int $depth Pointlessly used to track the depth of the XML structure
     */
    protected function convert_child($child, $depth=1) {
        global $OUTPUT;

        if (!$child->display) {
            return '';
        }
        $attributes = array();
        $attributes['id'] = $child->id;
        $attributes['type'] = $child->type;
        $attributes['key'] = $child->key;
        $attributes['icon'] = $child->icon;
        $attributes['class'] = $child->get_css_type();
        if ($child->forcetitle || $child->title !== $child->text) {
            $attributes['title'] = htmlentities($child->title);
        }
        if (array_key_exists((string)$child->key, $this->expandable)) {
            $attributes['expandable'] = $child->key;
            $child->add_class($this->expandable[$child->key]['id']);
        } else if ($child->type >= $this->expansionceiling) {
            $attributes['expansionceiling'] = $child->key;
        }

        if (count($child->classes)>0) {
            $attributes['class'] .= ' '.join(' ',$child->classes);
        }
        if (is_string($child->action)) {
            $attributes['link'] = $child->action;
        } else if ($child->action instanceof moodle_url) {
            $attributes['link'] = $child->action->out();
        }
        $attributes['hidden'] = ($child->hidden);
        $attributes['haschildren'] = (count($child->children)>0 || $child->type == navigation_node::TYPE_CATEGORY);

        $xml = '<'.$this->nodetype[$child->nodetype];
        if (count($attributes)>0) {
            foreach ($attributes as $key=>$value) {
                if (is_bool($value)) {
                    if ($value) {
                        $xml .= ' '.$key.'="true"';
                    } else {
                        $xml .= ' '.$key.'="false"';
                    }
                } else if ($value instanceof pix_icon) {
                    $xml .= ' '.$key.'="'.$OUTPUT->pix_url($value->pix, $value->component).'"';
                } else if ($value !== null) {
                    $xml .= ' '.$key.'="'.$value.'"';
                }
            }
        }
        $xml .= '>';
        $xml .= '<name>'.htmlentities($child->text).'</name>';
        if (count($child->children)>0) {
            $xml .= '<children>';
            foreach ($child->children as $subchild) {
                $xml .= $this->convert_child($subchild, $depth+1);
            }
            $xml .= '</children>';
        }
        $xml .= '</'.$this->nodetype[$child->nodetype].'>';
        return $xml;
    }
}

/**
 * The cache class used by global navigation and settings navigation to cache bits
 * and bobs that are used during their generation.
 *
 * It is basically an easy access point to session with a bit of smarts to make
 * sure that the information that is cached is valid still.
 *
 * Example use:
 * <code php>
 * if (!$cache->viewdiscussion()) {
 *     // Code to do stuff and produce cachable content
 *     $cache->viewdiscussion = has_capability('mod/forum:viewdiscussion', $coursecontext);
 * }
 * $content = $cache->viewdiscussion;
 * </code>
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navigation_cache {
    /** @var int */
    protected $creation;
    /** @var array */
    protected $session;
    /** @var string */
    protected $area;
    /** @var int */
    protected $timeout;
    /** @var stdClass */
    protected $currentcontext;
    /** @var int */
    const CACHETIME = 0;
    /** @var int */
    const CACHEUSERID = 1;
    /** @var int */
    const CACHEVALUE = 2;
    /** @var null|array An array of navigation cache areas to expire on shutdown */
    public static $volatilecaches;

    /**
     * Contructor for the cache. Requires two arguments
     *
     * @param string $area The string to use to segregate this particular cache
     *                it can either be unique to start a fresh cache or if you want
     *                to share a cache then make it the string used in the original
     *                cache
     * @param int $timeout The number of seconds to time the information out after
     */
    public function __construct($area, $timeout=60) {
        global $SESSION, $PAGE;
        $this->creation = time();
        $this->area = $area;

        if (!isset($SESSION->navcache)) {
            $SESSION->navcache = new stdClass;
        }

        if (!isset($SESSION->navcache->{$area})) {
            $SESSION->navcache->{$area} = array();
        }
        $this->session = &$SESSION->navcache->{$area};
        $this->timeout = time()-$timeout;
        if (rand(0,10)===0) {
            $this->garbage_collection();
        }
    }

    /**
     * Magic Method to retrieve something by simply calling using = cache->key
     *
     * @param mixed $key The identifier for the information you want out again
     * @return void|mixed Either void or what ever was put in
     */
    public function __get($key) {
        if (!$this->cached($key)) {
            return;
        }
        $information = $this->session[$key][self::CACHEVALUE];
        return unserialize($information);
    }

    /**
     * Magic method that simply uses {@link set();} to store something in the cache
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function __set($key, $information) {
        $this->set($key, $information);
    }

    /**
     * Sets some information against the cache (session) for later retrieval
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function set($key, $information) {
        global $USER;
        $information = serialize($information);
        $this->session[$key]= array(self::CACHETIME=>time(), self::CACHEUSERID=>$USER->id, self::CACHEVALUE=>$information);
    }
    /**
     * Check the existence of the identifier in the cache
     *
     * @param string|int $key
     * @return bool
     */
    public function cached($key) {
        global $USER;
        if (!array_key_exists($key, $this->session) || !is_array($this->session[$key]) || $this->session[$key][self::CACHEUSERID]!=$USER->id || $this->session[$key][self::CACHETIME] < $this->timeout) {
            return false;
        }
        return true;
    }
    /**
     * Compare something to it's equivilant in the cache
     *
     * @param string $key
     * @param mixed $value
     * @param bool $serialise Whether to serialise the value before comparison
     *              this should only be set to false if the value is already
     *              serialised
     * @return bool If the value is the same false if it is not set or doesn't match
     */
    public function compare($key, $value, $serialise=true) {
        if ($this->cached($key)) {
            if ($serialise) {
                $value = serialize($value);
            }
            if ($this->session[$key][self::CACHEVALUE] === $value) {
                return true;
            }
        }
        return false;
    }
    /**
     * Wipes the entire cache, good to force regeneration
     */
    public function clear() {
        $this->session = array();
    }
    /**
     * Checks all cache entries and removes any that have expired, good ole cleanup
     */
    protected function garbage_collection() {
        foreach ($this->session as $key=>$cachedinfo) {
            if (is_array($cachedinfo) && $cachedinfo[self::CACHETIME]<$this->timeout) {
                unset($this->session[$key]);
            }
        }
    }

    /**
     * Marks the cache as being volatile (likely to change)
     *
     * Any caches marked as volatile will be destroyed at the on shutdown by
     * {@link navigation_node::destroy_volatile_caches()} which is registered
     * as a shutdown function if any caches are marked as volatile.
     *
     * @param bool $setting True to destroy the cache false not too
     */
    public function volatile($setting = true) {
        if (self::$volatilecaches===null) {
            self::$volatilecaches = array();
            register_shutdown_function(array('navigation_cache','destroy_volatile_caches'));
        }

        if ($setting) {
            self::$volatilecaches[$this->area] = $this->area;
        } else if (array_key_exists($this->area, self::$volatilecaches)) {
            unset(self::$volatilecaches[$this->area]);
        }
    }

    /**
     * Destroys all caches marked as volatile
     *
     * This function is static and works in conjunction with the static volatilecaches
     * property of navigation cache.
     * Because this function is static it manually resets the cached areas back to an
     * empty array.
     */
    public static function destroy_volatile_caches() {
        global $SESSION;
        if (is_array(self::$volatilecaches) && count(self::$volatilecaches)>0) {
            foreach (self::$volatilecaches as $area) {
                $SESSION->navcache->{$area} = array();
            }
        }
    }
}||||||||    protected function load_activity($instanceid) {
        global $CFG, $PAGE;

        $this->context = get_context_instance(CONTEXT_COURSE, $PAGE->course->id);
        $key = $this->add($PAGE->activityname, null, self::TYPE_ACTIVITY, null, $instanceid);

        $file = $CFG->dirroot.'/mod/'.$PAGE->activityname.'/lib.php';
        $function = $PAGE->activityname.'_extend_navigation';

        if (file_exists($file)) {
            require_once($file);
            if (function_exists($function)) {
                $function($this->get($key), $PAGE->course, $PAGE->activityrecord, $PAGE->cm);
            }
        }
    }
}

/**
 * Navbar class
 *
 * This class is used to manage the navbar, which is initialised from the navigation
 * object held by PAGE
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navbar extends navigation_node {
    /** @var bool */
    protected $initialised = false;
    /** @var mixed */
    protected $keys = array();
    /** @var null|string */
    protected $content = null;
    /** @var page object */
    protected $page;
    /** @var bool */
    protected $ignoreactive = false;
    /** @var bool */
    protected $duringinstall = false;
    /** @var bool */
    protected $hasitems = false;

    /**
     * The almighty constructor
     */
    public function __construct(&$page) {
        global $CFG;
        if (during_initial_install()) {
            $this->duringinstall = true;
            return false;
        }
        $this->page = $page;
        $this->text = get_string('home');
        $this->shorttext = get_string('home');
        $this->action = new moodle_url($CFG->wwwroot);
        $this->nodetype = self::NODETYPE_BRANCH;
        $this->type = self::TYPE_SYSTEM;
    }

    /**
     * Quick check to see if the navbar will have items in.
     *
     * @return bool Returns true if the navbar will have items, false otherwise
     */
    public function has_items() {
        if ($this->duringinstall) {
            return false;
        } else if ($this->hasitems !== false) {
            return true;
        }
        $this->page->navigation->initialise();

        $activenodefound = ($this->page->navigation->contains_active_node() ||
                            $this->page->settingsnav->contains_active_node() ||
                            $this->page->navigation->reiterate_active_nodes(URL_MATCH_BASE) ||
                            $this->page->settingsnav->reiterate_active_nodes(URL_MATCH_BASE));

        $outcome = (count($this->page->navbar->children)>0 || (!$this->ignoreactive && $activenodefound));
        $this->hasitems = $outcome;
        return $outcome;
    }

    public function ignore_active($setting=true) {
        $this->ignoreactive = ($setting);
    }

    /**
     * Generate the XHTML content for the navbar and return it
     *
     * We are lucky in that we can rely on PAGE->navigation for the structure
     * we simply need to look for the `active` path through the tree. We make this
     * easier by calling {@link strip_down_to_final_active()}.
     *
     * This function should in the future be refactored to work with a copy of the
     * PAGE->navigation object and strip it down to just this the active nodes using
     * a function that could be written again navigation_node called something like
     * strip_inactive_nodes(). I wrote this originally but currently the navigation
     * object is managed via references.
     *
     * @return string XHTML navbar content
     */
    public function content() {
        if ($this->duringinstall) {
            return '';
        }

        // Make sure that navigation is initialised
        if (!$this->has_items()) {
            return '';
        }

        if ($this->content !== null) {
            return $this->content;
        }

        // For screen readers
        $output = get_accesshide(get_string('youarehere','access'), 'h2').html_writer::start_tag('ul');

        // Check if navigation contains the active node
        if (!$this->ignoreactive && $this->page->navigation->contains_active_node()) {
            // Parse the navigation tree to get the active node
            $output .= $this->parse_branch_to_html($this->page->navigation->children, true);
        } else if (!$this->ignoreactive && $this->page->settingsnav->contains_active_node()) {
            // Parse the settings navigation to get the active node
            $output .= $this->parse_branch_to_html($this->page->settingsnav->children, true);
        } else {
            $output .= $this->parse_branch_to_html($this, true);
        }
        $output .= html_writer::end_tag('ul');
        $this->content = $output;
        return $output;
    }
    /**
     * This function converts an array of nodes into XHTML for the navbar
     *
     * @param array $navarray
     * @param bool $firstnode
     * @return string HTML
     */
    protected function parse_branch_to_html($navarray, $firstnode=true) {
        global $CFG;
        $separator = get_separator();
        $output = '';
        if ($firstnode===true) {
            // If this is the first node add the class first and display the
            // navbar properties (normally sitename)
            $output .= html_writer::tag('li', array('class'=>'first'), parent::content(true));
        }
        $count = 0;
        if (!is_array($navarray)) {
            return $output;
        }
        // Iterate the navarray and display each node
        while (count($navarray)>0) {
            // Sanity check make sure we don't display WAY too much information
            // on the navbar. If we get to 20 items just stop!
            $count++;
            if ($count>20) {
                // Maximum number of nodes in the navigation branch
                return $output;
            }
            $child = false;
            // Iterate the nodes in navarray and find the active node
            foreach ($navarray as $tempchild) {
                if ($tempchild->isactive || $tempchild->contains_active_node()) {
                    $child = $tempchild;
                    // We've got the first child we can break out of this foreach
                    break;
                }
            }
            // Check if we found the child
            if ($child===false || $child->mainnavonly) {
                // Set navarray to an empty array so that we complete the while
                $navarray = array();
            } else {
                // We found an/the active node, set navarray to it's children so that
                // we come back through this while with the children of the active node
                $navarray = $child->children;
                // If there are not more arrays being processed after this AND this is the last element
                // then we want to set the action to null so that it is not used
                if (empty($this->children) && (!$child->contains_active_node() || ($child->find_active_node()==false || $child->find_active_node()->mainnavonly))) {
                    $oldaction = $child->action;
                    $child->action = null;
                }
                if ($child->type !== navigation_node::TYPE_CATEGORY || !isset($CFG->navshowcategories) || !empty($CFG->navshowcategories)) {
                    // Now display the node
                    $output .= html_writer::tag('li', null, $separator.' '.$child->content(true));
                }
                if (isset($oldaction)) {
                    $child->action = $oldaction;
                }
            }
        }

        if (!empty($this->children)) {
            // Add the custom children
            $output .= $this->parse_branch_to_html($this->children, false, false);
        }

        // XHTML
        return $output;
    }
    /**
     * Add a new node to the navbar, overrides parent::add
     *
     * This function overrides {@link navigation_node::add()} so that we can change
     * the way nodes get added to allow us to simply call add and have the node added to the
     * end of the navbar
     *
     * @param string $text
     * @param string|moodle_url $action
     * @param int $type
     * @param string|int $key
     * @param string $shorttext
     * @param string $icon
     * @return string|int Identifier for this particular node
     */
    public function add($text, $action=null, $type=self::TYPE_CUSTOM, $shorttext=null, $key=null, pix_icon $icon=null) {
        // Check if there are any keys in the objects keys array
        if (count($this->keys)===0) {
            // If there are no keys then we can use the add method
            $key = parent::add($text, $action, $type, $shorttext, $key, $icon);
        } else {
            $key = $this->add_to_path($this->keys, $key, $text, $shorttext, $type, $action, $icon);
        }
        $this->keys[] = $key;
        $child = $this->get_by_path($this->keys);
        if ($child!==false) {
            // This ensure that the child will be shown
            $child->make_active();
        }
        return $key;
    }
}

/**
 * Class used to manage the settings option for the current page
 *
 * This class is used to manage the settings options in a tree format (recursively)
 * and was created initially for use with the settings blocks.
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class settings_navigation extends navigation_node {
    /** @var stdClass */
    protected $context;
    /** @var cache */
    protected $cache;
    /** @var page object */
    protected $page;
    /**
     * Sets up the object with basic settings and preparse it for use
     */
    public function __construct(moodle_page &$page) {
        if (during_initial_install()) {
            return false;
        }
        $this->page = $page;
        // Initialise the main navigation. It is most important that this is done
        // before we try anything
        $this->page->navigation->initialise();
        // Initialise the navigation cache
        $this->cache = new navigation_cache(NAVIGATION_CACHE_NAME);
    }
    /**
     * Initialise the settings navigation based on the current context
     *
     * This function initialises the settings navigation tree for a given context
     * by calling supporting functions to generate major parts of the tree.
     */
    public function initialise() {
        if (during_initial_install()) {
            return false;
        }
        $this->id = 'settingsnav';
        $this->context = $this->page->context;
        switch ($this->context->contextlevel) {
            case CONTEXT_SYSTEM:
                $this->cache->volatile();
                $adminkey = $this->load_administration_settings();
                $settingskey = $this->load_user_settings(SITEID);
                break;
            case CONTEXT_COURSECAT:
                $adminkey = $this->load_administration_settings();
                $adminnode = $this->get($adminkey);
                if ($adminnode!==false) {
                    $adminnode->forceopen =  true;
                }
                $settingskey = $this->load_user_settings(SITEID);
                break;
            case CONTEXT_COURSE:
                if ($this->page->course->id!==SITEID) {
                    $coursekey = $this->load_course_settings();
                    $coursenode = $this->get($coursekey);
                    if ($coursenode!==false) {
                        $coursenode->forceopen =  true;
                    }
                    $settingskey = $this->load_user_settings($this->page->course->id);
                    $adminkey = $this->load_administration_settings();
                } else {
                    $this->load_front_page_settings();
                    $settingskey = $this->load_user_settings(SITEID);
                    $adminkey = $this->load_administration_settings();
                }
                break;
            case CONTEXT_MODULE:
                $modulekey = $this->load_module_settings();
                $modulenode = $this->get($modulekey);
                if ($modulenode!==false) {
                    $modulenode->forceopen =  true;
                }
                $coursekey = $this->load_course_settings();
                $settingskey = $this->load_user_settings($this->page->course->id);
                $adminkey = $this->load_administration_settings();
                break;
            case CONTEXT_USER:
                $settingskey = $this->load_user_settings($this->page->course->id);
                $settingsnode = $this->get($settingskey);
                if ($settingsnode!==false) {
                    $settingsnode->forceopen =  true;
                }
                if ($this->page->course->id!==SITEID) {
                    $coursekey = $this->load_course_settings();
                }
                $adminkey = $this->load_administration_settings();
                break;
            default:
                debugging('An unknown context has passed into settings_navigation::initialise', DEBUG_DEVELOPER);
                break;
        }

        // Check if the user is currently logged in as another user
        if (session_is_loggedinas()) {
            // Get the actual user, we need this so we can display an informative return link
            $realuser = session_get_realuser();
            // Add the informative return to original user link
            $url = new moodle_url('/course/loginas.php',array('id'=>$this->page->course->id, 'return'=>1,'sesskey'=>sesskey()));
            $this->add(get_string('returntooriginaluser', 'moodle', fullname($realuser, true)), $url, self::TYPE_SETTING, null, null, new pix_icon('t/left', ''));
        }

        // Make sure the first child doesnt have proceed with hr set to true
        reset($this->children);
        current($this->children)->preceedwithhr = false;

        $this->remove_empty_root_branches();
        $this->respect_forced_open();
    }
    /**
     * Override the parent function so that we can add preceeding hr's and set a
     * root node class against all first level element
     *
     * It does this by first calling the parent's add method {@link navigation_node::add()}
     * and then proceeds to use the key to set class and hr
     *
     * @param string $text
     * @param sting|moodle_url $url
     * @param string $shorttext
     * @param string|int $key
     * @param int $type
     * @param string $icon
     * @return sting|int A key that can be used to reference the newly added node
     */
    public function add($text, $url=null, $type=null, $shorttext=null, $key=null, pix_icon $icon=null) {
        $key = parent::add($text, $url, $type, $shorttext, $key, $icon);
        $this->get($key)->add_class('root_node');
        $this->get($key)->preceedwithhr = true;
        return $key;
    }

    /**
     * This function allows the user to add something to the start of the settings
     * navigation, which means it will be at the top of the settings navigation block
     *
     * @param string $text
     * @param sting|moodle_url $url
     * @param string $shorttext
     * @param string|int $key
     * @param int $type
     * @param string $icon
     * @return sting|int A key that can be used to reference the newly added node
     */
    public function prepend($text, $url=null, $type=null, $shorttext=null, $key=null, pix_icon $icon=null) {
        $key = $this->add($text, $url, $type, $shorttext, $key, $icon);
        $children = $this->children;
        $this->children = array();
        $this->children[$key] = array_pop($children);
        foreach ($children as $k=>$child) {
            $this->children[$k] = $child;
            $this->get($k)->add_class('root_node');
            $this->get($k)->preceedwithhr = true;
        }
        return $key;
    }
    /**
     * Load the site administration tree
     *
     * This function loads the site administration tree by using the lib/adminlib library functions
     *
     * @param null|navigation_node $referencebranch A reference to a branch in the settings
     *      navigation tree
     * @param null|part_of_admin_tree $adminbranch The branch to add, if null generate the admin
     *      tree and start at the beginning
     * @return mixed A key to access the admin tree by
     */
    protected function load_administration_settings(navigation_node $referencebranch=null, part_of_admin_tree $adminbranch=null) {
        global $CFG;

        // Check if we are just starting to generate this navigation.
        if ($referencebranch === null) {

            if (!function_exists('admin_get_root')) {
                require_once($CFG->dirroot.'/lib/adminlib.php');
            }
            $adminroot = admin_get_root(false, false);
            $branchkey = $this->add(get_string('administrationsite'), null, self::TYPE_SETTING);
            $referencebranch = $this->get($branchkey);
            foreach ($adminroot->children as $adminbranch) {
                $this->load_administration_settings($referencebranch, $adminbranch);
            }

            if (!$this->contains_active_node()) {
                $section = $this->page->url->param('section');
                if ($current = $adminroot->locate($section, true)) {
                    if ($child = $this->find_child($current->name, self::TYPE_SETTING)) {
                        $child->make_active();
                    }
                }
            }

            return $branchkey;
        } else if ($adminbranch->check_access()) {
            // We have a reference branch that we can access and is not hidden `hurrah`
            // Now we need to display it and any children it may have
            $url = null;
            $icon = null;
            if ($adminbranch instanceof admin_settingpage) {
                $url = new moodle_url('/admin/settings.php', array('section'=>$adminbranch->name));
            } else if ($adminbranch instanceof admin_externalpage) {
                $url = $adminbranch->url;
            }

            // Add the branch
            $branchkey = $referencebranch->add($adminbranch->visiblename, $url, self::TYPE_SETTING, null, $adminbranch->name, $icon);
            $reference = $referencebranch->get($branchkey);

            if ($adminbranch->is_hidden()) {
                $reference->display = false;
            }

            // Check if we are generating the admin notifications and whether notificiations exist
            if ($adminbranch->name === 'adminnotifications' && admin_critical_warnings_present()) {
                $reference->add_class('criticalnotification');
            }
            // Check if this branch has children
            if ($reference && isset($adminbranch->children) && is_array($adminbranch->children) && count($adminbranch->children)>0) {
                foreach ($adminbranch->children as $branch) {
                    // Generate the child branches as well now using this branch as the reference
                    $this->load_administration_settings($reference, $branch);
                }
            } else {
                $reference->icon = new pix_icon('i/settings', '');
            }
        }
    }

    /**
     * Generate the list of modules for the given course.
     *
     * The array of resources and activities that can be added to a course is then
     * stored in the cache so that we can access it for anywhere.
     * It saves us generating it all the time
     *
     * <code php>
     * // To get resources:
     * $this->cache->{'course'.$courseid.'resources'}
     * // To get activities:
     * $this->cache->{'course'.$courseid.'activities'}
     * </code>
     *
     * @param stdClass $course The course to get modules for
     */
    protected function get_course_modules($course) {
        global $CFG;
        $mods = $modnames = $modnamesplural = $modnamesused = array();
        // This function is included when we include course/lib.php at the top
        // of this file
        get_all_mods($course->id, $mods, $modnames, $modnamesplural, $modnamesused);
        $resources = array();
        $activities = array();
        foreach($modnames as $modname=>$modnamestr) {
            if (!course_allowed_module($course, $modname)) {
                continue;
            }

            $libfile = "$CFG->dirroot/mod/$modname/lib.php";
            if (!file_exists($libfile)) {
                continue;
            }
            include_once($libfile);
            $gettypesfunc =  $modname.'_get_types';
            if (function_exists($gettypesfunc)) {
                $types = $gettypesfunc();
                foreach($types as $type) {
                    if (!isset($type->modclass) || !isset($type->typestr)) {
                        debugging('Incorrect activity type in '.$modname);
                        continue;
                    }
                    if ($type->modclass == MOD_CLASS_RESOURCE) {
                        $resources[html_entity_decode($type->type)] = $type->typestr;
                    } else {
                        $activities[html_entity_decode($type->type)] = $type->typestr;
                    }
                }
            } else {
                $archetype = plugin_supports('mod', $modname, FEATURE_MOD_ARCHETYPE, MOD_ARCHETYPE_OTHER);
                if ($archetype == MOD_ARCHETYPE_RESOURCE) {
                    $resources[$modname] = $modnamestr;
                } else {
                    // all other archetypes are considered activity
                    $activities[$modname] = $modnamestr;
                }
            }
        }
        $this->cache->{'course'.$course->id.'resources'} = $resources;
        $this->cache->{'course'.$course->id.'activities'} = $activities;
    }

    /**
     * This function loads the course settings that are available for the user
     *
     * @return bool|mixed Either false of a key to access the course tree by
     */
    protected function load_course_settings() {
        global $CFG, $USER, $SESSION;

        $course = $this->page->course;
        if (empty($course->context)) {
            if (!$this->cache->cached('coursecontext'.$course->id)) {
                $this->cache->{'coursecontext'.$course->id} = get_context_instance(CONTEXT_COURSE, $course->id);   // Course context
            }
            $course->context = $this->cache->{'coursecontext'.$course->id};
        }
        if (!$this->cache->cached('canviewcourse'.$course->id)) {
            $this->cache->{'canviewcourse'.$course->id} = has_capability('moodle/course:view', $course->context);
        }
        if ($course->id === SITEID || !$this->cache->{'canviewcourse'.$course->id}) {
            return false;
        }

        $coursenode = $this->page->navigation->find_child($course->id, global_navigation::TYPE_COURSE);

        $coursenodekey = $this->add(get_string('courseadministration'), null, $coursenode->type, null, 'courseadmin');
        $coursenode = $this->get($coursenodekey);

        if (has_capability('moodle/course:update', $course->context)) {
            // Add the turn on/off settings
            $url = new moodle_url('/course/view.php', array('id'=>$course->id, 'sesskey'=>sesskey()));
            if ($this->page->user_is_editing()) {
                $url->param('edit', 'off');
                $editstring = get_string('turneditingoff');
            } else {
                $url->param('edit', 'on');
                $editstring = get_string('turneditingon');
            }
            $coursenode->add($editstring, $url, self::TYPE_SETTING, null, null, new pix_icon('i/edit', ''));

            if ($this->page->user_is_editing()) {
                // Add `add` resources|activities branches
                $structurefile = $CFG->dirroot.'/course/format/'.$course->format.'/lib.php';
                if (file_exists($structurefile)) {
                    require_once($structurefile);
                    $formatstring = call_user_func('callback_'.$course->format.'_definition');
                    $formatidentifier = optional_param(call_user_func('callback_'.$course->format.'_request_key'), 0, PARAM_INT);
                } else {
                    $formatstring = get_string('topic');
                    $formatidentifier = optional_param('topic', 0, PARAM_INT);
                }
                if (!$this->cache->cached('coursesections'.$course->id)) {
                    $this->cache->{'coursesections'.$course->id} = get_all_sections($course->id);
                }
                $sections = $this->cache->{'coursesections'.$course->id};

                $addresource = $this->get($this->add(get_string('addresource')));
                $addactivity = $this->get($this->add(get_string('addactivity')));
                if ($formatidentifier!==0) {
                    $addresource->forceopen = true;
                    $addactivity->forceopen = true;
                }

                if (!$this->cache->cached('course'.$course->id.'resources')) {
                    $this->get_course_modules($course);
                }
                $resources = $this->cache->{'course'.$course->id.'resources'};
                $activities = $this->cache->{'course'.$course->id.'activities'};

                $textlib = textlib_get_instance();

                foreach ($sections as $section) {
                    if ($formatidentifier !== 0 && $section->section != $formatidentifier) {
                        continue;
                    }
                    $sectionurl = new moodle_url('/course/view.php', array('id'=>$course->id, $formatstring=>$section->section));
                    if ($section->section == 0) {
                        $sectionresources = $addresource->add(get_string('course'), $sectionurl, self::TYPE_SETTING);
                        $sectionactivities = $addactivity->add(get_string('course'), $sectionurl, self::TYPE_SETTING);
                    } else {
                        $sectionresources = $addresource->add($formatstring.' '.$section->section, $sectionurl, self::TYPE_SETTING);
                        $sectionactivities = $addactivity->add($formatstring.' '.$section->section, $sectionurl, self::TYPE_SETTING);
                    }
                    foreach ($resources as $value=>$resource) {
                        $url = new moodle_url('/course/mod.php', array('id'=>$course->id, 'sesskey'=>sesskey(), 'section'=>$section->section));
                        $pos = strpos($value, '&type=');
                        if ($pos!==false) {
                            $url->param('add', $textlib->substr($value, 0,$pos));
                            $url->param('type', $textlib->substr($value, $pos+6));
                        } else {
                            $url->param('add', $value);
                        }
                        $addresource->get($sectionresources)->add($resource, $url, self::TYPE_SETTING);
                    }
                    $subbranch = false;
                    foreach ($activities as $activityname=>$activity) {
                        if ($activity==='--') {
                            $subbranch = false;
                            continue;
                        }
                        if (strpos($activity, '--')===0) {
                            $subbranch = $addactivity->get($sectionactivities)->add(trim($activity, '-'));
                            continue;
                        }
                        $url = new moodle_url('/course/mod.php', array('id'=>$course->id, 'sesskey'=>sesskey(), 'section'=>$section->section));
                        $pos = strpos($activityname, '&type=');
                        if ($pos!==false) {
                            $url->param('add', $textlib->substr($activityname, 0,$pos));
                            $url->param('type', $textlib->substr($activityname, $pos+6));
                        } else {
                            $url->param('add', $activityname);
                        }
                        if ($subbranch !== false) {
                            $addactivity->get($sectionactivities)->get($subbranch)->add($activity, $url, self::TYPE_SETTING);
                        } else {
                            $addactivity->get($sectionactivities)->add($activity, $url, self::TYPE_SETTING);
                        }
                    }
                }
            }

            // Add the course settings link
            $url = new moodle_url('/course/edit.php', array('id'=>$course->id));
            $coursenode->add(get_string('settings'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/settings', ''));
        }

        // Add assign or override roles if allowed
        if (has_capability('moodle/role:assign', $course->context)) {
            $url = new moodle_url('/admin/roles/assign.php', array('contextid'=>$course->context->id));
            $coursenode->add(get_string('assignroles', 'role'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/roles', ''));
        } else if (get_overridable_roles($course->context, ROLENAME_ORIGINAL)) {
            $url = new moodle_url('/admin/roles/override.php', array('contextid'=>$course->context->id));
            $coursenode->add(get_string('overridepermissions', 'role'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/roles', ''));
        }

        // Add view grade report is permitted
        $reportavailable = false;
        if (has_capability('moodle/grade:viewall', $course->context)) {
            $reportavailable = true;
        } else if (!empty($course->showgrades)) {
            $reports = get_plugin_list('gradereport');
            if (is_array($reports) && count($reports)>0) {     // Get all installed reports
                arsort($reports); // user is last, we want to test it first
                foreach ($reports as $plugin => $plugindir) {
                    if (has_capability('gradereport/'.$plugin.':view', $course->context)) {
                        //stop when the first visible plugin is found
                        $reportavailable = true;
                        break;
                    }
                }
            }
        }
        if ($reportavailable) {
            $url = new moodle_url('/grade/report/index.php', array('id'=>$course->id));
            $coursenode->add(get_string('grades'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/grades', ''));
        }

        //  Add outcome if permitted
        if (!empty($CFG->enableoutcomes) && has_capability('moodle/course:update', $course->context)) {
            $url = new moodle_url('/grade/edit/outcome/course.php', array('id'=>$course->id));
            $coursenode->add(get_string('outcomes', 'grades'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/outcomes', ''));
        }

        // Add meta course links
        if ($course->metacourse) {
            if (has_capability('moodle/course:managemetacourse', $course->context)) {
                $url = new moodle_url('/course/importstudents.php', array('id'=>$course->id));
                $coursenode->add(get_string('childcourses'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/course', ''));
            } else if (has_capability('moodle/role:assign', $course->context)) {
                $key = $coursenode->add(get_string('childcourses'), null,  self::TYPE_SETTING, null, null, new pix_icon('i/course', ''));
                $coursenode->get($key)->hidden = true;;
            }
        }

        // Manage groups in this course
        if (($course->groupmode || !$course->groupmodeforce) && has_capability('moodle/course:managegroups', $course->context)) {
            $url = new moodle_url('/group/index.php', array('id'=>$course->id));
            $coursenode->add(get_string('groups'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/group', ''));
        }

        // Backup this course
        if (has_capability('moodle/site:backup', $course->context)) {
            $url = new moodle_url('/backup/backup.php', array('id'=>$course->id));
            $coursenode->add(get_string('backup'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/backup', ''));
        }

        // Restore to this course
        if (has_capability('moodle/site:restore', $course->context)) {
            $url = new moodle_url('/files/index.php', array('id'=>$course->id, 'wdir'=>'/backupdata'));
            $coursenode->add(get_string('restore'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/restore', ''));
        }

        // Import data from other courses
        if (has_capability('moodle/site:import', $course->context)) {
            $url = new moodle_url('/course/import.php', array('id'=>$course->id));
            $coursenode->add(get_string('import'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/restore', ''));
        }

        // Reset this course
        if (has_capability('moodle/course:reset', $course->context)) {
            $url = new moodle_url('/course/reset.php', array('id'=>$course->id));
            $coursenode->add(get_string('reset'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/return', ''));
        }

        // Manage questions
        $questioncaps = array('moodle/question:add',
                              'moodle/question:editmine',
                              'moodle/question:editall',
                              'moodle/question:viewmine',
                              'moodle/question:viewall',
                              'moodle/question:movemine',
                              'moodle/question:moveall');
        if (has_any_capability($questioncaps, $this->context)) {
            $questionlink = $CFG->wwwroot.'/question/edit.php';
        } else if (has_capability('moodle/question:managecategory', $this->context)) {
            $questionlink = $CFG->wwwroot.'/question/category.php';
        }
        if (isset($questionlink)) {
            $url = new moodle_url($questionlink, array('courseid'=>$course->id));
            $coursenode->add(get_string('questions','quiz'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/questions', ''));
        }

        // Repository Instances
        require_once($CFG->dirroot.'/repository/lib.php');
        $editabletypes = repository::get_editable_types($this->context);
        if (has_capability('moodle/course:update', $this->context) && !empty($editabletypes)) {
            $url = new moodle_url('/repository/manage_instances.php', array('contextid'=>$this->context->id));
            $coursenode->add(get_string('repositories'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/repository', ''));
        }

        // Manage files
        if (has_capability('moodle/course:managefiles', $this->context)) {
            $url = new moodle_url('/files/index.php', array('id'=>$course->id));
            $coursenode->add(get_string('files'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/files', ''));
        }

        // Authorize hooks
        if ($course->enrol == 'authorize' || (empty($course->enrol) && $CFG->enrol == 'authorize')) {
            require_once($CFG->dirroot.'/enrol/authorize/const.php');
            $url = new moodle_url('/enrol/authorize/index.php', array('course'=>$course->id));
            $coursenode->add(get_string('payments'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/payment', ''));
            if (has_capability('enrol/authorize:managepayments', $this->page->context)) {
                $cnt = $DB->count_records('enrol_authorize', array('status'=>AN_STATUS_AUTH, 'courseid'=>$course->id));
                if ($cnt) {
                    $url = new moodle_url('/enrol/authorize/index.php', array('course'=>$course->id,'status'=>AN_STATUS_AUTH));
                    $coursenode->add(get_string('paymentpending', 'moodle', $cnt), $url, self::TYPE_SETTING, null, null, new pix_icon('i/payment', ''));
                }
            }
        }

        // Unenrol link
        if (empty($course->metacourse)) {
            if (has_capability('moodle/legacy:guest', $this->context, NULL, false)) {   // Are a guest now
                $url = new moodle_url('/course/enrol.php', array('id'=>$course->id));
                $coursenode->add(get_string('enrolme', '', format_string($course->shortname)), $url, self::TYPE_SETTING, null, null, new pix_icon('i/user', ''));
            } else if (has_capability('moodle/role:unassignself', $this->context, NULL, false) && get_user_roles($this->context, 0, false)) {  // Have some role
                $url = new moodle_url('/course/unenrol.php', array('id'=>$course->id));
                $coursenode->add(get_string('unenrolme', '', format_string($course->shortname)), $url, self::TYPE_SETTING, null, null, new pix_icon('i/user', ''));
            }
        }

        // Link to the user own profile (except guests)
        if (!isguestuser() and isloggedin()) {
            $url = new moodle_url('/user/view.php', array('id'=>$USER->id, 'course'=>$course->id));
            $coursenode->add(get_string('profile'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/user', ''));
        }

        // Switch roles
        $roles = array();
        $assumedrole = $this->in_alternative_role();
        if ($assumedrole!==false) {
            $roles[0] = get_string('switchrolereturn');
        }
        if (has_capability('moodle/role:switchroles', $this->context)) {
            $availableroles = get_switchable_roles($this->context);
            if (is_array($availableroles)) {
                foreach ($availableroles as $key=>$role) {
                    if ($key == $CFG->guestroleid || $assumedrole===(int)$key) {
                        continue;
                    }
                    $roles[$key] = $role;
                }
            }
        }
        if (is_array($roles) && count($roles)>0) {
            $switchroleskey = $this->add(get_string('switchroleto'));
            if ((count($roles)==1 && array_key_exists(0, $roles))|| $assumedrole!==false) {
                $this->get($switchroleskey)->forceopen = true;
            }
            $returnurl = $this->page->url;
            $returnurl->param('sesskey', sesskey());
            $SESSION->returnurl = serialize($returnurl);
            foreach ($roles as $key=>$name) {
                $url = new moodle_url('/course/switchrole.php', array('id'=>$course->id,'sesskey'=>sesskey(), 'switchrole'=>$key, 'returnurl'=>'1'));
                $this->get($switchroleskey)->add($name, $url, self::TYPE_SETTING, null, $key, new pix_icon('i/roles', ''));
            }
        }
        // Return we are done
        return $coursenodekey;
    }

    /**
     * This function calls the module function to inject module settings into the
     * settings navigation tree.
     *
     * This only gets called if there is a corrosponding function in the modules
     * lib file.
     *
     * For examples mod/forum/lib.php ::: forum_extend_settings_navigation()
     *
     * @return void|mixed The key to access the module method by
     */
    protected function load_module_settings() {
        global $CFG;

        if (!$this->page->cm && $this->context->contextlevel == CONTEXT_MODULE && $this->context->instanceid) {
            $cm = get_coursemodule_from_id('chat', $this->context->instanceid, 0, false, MUST_EXIST);
            $cm->context = $this->context;
            $this->page->set_cm($cm, $this->page->course);
        }

        if (empty($this->page->cm->context)) {
            if ($this->context->instanceid === $this->page->cm->id) {
                $this->page->cm->context = $this->context;
            } else {
                $this->page->cm->context = get_context_instance(CONTEXT_MODULE, $this->page->cm->instance);
            }
        }

        $file = $CFG->dirroot.'/mod/'.$this->page->activityname.'/lib.php';
        $function = $this->page->activityname.'_extend_settings_navigation';

        if (file_exists($file)) {
            require_once($file);
        }
        if (!function_exists($function)) {
            return;
        }
        return $function($this,$this->page->activityrecord);
    }

    /**
     * Loads the user settings block of the settings nav
     *
     * This function is simply works out the userid and whether we need to load
     * just the current users profile settings, or the current user and the user the
     * current user is viewing.
     *
     * This function has some very ugly code to work out the user, if anyone has
     * any bright ideas please feel free to intervene.
     *
     * @param int $courseid The course id of the current course
     */
    protected function load_user_settings($courseid=SITEID) {
        global $USER, $FULLME;

        if (isguestuser() || !isloggedin()) {
            return false;
        }

        // This is terribly ugly code, but I couldn't see a better way around it
        // we need to pick up the user id, it can be the current user or someone else
        // and the key depends on the current location
        // Default to look at id
        $userkey='id';
        if ($this->context->contextlevel >= CONTEXT_COURSECAT && strpos($FULLME, '/message/')===false && strpos($FULLME, '/mod/forum/user')===false) {
            // If we have a course context and we are not in message or forum
            // Message and forum both pick the user up from `id`
            $userkey = 'user';
        } else if (strpos($FULLME,'/blog/') || strpos($FULLME, '/roles/')) {
            // And blog and roles just do thier own thing using `userid`
            $userkey = 'userid';
        }

        $userid = optional_param($userkey, $USER->id, PARAM_INT);
        if ($userid!=$USER->id) {
            $this->generate_user_settings($courseid,$userid,'userviewingsettings');
            $this->generate_user_settings($courseid,$USER->id);
        } else {
            $this->generate_user_settings($courseid,$USER->id);
        }
    }

    /**
     * This function gets called by {@link load_user_settings()} and actually works out
     * what can be shown/done
     *
     * @param int $courseid The current course' id
     * @param int $userid The user id to load for
     * @param string $gstitle The string to pass to get_string for the branch title
     * @return string|int The key to reference this user's settings
     */
    protected function generate_user_settings($courseid, $userid, $gstitle='usercurrentsettings') {
        global $DB, $CFG, $USER, $SITE;

        if ($courseid != SITEID) {
            if (!empty($this->page->course->id) && $this->page->course->id == $courseid) {
                $course = $this->page->course;
            } else {
                $course = $DB->get_record("course", array("id"=>$courseid), '*', MUST_EXIST);
            }
        } else {
            $course = $SITE;
        }

        $coursecontext = get_context_instance(CONTEXT_COURSE, $course->id);   // Course context
        $systemcontext   = get_system_context();
        $currentuser = ($USER->id == $userid);

        if ($currentuser) {
            $user = $USER;
            $usercontext = get_context_instance(CONTEXT_USER, $user->id);       // User context
        } else {
            if (!$user = $DB->get_record('user', array('id'=>$userid))) {
                return false;
            }
            // Check that the user can view the profile
            $usercontext = get_context_instance(CONTEXT_USER, $user->id);       // User context
            if ($course->id==SITEID) {
                if ($CFG->forceloginforprofiles && !isteacherinanycourse() && !isteacherinanycourse($user->id) && !has_capability('moodle/user:viewdetails', $usercontext)) {  // Reduce possibility of "browsing" userbase at site level
                    // Teachers can browse and be browsed at site level. If not forceloginforprofiles, allow access (bug #4366)
                    return false;
                }
            } else {
                if ((!has_capability('moodle/user:viewdetails', $coursecontext) && !has_capability('moodle/user:viewdetails', $usercontext)) || !has_capability('moodle/course:view', $coursecontext, $user->id, false)) {
                    return false;
                }
                if (groups_get_course_groupmode($course) == SEPARATEGROUPS && !has_capability('moodle/site:accessallgroups', $coursecontext)) {
                    // If groups are in use, make sure we can see that group
                    return false;
                }
            }
        }

        $fullname = fullname($user, has_capability('moodle/site:viewfullnames', $this->page->context));

        // Add a user setting branch
        $usersettingskey = $this->add(get_string($gstitle, 'moodle', $fullname));
        $usersetting = $this->get($usersettingskey);
        $usersetting->id = 'usersettings';

        // Check if the user has been deleted
        if ($user->deleted) {
            if (!has_capability('moodle/user:update', $coursecontext)) {
                // We can't edit the user so just show the user deleted message
                $usersetting->add(get_string('userdeleted'), null, self::TYPE_SETTING);
            } else {
                // We can edit the user so show the user deleted message and link it to the profile
                $profileurl = new moodle_url('/user/view.php', array('id'=>$user->id, 'course'=>$course->id));
                $usersetting->add(get_string('userdeleted'), $profileurl, self::TYPE_SETTING);
            }
            return true;
        }

        // Add the profile edit link
        if (isloggedin() && !isguestuser($user) && !is_mnet_remote_user($user)) {
            if (($currentuser || !is_primary_admin($user->id)) && has_capability('moodle/user:update', $systemcontext)) {
                $url = new moodle_url('/user/editadvanced.php', array('id'=>$user->id, 'course'=>$course->id));
                $usersetting->add(get_string('editmyprofile'), $url, self::TYPE_SETTING);
            } else if ((has_capability('moodle/user:editprofile', $usercontext) && !is_primary_admin($user->id)) || ($currentuser && has_capability('moodle/user:editownprofile', $systemcontext))) {
                $url = new moodle_url('/user/edit.php', array('id'=>$user->id, 'course'=>$course->id));
                $usersetting->add(get_string('editmyprofile'), $url, self::TYPE_SETTING);
            }
        }

        // Change password link
        if (!empty($user->auth)) {
            $userauth = get_auth_plugin($user->auth);
            if ($currentuser && !session_is_loggedinas() && $userauth->can_change_password() && !isguestuser() && has_capability('moodle/user:changeownpassword', $systemcontext)) {
                $passwordchangeurl = $userauth->change_password_url();
                if (!$passwordchangeurl) {
                    if (empty($CFG->loginhttps)) {
                        $wwwroot = $CFG->wwwroot;
                    } else {
                        $wwwroot = str_replace('http:', 'https:', $CFG->wwwroot);
                    }
                    $passwordchangeurl = new moodle_url('/login/change_password.php');
                } else {
                    $urlbits = explode($passwordchangeurl. '?', 1);
                    $passwordchangeurl = new moodle_url($urlbits[0]);
                    if (count($urlbits)==2 && preg_match_all('#\&([^\=]*?)\=([^\&]*)#si', '&'.$urlbits[1], $matches)) {
                        foreach ($matches as $pair) {
                            $fullmeurl->param($pair[1],$pair[2]);
                        }
                    }
                }
                $passwordchangeurl->param('id', $course->id);
                $usersetting->add(get_string("changepassword"), $passwordchangeurl, self::TYPE_SETTING);
            }
        }

        // View the roles settings
        if (has_any_capability(array('moodle/role:assign', 'moodle/role:safeoverride','moodle/role:override', 'moodle/role:manage'), $usercontext)) {
            $roleskey = $usersetting->add(get_string('roles'), null, self::TYPE_SETTING);

            $url = new moodle_url('/admin/roles/usersroles.php', array('userid'=>$user->id, 'courseid'=>$course->id));
            $usersetting->get($roleskey)->add(get_string('thisusersroles', 'role'), $url, self::TYPE_SETTING);

            $assignableroles = get_assignable_roles($usercontext, ROLENAME_BOTH);
            $overridableroles = get_overridable_roles($usercontext, ROLENAME_BOTH);

            if (!empty($assignableroles)) {
                $url = new moodle_url('/admin/roles/assign.php', array('contextid'=>$usercontext->id,'userid'=>$user->id, 'courseid'=>$course->id));
                $usersetting->get($roleskey)->add(get_string('assignrolesrelativetothisuser', 'role'), $url, self::TYPE_SETTING);
            }

            if (!empty($overridableroles)) {
                $url = new moodle_url('/admin/roles/override.php', array('contextid'=>$usercontext->id,'userid'=>$user->id, 'courseid'=>$course->id));
                $usersetting->get($roleskey)->add(get_string('overridepermissions', 'role'), $url, self::TYPE_SETTING);
            }

            $url = new moodle_url('/admin/roles/check.php', array('contextid'=>$usercontext->id,'userid'=>$user->id, 'courseid'=>$course->id));
            $usersetting->get($roleskey)->add(get_string('checkpermissions', 'role'), $url, self::TYPE_SETTING);
        }

        // Portfolio
        if ($currentuser && !empty($CFG->enableportfolios) && has_capability('moodle/portfolio:export', $systemcontext)) {
            require_once($CFG->libdir . '/portfoliolib.php');
            if (portfolio_instances(true, false)) {
                $portfoliokey = $usersetting->add(get_string('portfolios', 'portfolio'), null, self::TYPE_SETTING);
                $usersetting->get($portfoliokey)->add(get_string('configure', 'portfolio'), new moodle_url('/user/portfolio.php'), self::TYPE_SETTING);
                $usersetting->get($portfoliokey)->add(get_string('logs', 'portfolio'), new moodle_url('/user/portfoliologs.php'), self::TYPE_SETTING);
            }
        }

        // Security keys
        if ($currentuser && !is_siteadmin($USER->id) && !empty($CFG->enablewebservices) && has_capability('moodle/webservice:createtoken', $systemcontext)) {
            $url = new moodle_url('/user/managetoken.php', array('sesskey'=>sesskey()));
            $usersetting->add(get_string('securitykeys', 'webservice'), $url, self::TYPE_SETTING);
        }

        // Repository
        if (!$currentuser) {
            require_once($CFG->dirroot . '/repository/lib.php');
            $editabletypes = repository::get_editable_types($usercontext);
            if ($usercontext->contextlevel == CONTEXT_USER && !empty($editabletypes)) {
                $url = new moodle_url('/repository/manage_instances.php', array('contextid'=>$usercontext->id));
                $usersetting->add(get_string('repositories', 'repository'), $url, self::TYPE_SETTING);
            }
        }

        // Messaging
        if (has_capability('moodle/user:editownmessageprofile', $systemcontext)) {
            $url = new moodle_url('/message/edit.php', array('id'=>$user->id, 'course'=>$course->id));
            $usersetting->add(get_string('editmymessage', 'message'), $url, self::TYPE_SETTING);
        }

        return $usersettingskey;
    }

    /**
     * Determine whether the user is assuming another role
     *
     * This function checks to see if the user is assuming another role by means of
     * role switching. In doing this we compare each RSW key (context path) against
     * the current context path. This ensures that we can provide the switching
     * options against both the course and any page shown under the course.
     *
     * @return bool|int The role(int) if the user is in another role, false otherwise
     */
    protected function in_alternative_role() {
        global $USER;
        if (!empty($USER->access['rsw']) && is_array($USER->access['rsw'])) {
            if (!empty($this->page->context) && !empty($USER->access['rsw'][$this->page->context->path])) {
                return $USER->access['rsw'][$this->page->context->path];
            }
            foreach ($USER->access['rsw'] as $key=>$role) {
                if (strpos($this->context->path,$key)===0) {
                    return $role;
                }
            }
        }
        return false;
    }

    /**
     * This function loads all of the front page settings into the settings navigation.
     * This function is called when the user is on the front page, or $COURSE==$SITE
     */
    protected function load_front_page_settings() {
        global $SITE;

        $course = $SITE;
        if (empty($course->context)) {
            $course->context = get_context_instance(CONTEXT_COURSE, $course->id);   // Course context
        }

        $frontpagekey = $this->add(get_string('frontpagesettings'), null, self::TYPE_SETTING, null, 'frontpage');
        $frontpage = $this->get($frontpagekey);

        if (has_capability('moodle/course:update', $course->context)) {
            $frontpage->id = 'frontpagesettings';
            $frontpage->forceopen = true;

            // Add the turn on/off settings
            $url = new moodle_url('/course/view.php', array('id'=>$course->id, 'sesskey'=>sesskey()));
            if ($this->page->user_is_editing()) {
                $url->param('edit', 'off');
                $editstring = get_string('turneditingoff');
            } else {
                $url->param('edit', 'on');
                $editstring = get_string('turneditingon');
            }
            $frontpage->add($editstring, $url, self::TYPE_SETTING, null, null, new pix_icon('i/edit', ''));

            // Add the course settings link
            $url = new moodle_url('/admin/settings.php', array('section'=>'frontpagesettings'));
            $frontpage->add(get_string('settings'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/settings', ''));
        }

        //Participants
        if (has_capability('moodle/site:viewparticipants', $course->context)) {
            $url = new moodle_url('/user/index.php', array('contextid'=>$course->context->id));
            $frontpage->add(get_string('participants'), $url, self::TYPE_SETTING, null, null, new pix_icon('i/users', ''));
        }
    }


    /**
     * This function removes all root branches that have no children
     */
    public function remove_empty_root_branches() {
        foreach ($this->children as $key=>$node) {
            if ($node->nodetype != self::NODETYPE_BRANCH || count($node->children)===0) {
                $this->remove_child($key);
            }
        }
    }

    /**
     * This function marks the cache as volatile so it is cleared during shutdown
     */
    public function clear_cache() {
        $this->cache->volatile();
    }
}

/**
 * Simple class used to output a navigation branch in XML
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navigation_json {
    /** @var array */
    protected $nodetype = array('node','branch');
    /** @var array */
    protected $expandable = array();
    /** @var int */
    protected $expansionceiling = array();
    /**
     * Turns a branch and all of its children into XML
     *
     * @param navigation_node $branch
     * @return string XML string
     */
    public function convert($branch) {
        $xml = $this->convert_child($branch);
        return $xml;
    }
    /**
     * Set the expandable items in the array so that we have enough information
     * to attach AJAX events
     */
    public function set_expandable($expandable) {
        foreach ($expandable as $node) {
            $this->expandable[(string)$node['branchid']] = $node;
        }
    }
    /**
     * Sets the upper limit for expandable nodes. Any nodes that are of the specified
     * type or larger will not be expandable
     *
     * @param int $expansionceiling One of navigation_node::TYPE_*
     */
    public function set_expansionceiling($expansionceiling) {
        $tihs->expansionceiling = $expansionceiling;
    }
    /**
     * Recusively converts a child node and its children to XML for output
     *
     * @param navigation_node $child The child to convert
     * @param int $depth Pointlessly used to track the depth of the XML structure
     */
    protected function convert_child($child, $depth=1) {
        global $OUTPUT;

        if (!$child->display) {
            return '';
        }
        $attributes = array();
        $attributes['id'] = $child->id;
        $attributes['name'] = $child->text;
        $attributes['type'] = $child->type;
        $attributes['key'] = $child->key;
        $attributes['icon'] = $child->icon;
        $attributes['class'] = $child->get_css_type();
        if ($child->forcetitle || $child->title !== $child->text) {
            $attributes['title'] = htmlentities($child->title);
        }
        if (array_key_exists((string)$child->key, $this->expandable)) {
            $attributes['expandable'] = $child->key;
            $child->add_class($this->expandable[$child->key]['id']);
        } else if ($child->type >= $this->expansionceiling) {
            $attributes['expansionceiling'] = $child->key;
        }

        if (count($child->classes)>0) {
            $attributes['class'] .= ' '.join(' ',$child->classes);
        }
        if (is_string($child->action)) {
            $attributes['link'] = $child->action;
        } else if ($child->action instanceof moodle_url) {
            $attributes['link'] = $child->action->out();
        }
        $attributes['hidden'] = ($child->hidden);
        $attributes['haschildren'] = (count($child->children)>0 || $child->type == navigation_node::TYPE_CATEGORY);

        if ($attributes['icon'] instanceof pix_icon) {
            $attributes['icon'] = $OUTPUT->pix_url($attributes['icon']->pix, $attributes['icon']->component);
        }

        if (count($child->children)>0) {
            $attributes['children'] = array();
            foreach ($child->children as $subchild) {
                $attributes['children'][] = $this->convert_child($subchild, $depth+1);
            }
        }

        if ($depth > 1) {
            return $attributes;
        } else {
            return json_encode($attributes);
        }
    }
}

/**
 * The cache class used by global navigation and settings navigation to cache bits
 * and bobs that are used during their generation.
 *
 * It is basically an easy access point to session with a bit of smarts to make
 * sure that the information that is cached is valid still.
 *
 * Example use:
 * <code php>
 * if (!$cache->viewdiscussion()) {
 *     // Code to do stuff and produce cachable content
 *     $cache->viewdiscussion = has_capability('mod/forum:viewdiscussion', $coursecontext);
 * }
 * $content = $cache->viewdiscussion;
 * </code>
 *
 * @package moodlecore
 * @subpackage navigation
 * @copyright 2009 Sam Hemelryk
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class navigation_cache {
    /** @var int */
    protected $creation;
    /** @var array */
    protected $session;
    /** @var string */
    protected $area;
    /** @var int */
    protected $timeout;
    /** @var stdClass */
    protected $currentcontext;
    /** @var int */
    const CACHETIME = 0;
    /** @var int */
    const CACHEUSERID = 1;
    /** @var int */
    const CACHEVALUE = 2;
    /** @var null|array An array of navigation cache areas to expire on shutdown */
    public static $volatilecaches;

    /**
     * Contructor for the cache. Requires two arguments
     *
     * @param string $area The string to use to segregate this particular cache
     *                it can either be unique to start a fresh cache or if you want
     *                to share a cache then make it the string used in the original
     *                cache
     * @param int $timeout The number of seconds to time the information out after
     */
    public function __construct($area, $timeout=60) {
        global $SESSION;
        $this->creation = time();
        $this->area = $area;

        if (!isset($SESSION->navcache)) {
            $SESSION->navcache = new stdClass;
        }

        if (!isset($SESSION->navcache->{$area})) {
            $SESSION->navcache->{$area} = array();
        }
        $this->session = &$SESSION->navcache->{$area};
        $this->timeout = time()-$timeout;
        if (rand(0,10)===0) {
            $this->garbage_collection();
        }
    }

    /**
     * Magic Method to retrieve something by simply calling using = cache->key
     *
     * @param mixed $key The identifier for the information you want out again
     * @return void|mixed Either void or what ever was put in
     */
    public function __get($key) {
        if (!$this->cached($key)) {
            return;
        }
        $information = $this->session[$key][self::CACHEVALUE];
        return unserialize($information);
    }

    /**
     * Magic method that simply uses {@link set();} to store something in the cache
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function __set($key, $information) {
        $this->set($key, $information);
    }

    /**
     * Sets some information against the cache (session) for later retrieval
     *
     * @param string|int $key
     * @param mixed $information
     */
    public function set($key, $information) {
        global $USER;
        $information = serialize($information);
        $this->session[$key]= array(self::CACHETIME=>time(), self::CACHEUSERID=>$USER->id, self::CACHEVALUE=>$information);
    }
    /**
     * Check the existence of the identifier in the cache
     *
     * @param string|int $key
     * @return bool
     */
    public function cached($key) {
        global $USER;
        if (!array_key_exists($key, $this->session) || !is_array($this->session[$key]) || $this->session[$key][self::CACHEUSERID]!=$USER->id || $this->session[$key][self::CACHETIME] < $this->timeout) {
            return false;
        }
        return true;
    }
    /**
     * Compare something to it's equivilant in the cache
     *
     * @param string $key
     * @param mixed $value
     * @param bool $serialise Whether to serialise the value before comparison
     *              this should only be set to false if the value is already
     *              serialised
     * @return bool If the value is the same false if it is not set or doesn't match
     */
    public function compare($key, $value, $serialise=true) {
        if ($this->cached($key)) {
            if ($serialise) {
                $value = serialize($value);
            }
            if ($this->session[$key][self::CACHEVALUE] === $value) {
                return true;
            }
        }
        return false;
    }
    /**
     * Wipes the entire cache, good to force regeneration
     */
    public function clear() {
        $this->session = array();
    }
    /**
     * Checks all cache entries and removes any that have expired, good ole cleanup
     */
    protected function garbage_collection() {
        foreach ($this->session as $key=>$cachedinfo) {
            if (is_array($cachedinfo) && $cachedinfo[self::CACHETIME]<$this->timeout) {
                unset($this->session[$key]);
            }
        }
    }

    /**
     * Marks the cache as being volatile (likely to change)
     *
     * Any caches marked as volatile will be destroyed at the on shutdown by
     * {@link navigation_node::destroy_volatile_caches()} which is registered
     * as a shutdown function if any caches are marked as volatile.
     *
     * @param bool $setting True to destroy the cache false not too
     */
    public function volatile($setting = true) {
        if (self::$volatilecaches===null) {
            self::$volatilecaches = array();
            register_shutdown_function(array('navigation_cache','destroy_volatile_caches'));
        }

        if ($setting) {
            self::$volatilecaches[$this->area] = $this->area;
        } else if (array_key_exists($this->area, self::$volatilecaches)) {
            unset(self::$volatilecaches[$this->area]);
        }
    }

    /**
     * Destroys all caches marked as volatile
     *
     * This function is static and works in conjunction with the static volatilecaches
     * property of navigation cache.
     * Because this function is static it manually resets the cached areas back to an
     * empty array.
     */
    public static function destroy_volatile_caches() {
        global $SESSION;
        if (is_array(self::$volatilecaches) && count(self::$volatilecaches)>0) {
            foreach (self::$volatilecaches as $area) {
                $SESSION->navcache->{$area} = array();
            }
        }
    }
}||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_GLOBAL
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR)
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_VAR)
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_ECHO
                    (SCALAR))
                (AST_RETURN
                    (NULL)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR)
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_ECHO
                    (SCALAR))
                (AST_RETURN
                    (NULL)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR)
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_ECHO
                    (SCALAR))
                (AST_RETURN
                    (NULL)))))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_CALL
            (
                (AST_CONST)
                (AST_PROP
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_PROP
                    (AST_VAR))
                (AST_CONST)
                (AST_CLASS_CONST
                    (SCALAR))
                (AST_CONST)
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR))
                (AST_PROP
                    (AST_VAR)))
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_PROP
                (AST_VAR))
            (SCALAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)))
            (
                (AST_INCLUDE_OR_EVAL
                    (AST_VAR))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_CALL
                            (
                                (AST_VAR)))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_METHOD_CALL
                                    (AST_VAR)
                                    (
                                        (AST_VAR))))
                            (AST_CALL
                                (AST_VAR)
                                (
                                    (AST_VAR)
                                    (AST_VAR)
                                    (AST_VAR)
                                    (AST_VAR))))))))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_GLOBAL
        (AST_VAR))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_CALL
            (
                (AST_CONST)
                (AST_PROP
                    (AST_PROP
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_PROP
                    (AST_VAR))
                (AST_CONST)
                (AST_CLASS_CONST
                    (SCALAR))
                (AST_CONST)
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR))
                (AST_PROP
                    (AST_VAR)))
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_PROP
                (AST_VAR))
            (SCALAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)))
            (
                (AST_INCLUDE_OR_EVAL
                    (AST_VAR))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_CALL
                            (
                                (AST_VAR)))
                        (
                            (AST_CALL
                                (AST_VAR)
                                (
                                    (AST_METHOD_CALL
                                        (AST_VAR)
                                        (
                                            (AST_VAR)))
                                    (AST_PROP
                                        (AST_VAR))
                                    (AST_PROP
                                        (AST_VAR))
                                    (AST_PROP
                                        (AST_VAR)))))))))))