    public function write_xml(array $data) {

        foreach ($data as $name => $value) {
            $this->xmlwriter->full_tag($name, $value);
        }
    }
}


/**
 * Shared base class for activity modules and blocks handlers
 */
abstract class moodle1_plugin_handler extends moodle1_xml_handler {

    /** @var string */
    protected $plugintype;

    /** @var string */
    protected $pluginname;

    /**
     * @param moodle1_converter $converter the converter that requires us
     * @param string plugintype
     * @param string pluginname
     */
    public function __construct(moodle1_converter $converter, $plugintype, $pluginname) {

        parent::__construct($converter);
        $this->plugintype = $plugintype;
        $this->pluginname = $pluginname;
    }
}


/**
 * Base class for activity module handlers
 */
abstract class moodle1_mod_handler extends moodle1_plugin_handler {

    /** @var int module id */
    protected $moduleid;

    /**
     * Return the relative path to the XML file that
     * this step writes out to.  Example: course/course.xml
     *
     * @return string
     */
    public function get_xml_filename() {
        return "activities/{$this->pluginname}_{$this->moduleid}/module.xml";
    }
}


/**
 * Base class for activity module handlers
 */
abstract class moodle1_block_handler extends moodle1_plugin_handler {

}


/**
 * Process the root element of the backup file
 */
class moodle1_root_handler extends moodle1_handler {

    public function get_paths() {
        return array(new convert_path('root_element', '/MOODLE_BACKUP'));
    }

    public function process_root_element($data) {
    }

    /**
     * This is executed at the very start of the moodle.xml parsing
     */
    public function on_root_element_start() {
        $this->converter->create_backup_ids_temp_table();
    }

    /**
     * This is executed at the end of the moodle.xml parsing
     */
    public function on_root_element_end() {
        $this->converter->drop_backup_ids_temp_table();
    }
}


/**
 * Handles the conversion of /MOODLE_BACKUP/INFO paths
 */
class moodle1_info_handler extends moodle1_handler {

    public function get_paths() {
        return array(
            new convert_path(
                'info', '/MOODLE_BACKUP/INFO',
                array(
                    'newfields' => array(
                        'mnet_remoteusers' => 0,
                    ),
                )
            ),
            new convert_path('info_details', '/MOODLE_BACKUP/INFO/DETAILS'),
            new convert_path('info_details_mod', '/MOODLE_BACKUP/INFO/DETAILS/MOD'),
            new convert_path('info_details_mod_instance', '/MOODLE_BACKUP/INFO/DETAILS/MOD/INSTANCES/INSTANCE'),
        );
    }

    public function process_info($data) {
    }

    public function process_info_details($data) {
    }

    public function process_info_details_mod($data) {
    }

    public function process_info_details_mod_instance($data) {
    }
}


/**
 * Handles the conversion of /MOODLE_BACKUP/COURSE/HEADER paths
 */
class moodle1_course_header_handler extends moodle1_xml_handler {

    /** @var array we need to merge course information because it is dispatched twice */
    protected $course = array();

    /** @var array we need to merge course information because it is dispatched twice */
    protected $courseraw = array();

    /** @var array */
    protected $category;

    public function get_paths() {
        return array(
            new convert_path(
                'course_header', '/MOODLE_BACKUP/COURSE/HEADER',
                array(
                    'newfields' => array(
                        'summaryformat'          => 1,
                        'legacyfiles'            => 1, // @todo is this correct?
                        'requested'              => 0, // @todo not really new, but maybe never backed up?
                        'restrictmodules'        => 0,
                        'enablecompletion'       => 0,
                        'completionstartonenrol' => 0,
                        'completionnotify'       => 0,
                    ),
                    'dropfields' => array(
                        'roles_overrides',
                        'roles_assignments',
                        'cost',
                        'currancy',
                        'defaultrole',
                        'enrol',
                        'enrolenddate',
                        'enrollable',
                        'enrolperiod',
                        'enrolstartdate',
                        'expirynotify',
                        'expirythreshold',
                        'guest',
                        'notifystudents',
                        'password',
                        'student',
                        'students',
                        'teacher',
                        'teachers',
                        'metacourse',
                    )
                )
            ),
            new convert_path('course_header_category', '/MOODLE_BACKUP/COURSE/HEADER/CATEGORY'),
        );
    }

    /**
     * Because there is the CATEGORY branch in the middle of the COURSE/HEADER
     * branch, this is dispatched twice. We use $this->coursecooked to merge
     * the result. Once the parser is fixed, it can be refactored.
     */
    public function process_course_header($data, $raw) {
       $this->course    = array_merge($this->course, $data);
       $this->courseraw = array_merge($this->courseraw, $raw);
    }

    public function process_course_header_category($data) {
        $this->category = $data;
    }

    public function on_course_header_end() {

        $contextid = convert_helper::get_contextid($this->course['id'], 'course', $this->converter->get_id());

        $this->open_xml_writer('course/course.xml');
        $this->xmlwriter->begin_tag('course', array(
            'id'        => $this->course['id'],
            'contextid' => $contextid,
        ));
        $this->write_xml($this->course);
        $this->xmlwriter->begin_tag('category', array('id' => $this->category['id']));
        $this->xmlwriter->full_tag('name', $this->category['name']);
        $this->xmlwriter->full_tag('description', null);
        $this->xmlwriter->end_tag('category');
        $this->xmlwriter->full_tag('tags', null);
        $this->xmlwriter->full_tag('allowed_modules', null);
        $this->xmlwriter->end_tag('course');
        $this->close_xml_writer();

    }
}||||||||    public function write_xml($element, array $data, array $attribs = array(), $parent = '/') {

        $mypath    = $parent . $element;
        $myattribs = array();

        // detect properties that should be rendered as element's attributes instead of children
        foreach ($data as $name => $value) {
            if (!is_array($value)) {
                if ($name === 'id' or in_array($mypath . '/' . $name, $attribs)) {
                    $myattribs[$name] = $value;
                    unset($data[$name]);
                }
            }
        }

        // reorder the $data so that all sub-branches are at the end (needed by our parser)
        $leaves   = array();
        $branches = array();
        foreach ($data as $name => $value) {
            if (is_array($value)) {
                $branches[$name] = $value;
            } else {
                $leaves[$name] = $value;
            }
        }
        $data = array_merge($leaves, $branches);

        $this->xmlwriter->begin_tag($element, $myattribs);

        foreach ($data as $name => $value) {
            if (is_array($value)) {
                // recursively call self
                $this->write_xml($name, $value, $attribs, $mypath);
            } else {
                $this->xmlwriter->full_tag($name, $value);
            }
        }

        $this->xmlwriter->end_tag($element);
    }
}


/**
 * Shared base class for activity modules and blocks handlers
 */
abstract class moodle1_plugin_handler extends moodle1_xml_handler {

    /** @var string */
    protected $plugintype;

    /** @var string */
    protected $pluginname;

    /**
     * @param moodle1_converter $converter the converter that requires us
     * @param string plugintype
     * @param string pluginname
     */
    public function __construct(moodle1_converter $converter, $plugintype, $pluginname) {

        parent::__construct($converter);
        $this->plugintype = $plugintype;
        $this->pluginname = $pluginname;
    }
}


/**
 * Base class for activity module handlers
 */
abstract class moodle1_mod_handler extends moodle1_plugin_handler {

    /** @var int module id */
    protected $moduleid;

    /**
     * Return the relative path to the XML file that
     * this step writes out to.  Example: course/course.xml
     *
     * @return string
     */
    public function get_xml_filename() {
        return "activities/{$this->pluginname}_{$this->moduleid}/module.xml";
    }
}


/**
 * Base class for activity module handlers
 */
abstract class moodle1_block_handler extends moodle1_plugin_handler {

}


/**
 * Process the root element of the backup file
 */
class moodle1_root_handler extends moodle1_handler {

    public function get_paths() {
        return array(new convert_path('root_element', '/MOODLE_BACKUP'));
    }

    public function process_root_element($data) {
    }

    /**
     * This is executed at the very start of the moodle.xml parsing
     */
    public function on_root_element_start() {
        $this->converter->create_backup_ids_temp_table();
    }

    /**
     * This is executed at the end of the moodle.xml parsing
     */
    public function on_root_element_end() {
        $this->converter->drop_backup_ids_temp_table();
    }
}


/**
 * Handles the conversion of /MOODLE_BACKUP/INFO paths
 *
 * We do not produce any XML file here, just storing the data in the temp
 * table so thay can be used by a later handler.
 */
class moodle1_info_handler extends moodle1_handler {

    public function get_paths() {
        return array(
            new convert_path('info', '/MOODLE_BACKUP/INFO'),
            new convert_path('info_details', '/MOODLE_BACKUP/INFO/DETAILS'),
            new convert_path('info_details_mod', '/MOODLE_BACKUP/INFO/DETAILS/MOD'),
            new convert_path('info_details_mod_instance', '/MOODLE_BACKUP/INFO/DETAILS/MOD/INSTANCES/INSTANCE'),
        );
    }

    public function process_info($data) {
    }

    public function process_info_details($data) {
    }

    public function process_info_details_mod($data) {
    }

    public function process_info_details_mod_instance($data) {
    }
}


/**
 * Handles the conversion of /MOODLE_BACKUP/COURSE/HEADER paths
 */
class moodle1_course_header_handler extends moodle1_xml_handler {

    /** @var array we need to merge course information because it is dispatched twice */
    protected $course = array();

    /** @var array we need to merge course information because it is dispatched twice */
    protected $courseraw = array();

    /** @var array */
    protected $category;

    public function get_paths() {
        return array(
            new convert_path(
                'course_header', '/MOODLE_BACKUP/COURSE/HEADER',
                array(
                    'newfields' => array(
                        'summaryformat'          => 1,
                        'legacyfiles'            => 1, // @todo is this correct?
                        'requested'              => 0, // @todo not really new, but maybe never backed up?
                        'restrictmodules'        => 0,
                        'enablecompletion'       => 0,
                        'completionstartonenrol' => 0,
                        'completionnotify'       => 0,
                        'tags'                   => array(),
                        'allowed_modules'        => array(),
                    ),
                    'dropfields' => array(
                        'roles_overrides',
                        'roles_assignments',
                        'cost',
                        'currancy',
                        'defaultrole',
                        'enrol',
                        'enrolenddate',
                        'enrollable',
                        'enrolperiod',
                        'enrolstartdate',
                        'expirynotify',
                        'expirythreshold',
                        'guest',
                        'notifystudents',
                        'password',
                        'student',
                        'students',
                        'teacher',
                        'teachers',
                        'metacourse',
                    )
                )
            ),
            new convert_path(
                'course_header_category', '/MOODLE_BACKUP/COURSE/HEADER/CATEGORY',
                array(
                    'newfields' => array(
                        'description' => null,
                    )
                )
            ),
        );
    }

    /**
     * Because there is the CATEGORY branch in the middle of the COURSE/HEADER
     * branch, this is dispatched twice. We use $this->coursecooked to merge
     * the result. Once the parser is fixed, it can be refactored.
     */
    public function process_course_header($data, $raw) {
       $this->course    = array_merge($this->course, $data);
       $this->courseraw = array_merge($this->courseraw, $raw);
    }

    public function process_course_header_category($data) {
        $this->category = $data;
    }

    public function on_course_header_end() {

        $contextid = $this->converter->get_contextid(CONTEXT_COURSE, $this->course['id']);

        // stash the information needed by other handlers
        $info = array(
            'original_course_id'        => $this->course['id'],
            'original_course_fullname'  => $this->course['fullname'],
            'original_course_shortname' => $this->course['shortname'],
            'original_course_startdate' => $this->course['startdate'],
            'original_course_contextid' => $contextid
        );
        $this->converter->set_stash('original_course_info', $info);

        $this->course['contextid'] = $contextid;
        $this->course['category'] = $this->category;

        $this->open_xml_writer('course/course.xml');
        $this->write_xml('course', $this->course, array('/course/contextid'));
        $this->close_xml_writer();
    }
}||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_METHOD_CALL
                (AST_PROP
                    (AST_VAR))
                (
                    (AST_VAR)
                    (AST_VAR))))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPENO_PARAM_DEFAULTPARAM_TYPEPARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_VAR)
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_UNARY_OP
                        (AST_CALL
                            (
                                (AST_VAR))))
                    (
                        (AST_IF
                            (AST_IF_ELEM
                                (AST_BINARY_OP
                                    (AST_BINARY_OP
                                        (AST_VAR)
                                        (SCALAR))
                                    (AST_CALL
                                        (
                                            (AST_BINARY_OP
                                                (AST_BINARY_OP
                                                    (AST_VAR)
                                                    (SCALAR))
                                                (AST_VAR))
                                            (AST_VAR))))
                                (
                                    (AST_ASSIGN
                                        (AST_DIM
                                            (AST_VAR)
                                            (AST_VAR))
                                        (AST_VAR))
                                    (AST_UNSET
                                        (AST_DIM
                                            (AST_VAR)
                                            (AST_VAR)))))))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_CALL
                        (
                            (AST_VAR)))
                    (
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR))
                            (AST_VAR))))
                (AST_IF_ELEM
                    (NULL)
                    (
                        (AST_ASSIGN
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR))
                            (AST_VAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR)
                (AST_VAR))))
    (AST_METHOD_CALL
        (AST_PROP
            (AST_VAR))
        (
            (AST_VAR)
            (AST_VAR)))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_CALL
                        (
                            (AST_VAR)))
                    (
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (AST_VAR)
                                (AST_VAR)
                                (AST_VAR)
                                (AST_VAR)))))
                (AST_IF_ELEM
                    (NULL)
                    (
                        (AST_METHOD_CALL
                            (AST_PROP
                                (AST_VAR))
                            (
                                (AST_VAR)
                                (AST_VAR))))))))
    (AST_METHOD_CALL
        (AST_PROP
            (AST_VAR))
        (
            (AST_VAR))))