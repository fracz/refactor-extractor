    protected function addExtensionsFromTemplateConfiguration($transformation, $project, $env)
    {
        /** @var \SimpleXMLElement $extension */
        foreach ((array)$transformation->getParameter('twig-extension', array()) as $extension) {
            $extension = (string)$extension;
            if (!class_exists($extension)) {
                throw new \InvalidArgumentException('Unknown twig extension: ' . $extension);
            }

            // to support 'normal' Twig extensions we check the interface to determine what instantiation to do.
            $implements_interface = in_array(
                'phpDocumentor\Plugin\Twig\ExtensionInterface',
                class_implements($extension)
            );

            $env->addExtension($implements_interface
                ? new $extension($project, $transformation)
                : new $extension()
            );
        }
    }

    /**
     * Uses the currently selected node and transformation to assemble the destination path for the file.
     *
     * The Twig writer accepts the use of a Query to be able to generate output
     * for multiple objects using the same template.
     *
     * The given node is the result of such a query, or if no query given the
     * selected element, and the transformation contains the destination file.
     *
     * Since it is important to be able to generate a unique name per element
     * can the user provide a template variable in the name of the file.
     * Such a template variable always resides between braces and tries to
     * take the node value of a given node or attribute.
     *
     * Example:
     *
     *   An artefact stating `classes/{full_name}.html` will try to find the
     *   node 'full_name' as a child of the given $node and use that value
     *   instead.
     *
     * @param DescriptorAbstract $node
     * @param Transformation     $transformation
     *
     * @return string
     */
||||||||    protected function addExtensionsFromTemplateConfiguration(
        Transformation $transformation,
        ProjectDescriptor $project,
        \Twig_Environment $twigEnvironment
    ) {
        /** @var \SimpleXMLElement $extension */
        foreach ((array)$transformation->getParameter('twig-extension', array()) as $extension) {
            $extension = (string)$extension;
            if (!class_exists($extension)) {
                throw new \InvalidArgumentException('Unknown twig extension: ' . $extension);
            }

            // to support 'normal' Twig extensions we check the interface to determine what instantiation to do.
            $implements_interface = in_array(
                'phpDocumentor\Plugin\Twig\ExtensionInterface',
                class_implements($extension)
            );

            $twigEnvironment->addExtension($implements_interface
                ? new $extension($project, $transformation)
                : new $extension()
            );
        }
    }

    /**
     * Uses the currently selected node and transformation to assemble the destination path for the file.
     *
     * The Twig writer accepts the use of a Query to be able to generate output for multiple objects using the same
     * template.
     *
     * The given node is the result of such a query, or if no query given the selected element, and the transformation
     * contains the destination file.
     *
     * Since it is important to be able to generate a unique name per element can the user provide a template variable
     * in the name of the file.
     * Such a template variable always resides between double braces and tries to take the node value of a given
     * query string.
     *
     * Example:
     *
     *   An artefact stating `classes/{{name}}.html` will try to find the
     *   node 'name' as a child of the given $node and use that value instead.
     *
     * @param DescriptorAbstract $node
     * @param Transformation     $transformation
     *
     * @return string
     */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_FOREACH
        (AST_CAST
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (SCALAR)
                    (AST_ARRAY))))
        (AST_VAR)
        (NULL)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_CAST
                    (AST_VAR)))
            (AST_IF
                (AST_IF_ELEM
                    (AST_UNARY_OP
                        (AST_CALL
                            (
                                (AST_VAR))))
                    (
                        (AST_THROW
                            (AST_NEW
                                (
                                    (AST_BINARY_OP
                                        (SCALAR)
                                        (AST_VAR))))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (SCALAR)
                        (AST_CALL
                            (
                                (AST_VAR))))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_CONDITIONAL
                        (AST_VAR)
                        (AST_NEW
                            (AST_VAR)
                            (
                                (AST_VAR)
                                (AST_VAR)))
                        (AST_NEW
                            (AST_VAR))))))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPENO_PARAM_DEFAULTPARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_FOREACH
        (AST_CAST
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (SCALAR)
                    (AST_ARRAY))))
        (AST_VAR)
        (NULL)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_CAST
                    (AST_VAR)))
            (AST_IF
                (AST_IF_ELEM
                    (AST_UNARY_OP
                        (AST_CALL
                            (
                                (AST_VAR))))
                    (
                        (AST_THROW
                            (AST_NEW
                                (
                                    (AST_BINARY_OP
                                        (SCALAR)
                                        (AST_VAR))))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (SCALAR)
                        (AST_CALL
                            (
                                (AST_VAR))))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_CONDITIONAL
                        (AST_VAR)
                        (AST_NEW
                            (AST_VAR)
                            (
                                (AST_VAR)
                                (AST_VAR)))
                        (AST_NEW
                            (AST_VAR))))))))