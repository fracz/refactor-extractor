<?php

/**
 * Our generator class. This does the work of interpreting the form data, passing the work off to the various
 * plugins and piecing the generateda data for returning to the client.
 */
class Generator {
	private $batchNum;
	private $batchSize;
	private $numResults;
	private $template;
	private $exportType;
	private $countries;
	private $dataTypes;


	/**
	 * @param array $postdata everything from the form post.
	 */
	public function __construct($postdata) {
		$this->batchSize  = $postdata["gdBatchSize"];
		$this->batchNum   = $postdata["gdCurrentBatchNum"];
		$this->numResults = $postdata["gdNumRowsToGenerate"];
		$this->countries  = $postdata["gdCountries"];
		$this->dataTypes  = DataTypePluginHelper::getDataTypeHash(Core::$dataTypePlugins);

		// figure out what we're going to need to generate
		$this->createDataSetTemplate($postdata);

		// now we farm out the work of data generation to the selected Export Type
		$exportTypes = Core::$exportTypePlugins;
		$selectedExportType = null;
		foreach ($exportTypes as $currExportType) {
			if ($currExportType->getFolder() != $postdata["gdExportType"]) {
				continue;
			}
			$this->exportType = $currExportType;
			break;
		}

		// TODO should have error checking here to confirm the export type was found
	}


	public function generate() {
		return $this->exportType->generate($this);
	}

	/**
	 * This function creates a "template" of the data set to be generated by passing off work to the
	 * various Data Types. The "template" that's returned is an ordered array of hashes, each hash being
	 * of the following structure:
	 *
	 *   array(
	 *      "title" => "", // whatever string is being used for the column title / node name / etc.
	 *      "type"  => "", // the namespace (folder name) of the Data Type
	 *      "options" => "" // whatever custom options have been specified for this Data Type
	 *      "has_dependencies" => ""  // boolean true / false. This is for Data Types whose generated content
	 *                                // (may) depend on values in other fields in the row, e.g. "Region",
	 *                                // which would need to know the randomly generated country to generate
	 *                                // an appropriate value
	 *   )
	 *
	 * The first two values are found right in the $_POST values, but the third and fourth are determined by
	 * the Data Type itself.
	 *
	 * @param array $hash
	 * @param integer $numCols
	 * @return array
	 */
	private function createDataSetTemplate($hash) {
		$numCols  = $hash["gdNumCols"];
		$rowOrder = $hash["gdRowOrder"];
		$rowNums = explode(",", $rowOrder);

		// find out what the user wants to generate
		$templatesByProcessOrder = array();
		$order = 1;
		foreach ($rowNums as $i) {
			$title    = $hash["gdTitle_$i"];
			$dataType = $hash["gdDataType_$i"];

			// if there's no data type, the row wasn't filled in so we just ignore it
			if (empty($dataType)) {
				continue;
			}

			$dataTypeFolder = preg_replace("/^data-type-/", "", $dataType);
			$currDataType = $this->dataTypes[$dataTypeFolder];
			$processOrder = $currDataType->getProcessOrder();
			$options = $currDataType->getRowGenerationOptions($hash, $i, $numCols);

			// the only time $options is false is if this Data Type explicitly returned it, meaning
			// that it was unable to determine the options needed. This could occur if the user didn't enter in appropriate
			// values in the UI and the Data Type failed to catch it via the JS validation
			if ($options !== false) {
				if (!array_key_exists("processOrder$processOrder", $templatesByProcessOrder)) {
					$templatesByProcessOrder["processOrder$processOrder"] = array();
				}
				$templatesByProcessOrder["processOrder$processOrder"][] = array(
					"title"          => $title,
				    "colNum"         => $order,
					"dataTypeFolder" => $dataTypeFolder,
					"options"        => $options
				);
			}

			$order++;
		}

		// sort by process order and return
		ksort($templatesByProcessOrder);
		$this->template = $templatesByProcessOrder;
	}


	// getters

	public function getBatchNum() {
		return $this->batchNum;
	}

	public function getBatchSize() {
		return $this->batchSize;
	}

	public function getNumResults() {
		return $this->numResults;
	}

	public function getTemplateByProcessOrder() {
		return $this->template;
	}

	/**
	 * this->template contains the entire data set to be generated by the Export Type, grouped
	 * by the priority in which they should be generated. This flattens the info and returns a
	 *
	 * This is generally used for producing the list of headings in the expected order.
	 *
	 * @param array $template
	 */
	public function getTemplateByDisplayOrder() {
		$ordered = array();
		while (list($order, $dataTypes) = each($this->template)) {
			foreach ($dataTypes as $dataType) {
		    	$order = $dataType["colNum"];
		    	$ordered["order$order"] = $dataType;
			}
		}
		asort($ordered);
		return array_values($ordered);
	}

	public function getExportType() {
		return $this->exportType;
	}

	public function getCountries() {
		return $this->countries;
	}

	public function getDataTypes() {
		return $this->dataTypes;
	}
}