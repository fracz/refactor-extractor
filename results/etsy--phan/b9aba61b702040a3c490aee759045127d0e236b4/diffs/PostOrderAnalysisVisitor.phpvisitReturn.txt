    public function visitReturn(Node $node) : Context
    {
        // Don't check return types in traits
        if ($this->context->isInClassScope()) {
            $clazz = $this->context->getClassInScope($this->code_base);
            if ($clazz->isTrait()) {
                return $this->context;
            }
        }

        // Make sure we're actually returning from a method.
        if (!$this->context->isInFunctionLikeScope()) {
            return $this->context;
        }

        // Get the method/function/closure we're in
        $method = $this->context->getFunctionLikeInScope($this->code_base);

        assert(!empty($method),
            "We're supposed to be in either method or closure scope.");

        // Figure out what we intend to return
        $method_return_type = $method->getUnionType();

        // Figure out what is actually being returned
        $expression_type = UnionType::fromNode(
            $this->context,
            $this->code_base,
            $node->children['expr']
        );

        if (null === $node->children['expr']) {
            $expression_type = VoidType::instance(false)->asUnionType();
        }

        if ($expression_type->hasStaticType()) {
            $expression_type =
                $expression_type->withStaticResolvedInContext(
                    $this->context
                );
        }

        if ($method->getHasYield()) {  // Function that is syntactically a Generator.
            return $this->context;  // Analysis was completed in PreOrderAnalysisVisitor
        }
        // This leaves functions which aren't syntactically generators.

        // If there is no declared type, see if we can deduce
        // what it should be based on the return type
        if ($method_return_type->isEmpty()
            || $method->isReturnTypeUndefined()
        ) {
            $method->setIsReturnTypeUndefined(true);

            // Set the inferred type of the method based
            // on what we're returning
            $method->getUnionType()->addUnionType($expression_type);

            // No point in comparing this type to the
            // type we just set
            return $this->context;
        }


        // C
        if (!$method->isReturnTypeUndefined()
            && !$expression_type->canCastToExpandedUnionType(
                $method_return_type,
                $this->code_base
            )
        ) {
            $this->emitIssue(
                Issue::TypeMismatchReturn,
                $node->lineno ?? 0,
                (string)$expression_type,
                $method->getName(),
                (string)$method_return_type
            );
        }
        // For functions that aren't syntactically Generators,
        // update the set/existence of return values.

        if ($method->isReturnTypeUndefined()) {
            // Add the new type to the set of values returned by the
            // method
            $method->getUnionType()->addUnionType($expression_type);
        }

        // Mark the method as returning something (even if void)
        $method->setHasReturn(true);

        return $this->context;
    }


    /**
     * @param Node $node
     * A node to parse
     *
     * @return Context
     * A new or an unchanged context resulting from
     * parsing the node
     */
||||||||    public function visitReturn(Node $node) : Context
    {
        // Make sure we're actually returning from a method.
        if (!$this->context->isInFunctionLikeScope()) {
            return $this->context;
        }

        // Check real return types instead of phpdoc return types in traits for #800
        // TODO: Why did Phan originally not analyze return types of traits at all in 4c6956c05222e093b29393ceaa389ffb91041bdc
        $is_trait = false;
        if ($this->context->isInClassScope()) {
            $clazz = $this->context->getClassInScope($this->code_base);
            $is_trait = $clazz->isTrait();
        }


        // Get the method/function/closure we're in
        $method = $this->context->getFunctionLikeInScope($this->code_base);

        assert(!empty($method),
            "We're supposed to be in either method or closure scope.");

        // Figure out what we intend to return
        // (For traits, lower the false positive rate by comparing against the real return type instead of the phpdoc type (#800))
        $method_return_type = $is_trait ? $method->getRealReturnType() : $method->getUnionType();

        // Figure out what is actually being returned
        $expression_type = UnionType::fromNode(
            $this->context,
            $this->code_base,
            $node->children['expr']
        );

        if (null === $node->children['expr']) {
            $expression_type = VoidType::instance(false)->asUnionType();
        }

        if ($expression_type->hasStaticType()) {
            $expression_type =
                $expression_type->withStaticResolvedInContext(
                    $this->context
                );
        }

        if ($method->getHasYield()) {  // Function that is syntactically a Generator.
            return $this->context;  // Analysis was completed in PreOrderAnalysisVisitor
        }
        // This leaves functions which aren't syntactically generators.

        // If there is no declared type, see if we can deduce
        // what it should be based on the return type
        if ($method_return_type->isEmpty()
            || $method->isReturnTypeUndefined()
        ) {
            if (!$is_trait) {
                $method->setIsReturnTypeUndefined(true);

                // Set the inferred type of the method based
                // on what we're returning
                $method->getUnionType()->addUnionType($expression_type);
            }

            // No point in comparing this type to the
            // type we just set
            return $this->context;
        }

        // C
        if (!$method->isReturnTypeUndefined()
            && !$expression_type->canCastToExpandedUnionType(
                $method_return_type,
                $this->code_base
            )
        ) {
            $this->emitIssue(
                Issue::TypeMismatchReturn,
                $node->lineno ?? 0,
                (string)$expression_type,
                $method->getName(),
                (string)$method_return_type
            );
        }
        // For functions that aren't syntactically Generators,
        // update the set/existence of return values.

        if ($method->isReturnTypeUndefined()) {
            // Add the new type to the set of values returned by the
            // method
            $method->getUnionType()->addUnionType($expression_type);
        }

        // Mark the method as returning something (even if void)
        $method->setHasReturn(true);

        return $this->context;
    }


    /**
     * @param Node $node
     * A node to parse
     *
     * @return Context
     * A new or an unchanged context resulting from
     * parsing the node
     */
||||||||HAS_DOC_COMMENTHAS_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_PROP
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_PROP
                            (AST_VAR))
                        (
                            (AST_PROP
                                (AST_VAR)))))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (
                            (AST_RETURN
                                (AST_PROP
                                    (AST_VAR)))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_METHOD_CALL
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_PROP
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_PROP
                (AST_VAR))
            (
                (AST_PROP
                    (AST_VAR)))))
    (AST_CALL
        (
            (AST_UNARY_OP
                (AST_EMPTY
                    (AST_VAR)))
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_PROP
                    (AST_VAR))
                (AST_PROP
                    (AST_VAR))
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_STATIC_CALL
                            (
                                (AST_CONST))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_PROP
                        (AST_VAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_METHOD_CALL
                    (AST_VAR)))
            (
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_CONST)))
                (AST_METHOD_CALL
                    (AST_METHOD_CALL
                        (AST_VAR))
                    (
                        (AST_VAR)))
                (AST_RETURN
                    (AST_PROP
                        (AST_VAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_UNARY_OP
                    (AST_METHOD_CALL
                        (AST_VAR)))
                (AST_UNARY_OP
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR)
                            (AST_PROP
                                (AST_VAR))))))
            (
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_CLASS_CONST
                            (SCALAR))
                        (AST_BINARY_OP
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR))
                        (AST_CAST
                            (AST_VAR))
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_CAST
                            (AST_VAR)))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_METHOD_CALL
                    (AST_METHOD_CALL
                        (AST_VAR))
                    (
                        (AST_VAR))))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_CONST)))
    (AST_RETURN
        (AST_PROP
            (AST_VAR))))||||||||HAS_DOC_COMMENTHAS_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_METHOD_CALL
                    (AST_PROP
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_PROP
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONST))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_PROP
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_PROP
                            (AST_VAR))
                        (
                            (AST_PROP
                                (AST_VAR)))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_PROP
                (AST_VAR))
            (
                (AST_PROP
                    (AST_VAR)))))
    (AST_CALL
        (
            (AST_UNARY_OP
                (AST_EMPTY
                    (AST_VAR)))
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONDITIONAL
            (AST_VAR)
            (AST_METHOD_CALL
                (AST_VAR))
            (AST_METHOD_CALL
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_PROP
                    (AST_VAR))
                (AST_PROP
                    (AST_VAR))
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_STATIC_CALL
                            (
                                (AST_CONST))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_PROP
                        (AST_VAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_METHOD_CALL
                    (AST_VAR)))
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_UNARY_OP
                            (AST_VAR))
                        (
                            (AST_METHOD_CALL
                                (AST_VAR)
                                (
                                    (AST_CONST)))
                            (AST_METHOD_CALL
                                (AST_METHOD_CALL
                                    (AST_VAR))
                                (
                                    (AST_VAR))))))
                (AST_RETURN
                    (AST_PROP
                        (AST_VAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_UNARY_OP
                    (AST_METHOD_CALL
                        (AST_VAR)))
                (AST_UNARY_OP
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR)
                            (AST_PROP
                                (AST_VAR))))))
            (
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_CLASS_CONST
                            (SCALAR))
                        (AST_BINARY_OP
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR))
                        (AST_CAST
                            (AST_VAR))
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_CAST
                            (AST_VAR)))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_METHOD_CALL
                    (AST_METHOD_CALL
                        (AST_VAR))
                    (
                        (AST_VAR))))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_CONST)))
    (AST_RETURN
        (AST_PROP
            (AST_VAR))))