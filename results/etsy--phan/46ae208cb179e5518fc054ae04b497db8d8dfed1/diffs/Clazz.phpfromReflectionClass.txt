    public static function fromReflectionClass(
        CodeBase $code_base,
        \ReflectionClass $class
    ) : Clazz {
        // Build a set of flags based on the constitution
        // of the built-in class
        $flags = 0;
        if ($class->isFinal()) {
            $flags = \ast\flags\CLASS_FINAL;
        } elseif ($class->isInterface()) {
            $flags = \ast\flags\CLASS_INTERFACE;
        } elseif ($class->isTrait()) {
            $flags = \ast\flags\CLASS_TRAIT;
        }
        if ($class->isAbstract()) {
            $flags |= \ast\flags\CLASS_ABSTRACT;
        }

        $context = new Context;

        $class_fqsen = FullyQualifiedClassName::fromStringInContext(
            $class->getName(),
            $context
        );

        // Build a base class element
        $clazz = new Clazz(
            $context,
            $class->getName(),
            UnionType::fromStringInContext($class->getName(), $context, Type::FROM_TYPE),
            $flags,
            $class_fqsen
        );

        // If this class has a parent class, add it to the
        // class info
        if (($parent_class = $class->getParentClass())) {

            $parent_class_fqsen =
                FullyQualifiedClassName::fromFullyQualifiedString(
                    '\\' . $parent_class->getName()
                );

            $parent_type = $parent_class_fqsen->asType();

            $clazz->setParentType($parent_type);
        }

        // Note: If there are multiple calls to Clazz->addProperty(),
        // the UnionType from the first one will be used, subsequent calls to addProperty()
        // will have no effect.
        // As a result, we set the types from phan's documented internal property types first,
        // preferring them over the default values (which may be null, etc.).
        foreach (UnionType::internalPropertyMapForClassName(
            $clazz->getName()
        ) as $property_name => $property_type_string) {

            // An asterisk indicates that the class supports
            // dynamic properties
            if ($property_name === '*') {
                $clazz->setHasDynamicProperties(true);
                continue;
            }

            $property_context = $context->withScope(
                new ClassScope(new GlobalScope, $clazz->getFQSEN())
            );

            $property_type =
                UnionType::fromStringInContext(
                    $property_type_string,
                    new Context,
                    Type::FROM_TYPE
                );

            $property_fqsen = FullyQualifiedPropertyName::make(
                $clazz->getFQSEN(),
                $property_name
            );

            $property = new Property(
                $property_context,
                $property_name,
                $property_type,
                0,
                $property_fqsen
            );

            $clazz->addProperty($code_base, $property, new None);
        }

        // n.b.: public properties on internal classes don't get
        //       listed via reflection until they're set unless
        //       they have a default value. Therefore, we don't
        //       bother iterating over `$class->getProperties()`
        //       `$class->getStaticProperties()`.

        foreach ($class->getDefaultProperties() as $name => $value) {
            $property_context = $context->withScope(
                new ClassScope(new GlobalScope, $clazz->getFQSEN())
            );

            $property_fqsen = FullyQualifiedPropertyName::make(
                $clazz->getFQSEN(),
                $name
            );

            $property = new Property(
                $property_context,
                $name,
                Type::fromObject($value)->asUnionType(),
                0,
                $property_fqsen
            );

            $clazz->addProperty($code_base, $property, new None);
        }

        foreach ($class->getInterfaceNames() as $name) {
            $clazz->addInterfaceClassFQSEN(
                FullyQualifiedClassName::fromFullyQualifiedString(
                    '\\' . $name
                )
            );
        }

        foreach ($class->getTraitNames() as $name) {
            // TODO: optionally, support getTraitAliases()? This is low importance for internal PHP modules,
            // it would be uncommon to see traits in internal PHP modules.
            $clazz->addTraitFQSEN(
                FullyQualifiedClassName::fromFullyQualifiedString(
                    '\\' . $name
                )
            );
        }

        foreach ($class->getConstants() as $name => $value) {
            $constant_fqsen = FullyQualifiedClassConstantName::make(
                $clazz->getFQSEN(),
                $name
            );

            $constant = new ClassConstant(
                $context,
                $name,
                Type::fromObject($value)->asUnionType(),
                0,
                $constant_fqsen
            );

            $clazz->addConstant($code_base, $constant);
        }

        foreach ($class->getMethods() as $reflection_method) {

            $method_context = $context->withScope(
                new ClassScope(new GlobalScope, $clazz->getFQSEN())
            );

            $method_list =
                FunctionFactory::methodListFromReflectionClassAndMethod(
                    $method_context,
                    $code_base,
                    $class,
                    $reflection_method
                );

            foreach ($method_list as $method) {
                $clazz->addMethod($code_base, $method, new None);
            }
        }

        return $clazz;
    }

    /**
     * @param Type|null $parent_type
     * The type of the parent (extended) class of this class.
     *
     * @return void
     */
||||||||    public static function fromReflectionClass(
        CodeBase $code_base,
        \ReflectionClass $class
    ) : Clazz {
        // Build a set of flags based on the constitution
        // of the built-in class
        $flags = 0;
        if ($class->isFinal()) {
            $flags = \ast\flags\CLASS_FINAL;
        } elseif ($class->isInterface()) {
            $flags = \ast\flags\CLASS_INTERFACE;
        } elseif ($class->isTrait()) {
            $flags = \ast\flags\CLASS_TRAIT;
        }
        if ($class->isAbstract()) {
            $flags |= \ast\flags\CLASS_ABSTRACT;
        }

        $context = new Context;

        $class_name = $class->getName();
        $class_fqsen = FullyQualifiedClassName::fromStringInContext(
            $class_name,
            $context
        );

        // Build a base class element
        $clazz = new Clazz(
            $context,
            $class_name,
            UnionType::fromStringInContext($class_name, $context, Type::FROM_TYPE),
            $flags,
            $class_fqsen
        );

        // If this class has a parent class, add it to the
        // class info
        if (($parent_class = $class->getParentClass())) {

            $parent_class_fqsen =
                FullyQualifiedClassName::fromFullyQualifiedString(
                    '\\' . $parent_class->getName()
                );

            $parent_type = $parent_class_fqsen->asType();

            $clazz->setParentType($parent_type);
        }

        if ($class_name === "Traversable") {
            // Make sure that canCastToExpandedUnionType() works as expected for Traversable and its subclasses
            $clazz->getUnionType()->addType(IterableType::instance(false));
        }

        // Note: If there are multiple calls to Clazz->addProperty(),
        // the UnionType from the first one will be used, subsequent calls to addProperty()
        // will have no effect.
        // As a result, we set the types from phan's documented internal property types first,
        // preferring them over the default values (which may be null, etc.).
        foreach (UnionType::internalPropertyMapForClassName(
            $clazz->getName()
        ) as $property_name => $property_type_string) {

            // An asterisk indicates that the class supports
            // dynamic properties
            if ($property_name === '*') {
                $clazz->setHasDynamicProperties(true);
                continue;
            }

            $property_context = $context->withScope(
                new ClassScope(new GlobalScope, $clazz->getFQSEN())
            );

            $property_type =
                UnionType::fromStringInContext(
                    $property_type_string,
                    new Context,
                    Type::FROM_TYPE
                );

            $property_fqsen = FullyQualifiedPropertyName::make(
                $clazz->getFQSEN(),
                $property_name
            );

            $property = new Property(
                $property_context,
                $property_name,
                $property_type,
                0,
                $property_fqsen
            );

            $clazz->addProperty($code_base, $property, new None);
        }

        // n.b.: public properties on internal classes don't get
        //       listed via reflection until they're set unless
        //       they have a default value. Therefore, we don't
        //       bother iterating over `$class->getProperties()`
        //       `$class->getStaticProperties()`.

        foreach ($class->getDefaultProperties() as $name => $value) {
            $property_context = $context->withScope(
                new ClassScope(new GlobalScope, $clazz->getFQSEN())
            );

            $property_fqsen = FullyQualifiedPropertyName::make(
                $clazz->getFQSEN(),
                $name
            );

            $property = new Property(
                $property_context,
                $name,
                Type::fromObject($value)->asUnionType(),
                0,
                $property_fqsen
            );

            $clazz->addProperty($code_base, $property, new None);
        }

        foreach ($class->getInterfaceNames() as $name) {
            $clazz->addInterfaceClassFQSEN(
                FullyQualifiedClassName::fromFullyQualifiedString(
                    '\\' . $name
                )
            );
        }

        foreach ($class->getTraitNames() as $name) {
            // TODO: optionally, support getTraitAliases()? This is low importance for internal PHP modules,
            // it would be uncommon to see traits in internal PHP modules.
            $clazz->addTraitFQSEN(
                FullyQualifiedClassName::fromFullyQualifiedString(
                    '\\' . $name
                )
            );
        }

        foreach ($class->getConstants() as $name => $value) {
            $constant_fqsen = FullyQualifiedClassConstantName::make(
                $clazz->getFQSEN(),
                $name
            );

            $constant = new ClassConstant(
                $context,
                $name,
                Type::fromObject($value)->asUnionType(),
                0,
                $constant_fqsen
            );

            $clazz->addConstant($code_base, $constant);
        }

        foreach ($class->getMethods() as $reflection_method) {

            $method_context = $context->withScope(
                new ClassScope(new GlobalScope, $clazz->getFQSEN())
            );

            $method_list =
                FunctionFactory::methodListFromReflectionClassAndMethod(
                    $method_context,
                    $code_base,
                    $class,
                    $reflection_method
                );

            foreach ($method_list as $method) {
                $clazz->addMethod($code_base, $method, new None);
            }
        }

        return $clazz;
    }

    /**
     * @param Type|null $parent_type
     * The type of the parent (extended) class of this class.
     *
     * @return void
     */
||||||||HAS_DOC_COMMENTHAS_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CONST))))
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CONST))))
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN_OP
                    (AST_VAR)
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW
            (
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_STATIC_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR)
                        (AST_CLASS_CONST
                            (SCALAR))))
                (AST_VAR)
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL
                        (
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_METHOD_CALL
                                    (AST_VAR))))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_VAR))))))
    (AST_FOREACH
        (AST_STATIC_CALL
            (
                (AST_METHOD_CALL
                    (AST_VAR))))
        (AST_VAR)
        (AST_VAR)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR))
                    (
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (AST_CONST)))
                        (AST_CONTINUE
                            (NULL)))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_NEW
                            (
                                (AST_NEW)
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_NEW)
                        (AST_CLASS_CONST
                            (SCALAR)))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)
                    (AST_NEW)))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (AST_VAR)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_NEW
                            (
                                (AST_NEW)
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_METHOD_CALL
                            (AST_STATIC_CALL
                                (
                                    (AST_VAR))))
                        (SCALAR)
                        (AST_VAR))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)
                    (AST_NEW)))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_STATIC_CALL
                        (
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_VAR))))))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_STATIC_CALL
                        (
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_VAR))))))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (AST_VAR)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_METHOD_CALL
                            (AST_STATIC_CALL
                                (
                                    (AST_VAR))))
                        (SCALAR)
                        (AST_VAR))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_NEW
                            (
                                (AST_NEW)
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR))))
            (AST_FOREACH
                (AST_VAR)
                (AST_VAR)
                (NULL)
                (
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR)
                            (AST_VAR)
                            (AST_NEW)))))))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTHAS_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CONST))))
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CONST))))
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN_OP
                    (AST_VAR)
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR)
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW
            (
                (AST_VAR)
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_CLASS_CONST
                            (SCALAR))))
                (AST_VAR)
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL
                        (
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_METHOD_CALL
                                    (AST_VAR))))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_VAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (
                (AST_METHOD_CALL
                    (AST_METHOD_CALL
                        (AST_VAR))
                    (
                        (AST_STATIC_CALL
                            (
                                (AST_CONST))))))))
    (AST_FOREACH
        (AST_STATIC_CALL
            (
                (AST_METHOD_CALL
                    (AST_VAR))))
        (AST_VAR)
        (AST_VAR)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (AST_VAR)
                        (SCALAR))
                    (
                        (AST_METHOD_CALL
                            (AST_VAR)
                            (
                                (AST_CONST)))
                        (AST_CONTINUE
                            (NULL)))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_NEW
                            (
                                (AST_NEW)
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_NEW)
                        (AST_CLASS_CONST
                            (SCALAR)))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR)
                        (SCALAR)
                        (AST_VAR))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)
                    (AST_NEW)))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (AST_VAR)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_NEW
                            (
                                (AST_NEW)
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_METHOD_CALL
                            (AST_STATIC_CALL
                                (
                                    (AST_VAR))))
                        (SCALAR)
                        (AST_VAR))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)
                    (AST_NEW)))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_STATIC_CALL
                        (
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_VAR))))))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_STATIC_CALL
                        (
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_VAR))))))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (AST_VAR)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_NEW
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_METHOD_CALL
                            (AST_STATIC_CALL
                                (
                                    (AST_VAR))))
                        (SCALAR)
                        (AST_VAR))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)))))
    (AST_FOREACH
        (AST_METHOD_CALL
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_NEW
                            (
                                (AST_NEW)
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR))))
            (AST_FOREACH
                (AST_VAR)
                (AST_VAR)
                (NULL)
                (
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR)
                            (AST_VAR)
                            (AST_NEW)))))))
    (AST_RETURN
        (AST_VAR)))