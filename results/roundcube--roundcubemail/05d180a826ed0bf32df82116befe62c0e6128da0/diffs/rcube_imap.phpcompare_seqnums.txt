   function compare_seqnums($a, $b)
   {
      // First get the sequence number from the header object (the 'id' field).
      $seqa = $a->id;
      $seqb = $b->id;

      // then find each sequence number in my ordered list
      $posa = $this->position_of($seqa);
      $posb = $this->position_of($seqb);

      // return the relative position as the comparison value
      $ret = $posa - $posb;
      return $ret;
   }
}


/**
 * Add quoted-printable encoding to a given string
 *
 * @param string   String to encode
 * @param int      Add new line after this number of characters
 * @param boolean  True if spaces should be converted into =20
 * @return string Encoded string
 */
function quoted_printable_encode($input, $line_max=76, $space_conv=false)
  {
  $hex = array('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
  $lines = preg_split("/(?:\r\n|\r|\n)/", $input);
  $eol = "\r\n";
  $escape = "=";
  $output = "";

  while( list(, $line) = each($lines))
    {
    //$line = rtrim($line); // remove trailing white space -> no =20\r\n necessary
    $linlen = strlen($line);
    $newline = "";
    for($i = 0; $i < $linlen; $i++)
      {
      $c = substr( $line, $i, 1 );
      $dec = ord( $c );
      if ( ( $i == 0 ) && ( $dec == 46 ) ) // convert first point in the line into =2E
        {
        $c = "=2E";
        }
      if ( $dec == 32 )
        {
        if ( $i == ( $linlen - 1 ) ) // convert space at eol only
          {
          $c = "=20";
          }
        else if ( $space_conv )
          {
          $c = "=20";
          }
        }
      else if ( ($dec == 61) || ($dec < 32 ) || ($dec > 126) )  // always encode "\t", which is *not* required
        {
        $h2 = floor($dec/16);
        $h1 = floor($dec%16);
        $c = $escape.$hex["$h2"].$hex["$h1"];
        }

      if ( (strlen($newline) + strlen($c)) >= $line_max )  // CRLF is not counted
        {
        $output .= $newline.$escape.$eol; // soft line break; " =\r\n" is okay
        $newline = "";
        // check if newline first character will be point or not
        if ( $dec == 46 )
          {
          $c = "=2E";
          }
        }
      $newline .= $c;
      } // end of for
    $output .= $newline.$eol;
    } // end of while

  return trim($output);
  }

||||||||   function compare_seqnums($a, $b)
   {
      // First get the sequence number from the header object (the 'id' field).
      $seqa = $a->id;
      $seqb = $b->id;

      // then find each sequence number in my ordered list
      $posa = isset($this->sequence_numbers[$seqa]) ? intval($this->sequence_numbers[$seqa]) : -1;
      $posb = isset($this->sequence_numbers[$seqb]) ? intval($this->sequence_numbers[$seqb]) : -1;

      // return the relative position as the comparison value
      return $posa - $posb;
   }
}


/**
 * Add quoted-printable encoding to a given string
 *
 * @param string   String to encode
 * @param int      Add new line after this number of characters
 * @param boolean  True if spaces should be converted into =20
 * @return string Encoded string
 */
function quoted_printable_encode($input, $line_max=76, $space_conv=false)
  {
  $hex = array('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
  $lines = preg_split("/(?:\r\n|\r|\n)/", $input);
  $eol = "\r\n";
  $escape = "=";
  $output = "";

  while( list(, $line) = each($lines))
    {
    //$line = rtrim($line); // remove trailing white space -> no =20\r\n necessary
    $linlen = strlen($line);
    $newline = "";
    for($i = 0; $i < $linlen; $i++)
      {
      $c = substr( $line, $i, 1 );
      $dec = ord( $c );
      if ( ( $i == 0 ) && ( $dec == 46 ) ) // convert first point in the line into =2E
        {
        $c = "=2E";
        }
      if ( $dec == 32 )
        {
        if ( $i == ( $linlen - 1 ) ) // convert space at eol only
          {
          $c = "=20";
          }
        else if ( $space_conv )
          {
          $c = "=20";
          }
        }
      else if ( ($dec == 61) || ($dec < 32 ) || ($dec > 126) )  // always encode "\t", which is *not* required
        {
        $h2 = floor($dec/16);
        $h1 = floor($dec%16);
        $c = $escape.$hex["$h2"].$hex["$h1"];
        }

      if ( (strlen($newline) + strlen($c)) >= $line_max )  // CRLF is not counted
        {
        $output .= $newline.$escape.$eol; // soft line break; " =\r\n" is okay
        $newline = "";
        // check if newline first character will be point or not
        if ( $dec == 46 )
          {
          $c = "=2E";
          }
        }
      $newline .= $c;
      } // end of for
    $output .= $newline.$eol;
    } // end of while

  return trim($output);
  }

||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_VAR)
            (AST_VAR)))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_PROP
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONDITIONAL
            (AST_ISSET
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))
            (AST_CALL
                (
                    (AST_DIM
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR))))
            (AST_UNARY_OP
                (SCALAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONDITIONAL
            (AST_ISSET
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))
            (AST_CALL
                (
                    (AST_DIM
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR))))
            (AST_UNARY_OP
                (SCALAR))))
    (AST_RETURN
        (AST_BINARY_OP
            (AST_VAR)
            (AST_VAR))))