||||||||    private static function _vlv_ber_encode($offset, $rpp, $search = '')
    {
        # this string is ber-encoded, php will prefix this value with:
        # 04 (octet string) and 10 (length of 16 bytes)
        # the code behind this string is broken down as follows:
        # 30 = ber sequence with a length of 0e (14) bytes following
        # 02 = type integer (in two's complement form) with 2 bytes following (beforeCount): 01 00 (ie 0)
        # 02 = type integer (in two's complement form) with 2 bytes following (afterCount):  01 18 (ie 25-1=24)
        # a0 = type context-specific/constructed with a length of 06 (6) bytes following
        # 02 = type integer with 2 bytes following (offset): 01 01 (ie 1)
        # 02 = type integer with 2 bytes following (contentCount):  01 00

        # whith a search string present:
        # 81 = type context-specific/constructed with a length of 04 (4) bytes following (the length will change here)
        # 81 indicates a user string is present where as a a0 indicates just a offset search
        # 81 = type context-specific/constructed with a length of 06 (6) bytes following

        # the following info was taken from the ISO/IEC 8825-1:2003 x.690 standard re: the
        # encoding of integer values (note: these values are in
        # two-complement form so since offset will never be negative bit 8 of the
        # leftmost octet should never by set to 1):
        # 8.3.2: If the contents octets of an integer value encoding consist
        # of more than one octet, then the bits of the first octet (rightmost) and bit 8
        # of the second (to the left of first octet) octet:
        # a) shall not all be ones; and
        # b) shall not all be zero

        if ($search)
        {
            $search = preg_replace('/[^-[:alpha:] ,.()0-9]+/', '', $search);
            $ber_val = self::_string2hex($search);
            $str = self::_ber_addseq($ber_val, '81');
        }
        else
        {
            # construct the string from right to left
            $str = "020100"; # contentCount

            $ber_val = self::_ber_encode_int($offset);  // returns encoded integer value in hex format

            // calculate octet length of $ber_val
            $str = self::_ber_addseq($ber_val, '02') . $str;

            // now compute length over $str
            $str = self::_ber_addseq($str, 'a0');
        }

        // now tack on records per page
        $str = "020100" . self::_ber_addseq(self::_ber_encode_int($rpp-1), '02') . $str;

        // now tack on sequence identifier and length
        $str = self::_ber_addseq($str, '30');

        return pack('H'.strlen($str), $str);
    }


    /**
     * create ber encoding for sort control
     *
     * @param array List of cols to sort by
     * @return string BER encoded option value
     */
||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_VAR)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (SCALAR)
                            (SCALAR)
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL
                        (
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL
                        (
                            (AST_VAR)
                            (SCALAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL
                        (
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (AST_STATIC_CALL
                            (
                                (AST_VAR)
                                (SCALAR)))
                        (AST_VAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_STATIC_CALL
                        (
                            (AST_VAR)
                            (SCALAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (SCALAR)
                (AST_STATIC_CALL
                    (
                        (AST_STATIC_CALL
                            (
                                (AST_BINARY_OP
                                    (AST_VAR)
                                    (SCALAR))))
                        (SCALAR))))
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (AST_VAR)
                (SCALAR))))
    (AST_RETURN
        (AST_CALL
            (
                (AST_BINARY_OP
                    (SCALAR)
                    (AST_CALL
                        (
                            (AST_VAR))))
                (AST_VAR)))))