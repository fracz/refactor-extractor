||||||||    static function loadDOMDocument($xml) {

        if (empty($xml))
            throw new Exception\BadRequest('Empty XML document sent');

        // The BitKinex client sends xml documents as UTF-16. PHP 5.3.1 (and presumably lower)
        // does not support this, so we must intercept this and convert to UTF-8.
        if (substr($xml,0,12) === "\x3c\x00\x3f\x00\x78\x00\x6d\x00\x6c\x00\x20\x00") {

            // Note: the preceeding byte sequence is "<?xml" encoded as UTF_16, without the BOM.
            $xml = iconv('UTF-16LE','UTF-8',$xml);

            // Because the xml header might specify the encoding, we must also change this.
            // This regex looks for the string encoding="UTF-16" and replaces it with
            // encoding="UTF-8".
            $xml = preg_replace('|<\?xml([^>]*)encoding="UTF-16"([^>]*)>|u','<?xml\1encoding="UTF-8"\2>',$xml);

        }

        // Retaining old error setting
        $oldErrorSetting =  libxml_use_internal_errors(true);

        // Clearing any previous errors
        libxml_clear_errors();

        $dom = new \DOMDocument();

        // We don't generally care about any whitespace
        $dom->preserveWhiteSpace = false;

        $dom->loadXML(self::convertDAVNamespace($xml),LIBXML_NOWARNING | LIBXML_NOERROR);

        if ($error = libxml_get_last_error()) {
            libxml_clear_errors();
            throw new Exception\BadRequest('The request body had an invalid XML body. (message: ' . $error->message . ', errorcode: ' . $error->code . ', line: ' . $error->line . ')');
        }

        // Restoring old mechanism for error handling
        if ($oldErrorSetting===false) libxml_use_internal_errors(false);

        return $dom;

    }

    /**
     * Parses all WebDAV properties out of a DOM Element
     *
     * Generally WebDAV properties are enclosed in {DAV:}prop elements. This
     * method helps by going through all these and pulling out the actual
     * propertynames, making them array keys and making the property values,
     * well.. the array values.
     *
     * If no value was given (self-closing element) null will be used as the
     * value. This is used in for example PROPFIND requests.
     *
     * Complex values are supported through the propertyMap argument. The
     * propertyMap should have the clark-notation properties as it's keys, and
     * classnames as values.
     *
     * When any of these properties are found, the unserialize() method will be
     * (statically) called. The result of this method is used as the value.
     *
     * @param \DOMElement $parentNode
     * @param array $propertyMap
     * @return array
     */
||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_EMPTY
                (AST_VAR))
            (
                (AST_THROW
                    (AST_NEW
                        (
                            (SCALAR)))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_VAR)
                        (SCALAR)
                        (SCALAR)))
                (SCALAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (SCALAR)
                            (SCALAR)
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (SCALAR)
                            (SCALAR)
                            (AST_VAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_CONST))))
    (AST_CALL)
    (AST_ASSIGN
        (AST_VAR)
        (AST_NEW))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_CONST))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_STATIC_CALL
                (
                    (AST_VAR)))
            (AST_BINARY_OP
                (AST_CONST)
                (AST_CONST))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL))
            (
                (AST_CALL)
                (AST_THROW
                    (AST_NEW
                        (
                            (AST_BINARY_OP
                                (AST_BINARY_OP
                                    (AST_BINARY_OP
                                        (AST_BINARY_OP
                                            (AST_BINARY_OP
                                                (AST_BINARY_OP
                                                    (SCALAR)
                                                    (AST_PROP
                                                        (AST_VAR)))
                                                (SCALAR))
                                            (AST_PROP
                                                (AST_VAR)))
                                        (SCALAR))
                                    (AST_PROP
                                        (AST_VAR)))
                                (SCALAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_CONST))
            (
                (AST_CALL
                    (
                        (AST_CONST))))))
    (AST_RETURN
        (AST_VAR)))