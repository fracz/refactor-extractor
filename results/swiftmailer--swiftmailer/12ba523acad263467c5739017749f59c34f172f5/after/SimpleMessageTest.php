<?php

require_once 'Swift/Mime/MimeEntity.php';
require_once 'Swift/Mime/SimpleMessage.php';
require_once 'Swift/Mime/MimePartTest.php';
require_once 'Swift/Mime/Header.php';
require_once 'Swift/Mime/ParameterizedHeader.php';

class Swift_Mime_SimpleMessageTest extends Swift_Mime_MimePartTest
{

  public function testDateIsSetInHeader()
  {
    $context = new Mockery();

    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->setFieldBodyModel(123)
      -> allowing($h)->getFieldName() -> returns('Date')
      -> ignoring($h)
      );

    $headers = array($h);

    $message = $this->_createMessage(
      $headers, $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setDate(123);

    $context->assertIsSatisfied();
  }

  public function testDateIsReadFromHeader()
  {
    $context = new Mockery();

    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns(123456)
      -> allowing($h)->getFieldName() -> returns('Date')
      -> ignoring($h)
      );

    $headers = array($h);

    $message = $this->_createMessage(
      $headers, $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(123456, $message->getDate());

    $context->assertIsSatisfied();
  }

  public function testIdIsSetInHeader()
  {
    /* -- RFC 2045, 7.
    In constructing a high-level user agent, it may be desirable to allow
    one body to make reference to another.  Accordingly, bodies may be
    labelled using the "Content-ID" header field, which is syntactically
    identical to the "Message-ID" header field
    */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->setFieldBodyModel('foo@bar')
      -> allowing($h)->getFieldName() -> returns('Message-ID')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setId('foo@bar');
    $context->assertIsSatisfied();
  }

  public function testIdIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns('xyz@somewhere.tld')
      -> allowing($h)->getFieldName() -> returns('Message-ID')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual('xyz@somewhere.tld', $message->getId());
    $context->assertIsSatisfied();
  }

  public function testIdIsAutoGenerated()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->setFieldBodyModel(pattern('/^.*?@.*?$/D'))
      -> allowing($h)->getFieldName() -> returns('Message-ID')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $context->assertIsSatisfied();
  }

  public function testNestingLevelIsSubpart()
  { //Overridden
  }

  public function testNestingLevelIsTop()
  {
    $context = new Mockery();
    $message = $this->_createMessage(
      array(), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(
      Swift_Mime_MimeEntity::LEVEL_TOP, $message->getNestingLevel()
      );
  }

  public function testSubjectIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.5.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel('foo')
      -> allowing($h)->getFieldName() -> returns('Subject')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setSubject('foo');
    $context->assertIsSatisfied();
  }

  public function testSubjectIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns('foo')
      -> allowing($h)->getFieldName() -> returns('Subject')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual('foo', $message->getSubject());
    $context->assertIsSatisfied();
  }

  public function testDateCanBeSetAndFetched()
  {
    /* -- RFC 2822, 3.6.1.
     */

    $context = new Mockery();
    $message = $this->_createMessage(
      array(), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setDate(123456);
    $this->assertEqual(123456, $message->getDate());
  }

  public function testReturnPathIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.7.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel('chris.corbyn@swiftmailer.org')
      -> allowing($h)->getFieldName() -> returns('Return-Path')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setReturnPath('chris.corbyn@swiftmailer.org');
    $context->assertIsSatisfied();
  }

  public function testReturnPathIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns('chris.corbyn@swiftmailer.org')
      -> allowing($h)->getFieldName() -> returns('Return-Path')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual('chris.corbyn@swiftmailer.org', $message->getReturnPath());
    $context->assertIsSatisfied();
  }

  public function testSenderIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.2.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel(array('chris.corbyn@swiftmailer.org'=>null))
      -> allowing($h)->getFieldName() -> returns('Sender')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setSender('chris.corbyn@swiftmailer.org');
    $context->assertIsSatisfied();
  }

  public function testSenderIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns(array('chris.corbyn@swiftmailer.org'=>'Chris'))
      -> allowing($h)->getFieldName() -> returns('Sender')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(
      array('chris.corbyn@swiftmailer.org'=>'Chris'),
      $message->getSender()
      );
    $context->assertIsSatisfied();
  }

  public function testFromIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.2.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel(array('chris.corbyn@swiftmailer.org'=>null))
      -> allowing($h)->getFieldName() -> returns('From')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setFrom('chris.corbyn@swiftmailer.org');
    $context->assertIsSatisfied();
  }

  public function testFromIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns(array('chris.corbyn@swiftmailer.org'=>'Chris'))
      -> allowing($h)->getFieldName() -> returns('From')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(
      array('chris.corbyn@swiftmailer.org'=>'Chris'),
      $message->getFrom()
      );
    $context->assertIsSatisfied();
  }

  public function testReplyToIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.2.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel(array('chris.corbyn@swiftmailer.org'=>null))
      -> allowing($h)->getFieldName() -> returns('Reply-To')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setReplyTo('chris.corbyn@swiftmailer.org');
    $context->assertIsSatisfied();
  }

  public function testReplyToIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns(array(
        'chris.corbyn@swiftmailer.org'=>'Chris',
        'mark@swiftmailer.org'=>'Mark'
        ))
      -> allowing($h)->getFieldName() -> returns('Reply-To')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(
      array('chris.corbyn@swiftmailer.org'=>'Chris',
      'mark@swiftmailer.org'=>'Mark'),
      $message->getReplyTo()
      );
    $context->assertIsSatisfied();
  }

  public function testToIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.3.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel(array('chris.corbyn@swiftmailer.org'=>null))
      -> allowing($h)->getFieldName() -> returns('To')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setTo('chris.corbyn@swiftmailer.org');
    $context->assertIsSatisfied();
  }

  public function testToIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns(array(
        'chris.corbyn@swiftmailer.org'=>'Chris',
        'mark@swiftmailer.org'=>'Mark'
        ))
      -> allowing($h)->getFieldName() -> returns('To')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(
      array('chris.corbyn@swiftmailer.org'=>'Chris',
      'mark@swiftmailer.org'=>'Mark'),
      $message->getTo()
      );
    $context->assertIsSatisfied();
  }

  public function testCcIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.3.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel(array('chris.corbyn@swiftmailer.org'=>null))
      -> allowing($h)->getFieldName() -> returns('Cc')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setCc('chris.corbyn@swiftmailer.org');
    $context->assertIsSatisfied();
  }

  public function testCcIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns(array(
        'chris.corbyn@swiftmailer.org'=>'Chris',
        'mark@swiftmailer.org'=>'Mark'
        ))
      -> allowing($h)->getFieldName() -> returns('Cc')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(
      array('chris.corbyn@swiftmailer.org'=>'Chris',
      'mark@swiftmailer.org'=>'Mark'),
      $message->getCc()
      );
    $context->assertIsSatisfied();
  }

  public function testBccIsSetInHeader()
  {
    /* -- RFC 2822, 3.6.3.
     */

    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> one($h)->setFieldBodyModel(array('chris.corbyn@swiftmailer.org'=>null))
      -> allowing($h)->getFieldName() -> returns('Bcc')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $message->setBcc('chris.corbyn@swiftmailer.org');
    $context->assertIsSatisfied();
  }

  public function testBccIsReadFromHeader()
  {
    $context = new Mockery();
    $h = $context->mock('Swift_Mime_Header');
    $context->checking(Expectations::create()
      -> atLeast(1)->of($h)->getFieldBodyModel() -> returns(array(
        'chris.corbyn@swiftmailer.org'=>'Chris',
        'mark@swiftmailer.org'=>'Mark'
        ))
      -> allowing($h)->getFieldName() -> returns('Bcc')
      -> ignoring($h)
      );
    $message = $this->_createMessage(
      array($h), $this->_getEncoder($context), $this->_getCache($context)
      );
    $this->assertEqual(
      array('chris.corbyn@swiftmailer.org'=>'Chris',
      'mark@swiftmailer.org'=>'Mark'),
      $message->getBcc()
      );
    $context->assertIsSatisfied();
  }

  public function testChildrenCanBeAttached()
  {
    $context = new Mockery();
    $entity1 = $context->mock('Swift_Mime_MimeEntity');
    $entity2 = $context->mock('Swift_Mime_MimeEntity');
    $context->checking(Expectations::create()
      -> allowing($entity1)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_ATTACHMENT)
      -> ignoring($entity1)
      -> allowing($entity2)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_SUBPART)
      -> ignoring($entity2)
      );

    $message = $this->_createMessage(
      array(), $this->_getEncoder($context), $this->_getCache($context)
      );

    $message->attach($entity1);

    $this->assertEqual(array($entity1), $message->getChildren(),
      '%s: Child should be appended'
      );

    $message->attach($entity2);

    $this->assertEqual(array($entity1, $entity2), $message->getChildren(),
      '%s: Children should be incrementally appended'
      );

    $context->assertIsSatisfied();
  }

  public function testChildrenCanBeDetached()
  {
    $context = new Mockery();
    $entity1 = $context->mock('Swift_Mime_MimeEntity');
    $entity2 = $context->mock('Swift_Mime_MimeEntity');
    $context->checking(Expectations::create()
      -> allowing($entity1)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_ATTACHMENT)
      -> allowing($entity1)->getId() -> returns('foo@bar')
      -> ignoring($entity1)
      -> allowing($entity2)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_SUBPART)
      -> allowing($entity2)->getId() -> returns('zip@button')
      -> ignoring($entity2)
      );

    $message = $this->_createMessage(
      array(), $this->_getEncoder($context), $this->_getCache($context)
      );

    $message->attach($entity1);

    $this->assertEqual(array($entity1), $message->getChildren(),
      '%s: Child should be appended'
      );

    $message->attach($entity2);

    $this->assertEqual(array($entity1, $entity2), $message->getChildren(),
      '%s: Children should be incrementally appended'
      );

    $message->detach($entity1);

    $this->assertEqual(array($entity2), $message->getChildren(),
      '%s: Child should be detached'
      );

    $context->assertIsSatisfied();
  }

  public function testEmbedAttachesChild()
  {
    $context = new Mockery();
    $entity1 = $context->mock('Swift_Mime_MimeEntity');
    $entity2 = $context->mock('Swift_Mime_MimeEntity');
    $context->checking(Expectations::create()
      -> allowing($entity1)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_ATTACHMENT)
      -> allowing($entity1)->getId() -> returns('foo@bar')
      -> ignoring($entity1)
      -> allowing($entity2)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_SUBPART)
      -> allowing($entity2)->getId() -> returns('zip@button')
      -> ignoring($entity2)
      );

    $message = $this->_createMessage(
      array(), $this->_getEncoder($context), $this->_getCache($context)
      );

    $message->embed($entity1);

    $this->assertEqual(array($entity1), $message->getChildren(),
      '%s: embed() should attach child'
      );

    $message->embed($entity2);

    $this->assertEqual(array($entity1, $entity2), $message->getChildren(),
      '%s: Children should be incrementally appended'
      );

    $context->assertIsSatisfied();
  }

  public function testEmbedReturnsValidCid()
  {
    $context = new Mockery();
    $entity1 = $context->mock('Swift_Mime_MimeEntity');
    $entity2 = $context->mock('Swift_Mime_MimeEntity');
    $context->checking(Expectations::create()
      -> allowing($entity1)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_ATTACHMENT)
      -> allowing($entity1)->getId() -> returns('foo@bar')
      -> ignoring($entity1)
      -> allowing($entity2)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_SUBPART)
      -> allowing($entity2)->getId() -> returns('zip@button')
      -> ignoring($entity2)
      );

    $message = $this->_createMessage(
      array(), $this->_getEncoder($context), $this->_getCache($context)
      );

    $this->assertEqual('cid:foo@bar', $message->embed($entity1));
    $this->assertEqual('cid:zip@button', $message->embed($entity2));

    $context->assertIsSatisfied();
  }

  public function testFluidInterface()
  {
    $context = new Mockery();
    $child = $context->mock('Swift_Mime_MimeEntity');
    $context->checking(Expectations::create()
      -> allowing($child)->getNestingLevel() -> returns(Swift_Mime_MimeEntity::LEVEL_SUBPART)
      -> ignoring($child)
      );
    $message = $this->_createMessage(
      array(), $this->_getEncoder($context), $this->_getCache($context)
      );
    $ref = $message
      ->setContentType('text/plain')
      ->setEncoder($this->_getEncoder($context))
      ->setId('foo@bar')
      ->setDescription('my description')
      ->setMaxLineLength(998)
      ->setBodyAsString('xx')
      ->setNestingLevel(10)
      ->setBoundary('xyz')
      ->setChildren(array())
      ->setHeaders(array())
      ->setCharset('iso-8859-1')
      ->setFormat('flowed')
      ->setDelSp(false)
      ->setSubject('subj')
      ->setDate(123)
      ->setReturnPath('foo@bar')
      ->setSender('foo@bar')
      ->setFrom(array('x@y' => 'XY'))
      ->setReplyTo(array('ab@cd' => 'ABCD'))
      ->setTo(array('chris@site.tld', 'mark@site.tld'))
      ->setCc('john@somewhere.tld')
      ->setBcc(array('one@site', 'two@site' => 'Two'))
      ->attach($child)
      ->detach($child)
      ;

    $this->assertReference($message, $ref);

    $context->assertIsSatisfied();
  }

  // -- Private helpers

  //abstract
  protected function _createEntity($headers, $encoder, $cache)
  {
    return $this->_createMessage($headers, $encoder, $cache);
  }

  protected function _createMimePart($headers, $encoder, $cache)
  {
    return $this->_createMessage($headers, $encoder, $cache);
  }

  private function _createMessage($headers, $encoder, $cache)
  {
    return new Swift_Mime_SimpleMessage($headers, $encoder, $cache);
  }

}