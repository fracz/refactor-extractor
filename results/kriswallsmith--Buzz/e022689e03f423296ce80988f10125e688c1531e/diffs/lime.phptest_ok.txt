  private function test_ok($condition, $message, $error = null)
  {
    list ($file, $line) = LimeTrace::findCaller('LimeTest');

    if ($result = (boolean) $condition)
    {
      $this->output->pass($message, $file, $line);
    }
    else
    {
      $this->output->fail($message, $file, $line, $error);
    }

    return $result;
  }
}

class lime_output
{
  const
    ERROR     = 'ERROR',
    INFO      = 'INFO',
    PARAMETER = 'PARAMETER',
    COMMENT   = 'COMMENT',
    GREEN_BAR = 'GREEN_BAR',
    RED_BAR   = 'RED_BAR',
    INFO_BAR  = 'INFO_BAR';

  protected static
    $styles = array(self::ERROR, self::INFO, self::PARAMETER, self::COMMENT, self::GREEN_BAR, self::RED_BAR, self::INFO_BAR);

  protected
    $colorizer = null;

  /**
   * Constructor.
   *
   * @param  boolean $forceColors  If set to TRUE, colorization will be enforced
   *                               whether or not the current console supports it
   */
  public function __construct($forceColors = false)
  {
    if (LimeColorizer::isSupported() || $forceColors)
    {
      $colorizer = new LimeColorizer();
      $colorizer->setStyle(self::ERROR, array('bg' => 'red', 'fg' => 'white', 'bold' => true));
      $colorizer->setStyle(self::INFO, array('fg' => 'green', 'bold' => true));
      $colorizer->setStyle(self::PARAMETER, array('fg' => 'cyan'));
      $colorizer->setStyle(self::COMMENT, array('fg' => 'yellow'));
      $colorizer->setStyle(self::GREEN_BAR, array('fg' => 'white', 'bg' => 'green', 'bold' => true));
      $colorizer->setStyle(self::RED_BAR, array('fg' => 'white', 'bg' => 'red', 'bold' => true));
      $colorizer->setStyle(self::INFO_BAR, array('fg' => 'cyan', 'bold' => true));

      $this->colorizer = $colorizer;
    }
  }

  /**
   * Colorizes the given text with the given style.
   *
   * @param  string $text   Some text
   * @param  string $style  One of the predefined style constants
   * @return string         The formatted text
   */
  protected function colorize($text, $style)
  {
    if (!in_array($style, self::$styles))
    {
      throw new InvalidArgumentException(sprintf('The style "%s" does not exist', $style));
    }

    return is_null($this->colorizer) ? $text : $this->colorizer->colorize($text, $style);
  }

  /**
   * ?
   */
  public function diag()
  {
    $messages = func_get_args();
    foreach ($messages as $message)
    {
      echo $this->colorize('# '.join("\n# ", (array) $message), self::COMMENT)."\n";
    }
  }

  /**
   * Prints a comment.
   *
   * @param  string $message
   */
  public function comment($message)
  {
    echo $this->colorize(sprintf('# %s', $message), self::COMMENT)."\n";
  }

  /**
   * Prints an informational message.
   *
   * @param  string $message
   */
  public function info($message)
  {
    echo $this->colorize(sprintf('> %s', $message), self::INFO_BAR)."\n";
  }

  /**
   * Prints an error.
   *
   * @param string $message
   */
  public function error($message)
  {
    echo $this->colorize(sprintf(' %s ', $message), self::RED_BAR)."\n";
  }

  /**
   * Prints and automatically colorizes a line.
   *
   * You can wrap the whole line into a specific predefined style by passing
   * the style constant in the second parameter.
   *
   * @param string  $message   The message to colorize
   * @param string  $style     The desired style constant
   * @param boolean $colorize  Whether to automatically colorize parts of the
   *                           line
   */
  public function echoln($message, $style = null, $colorize = true)
  {
    if ($colorize)
    {
      $message = preg_replace('/(?:^|\.)((?:not ok|dubious) *\d*)\b/e', '$this->colorize(\'$1\', self::ERROR)', $message);
      $message = preg_replace('/(?:^|\.)(ok *\d*)\b/e', '$this->colorize(\'$1\', self::INFO)', $message);
      $message = preg_replace('/"(.+?)"/e', '$this->colorize(\'$1\', self::PARAMETER)', $message);
      $message = preg_replace('/(\->|\:\:)?([a-zA-Z0-9_]+?)\(\)/e', '$this->colorize(\'$1$2()\', self::PARAMETER)', $message);
    }

    echo ($style ? $this->colorize($message, $style) : $message)."\n";
  }

  /**
   * Prints a message in a green box.
   *
   * @param string $message
   */
  public function greenBar($message)
  {
    echo $this->colorize($message.str_repeat(' ', 71 - min(71, strlen($message))), self::GREEN_BAR)."\n";
  }

  /**
   * Prints a message a in a red box.
   *
   * @param string $message
   */
  public function redBar($message)
  {
    echo $this->colorize($message.str_repeat(' ', 71 - min(71, strlen($message))), self::RED_BAR)."\n";
  }
}

class lime_output_color extends lime_output
{
}

class lime_colorizer extends LimeColorizer
{
  protected static
    $instances    = array(),
    $staticStyles = array();

  public function __construct()
  {
    self::$instances[] = $this;
    $this->styles = self::$staticStyles;
  }

  public static function style($name, $options = array())
  {
    foreach (self::$instances as $instance)
    {
      $instance->setStyle($name, $options);
    }
    self::$staticStyles[$name] = $options;
  }
}

class lime_harness extends LimeTestSuite
{
  public function __construct($options = array())
  {
    // for BC
    if (!is_array($options))
    {
      $options = array(); // drop the old output because it is not compatible with LimeTest
    }
    else if (array_key_exists('php_cli', $options))
    {
      $options['executable'] = $options['php_cli'];
      unset($options['php_cli']);
    }

    parent::__construct($options);
  }

  public function to_array()
  {
    return $this->toArray();
  }

  public function to_xml()
  {
    return $this->toXml();
  }

  public function get_failed_files()
  {
    return $this->output->getFailedFiles();
  }
}

class lime_coverage extends LimeCoverage
{
  public static function get_php_lines($content)
  {
    return self::getPhpLines($content);
  }

  public function format_range($lines)
  {
    return $this->formatRange($lines);
  }
}

class lime_registration extends LimeRegistration
{
  public function register_glob($glob)
  {
    return $this->registerGlob($glob);
  }

  public function register_dir($directory)
  {
    return $this->registerDir($directory);
  }
}||||||||||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL)))
        (AST_STATIC_CALL
            (
                (SCALAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ASSIGN
                (AST_VAR)
                (AST_CAST
                    (AST_VAR)))
            (
                (AST_METHOD_CALL
                    (AST_PROP
                        (AST_VAR))
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR)))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_METHOD_CALL
                    (AST_PROP
                        (AST_VAR))
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR)
                        (AST_VAR))))))
    (AST_RETURN
        (AST_VAR)))||||||||