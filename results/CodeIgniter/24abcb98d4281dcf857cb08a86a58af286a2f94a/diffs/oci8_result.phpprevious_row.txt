||||||||	public function previous_row($type = 'object')
	{
		$n = ($this->current_row !== 0) ? $this->current_row - 1 : 0;
		return $this->row($n, $type);
	}

	// --------------------------------------------------------------------

	/**
	 * Data Seek
	 *
	 * Moves the internal pointer to the desired offset. We call
	 * this internally before fetching results to make sure the
	 * result set starts at zero.
	 *
	 * Oracle's PHP extension doesn't have an easy way of doing this
	 * and the only workaround is to (re)execute the statement or cursor
	 * in order to go to the first (zero) index of the result set.
	 * Then, we would need to "dummy" fetch ($n - 1) rows to get to the
	 * right one.
	 *
	 * This is as ridiculous as it sounds and it's the reason why every
	 * other method that is fetching data tries to use an already "cached"
	 * result set. Keeping this just in case it becomes needed at
	 * some point in the future, but it will only work for resetting the
	 * pointer to zero.
	 *
	 * @return	bool
	 */
||||||||||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONDITIONAL
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (SCALAR))
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (SCALAR))
            (SCALAR)))
    (AST_RETURN
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR)
                (AST_VAR)))))