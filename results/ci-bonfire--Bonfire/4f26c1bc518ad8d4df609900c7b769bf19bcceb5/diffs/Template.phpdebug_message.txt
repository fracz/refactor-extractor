    protected static function debug_message($message, $force = false)
        {
        // Only echo the message when in debug mode.
        if (self::$debug) {
            echo $message;
        }

        // Log the message in debug mode or when $force is true.
        if ($force || self::$debug) {
        	logit(self::$log_prefix . $message);
        }
    }
}
//end class

// -----------------------------------------------------------------------------
// Helper Methods
// -----------------------------------------------------------------------------

/**
 * A shorthand method that allows views (from the current/default themes) to be
 * included in any other view.
 *
 * This function also allows for a very simple form of mobile templates. If being
 * viewed from a mobile site, it will attempt to load a file whose name is prefixed
 * with 'mobile_'. If that file is not found it will load the regular view.
 *
 * @example Rendering a view named 'index', the mobile version would be 'mobile_index'.
 *
 * @param string $view          The name of the view to render.
 * @param array  $data          An array of data to pass to the view.
 * @param bool   $ignore_mobile If true, will not change the view name based on mobile viewing. If false, will attempt to load a file prefixed with 'mobile_'
 *
 * @return string
 */
function theme_view($view = null, $data = null, $ignore_mobile = false)
{
    if (empty($view)) {
        return '';
    }

	$output ='';

    // If allowed, try to load the mobile version of the file.
    if (! $ignore_mobile) {
        $ci =& get_instance();

        $ci->load->library('user_agent');
        if ($ci->agent->is_mobile()) {
            Template::load_view("mobile_{$view}", $data, null, true, $output);
		}
	}

    // If output is empty, either mobile is ignored or no mobile file was found.
    if (empty($output)) {
        Template::load_view($view, $data, null, true, $output);
	}

	return $output;
}

/**
 * A simple helper method for checking menu items against the current class/controller.
 *
 * <code>
 *   <a href="<?php echo site_url(SITE_AREA . '/content'); ?>" <?php echo check_class(SITE_AREA . '/content'); ?> >
 *    Admin Home
 *  </a>
 *
 * </code>
 *
 * @param string $item       The name of the class to check against.
 * @param bool   $class_only If true, will only return 'active'. If false, will
 * return 'class="active"'.
 *
 * @return string Either 'active'/'class="active"' or an empty string.
 */
function check_class($item = '', $class_only = false)
{
    if (strtolower(get_instance()->router->fetch_class()) == strtolower($item)) {
		return $class_only ? 'active' : 'class="active"';
	}

	return '';
}

/**
 * A simple helper method for checking menu items against the current method
 * (controller action) (as far as the Router knows).
 *
 * @param string	$item		The name of the method to check against. Can be an array of names.
 * @param bool      $class_only If true, will only return 'active'. If false, will return 'class="active"'.
 *
 * @return string Either 'active'/'class="active"' or an empty string.
 */
function check_method($item, $class_only = false)
{
    $items = is_array($item) ? $item : array($item);
    if (in_array(get_instance()->router->fetch_method(), $items)) {
		return $class_only ? 'active' : 'class="active"';
	}

	return '';
}

/**
 * Checks the $item against the value of the specified URI segment as determined
 * by $this->uri->segment().
 *
 * @param   int     $segment_num    The segment to check the value against.
 * @param   string  $item           The value to check against the segment
 * @param   bool    $class_only     If true, will only return 'active'. If false, will return 'class="active"'.
 *
 * @return string Either 'active'/'class="active"' or an empty string.
 */
function check_segment($segment_num, $item, $class_only = false)
{
    if (get_instance()->uri->segment($segment_num) == $item) {
        return $class_only ? 'active' : 'class="active"';
    }

    return '';
}

/**
 * Will create a breadcrumb from either uri->segments or a key/value paired array.
 *
 * Uses 'template.breadcrumb_symbol' in the config for separators.
 *
 * @param array $my_segments (optional) Array of Key/Value to make Breadcrumbs from
 * @param bool  $wrap        (boolean)  Set to true to wrap in un-ordered list
 * @param bool  $echo        (boolean)  Set to true to echo the output, set to false to return it.
 *
 * @return string A Breadcrumb of the page structure.
 */
function breadcrumb($my_segments = null, $wrap = false, $echo = true)
{
	$ci =& get_instance();

    if (empty($my_segments) || ! is_array($my_segments)) {
        if (! class_exists('CI_URI')) {
		$ci->load->library('uri');
	}
		$segments = $ci->uri->segment_array();
		$total    = $ci->uri->total_segments();
    } else {
		$segments = $my_segments;
		$total    = count($my_segments);
	}

    // Are these segments in the admin section of the site?
    $home_link = site_url(is_array($segments) && in_array(SITE_AREA, $segments) ? SITE_AREA : '');
    $output    = '';
    $separator = $ci->config->item('template.breadcrumb_symbol') == '' ?
        '/' : $ci->config->item('template.breadcrumb_symbol');

    if ($wrap === true) {
        $separator = "<span class='divider'>{$separator}</span>" . PHP_EOL;

        $output  = "<ul class='breadcrumb'>" . PHP_EOL;
        $output .= "<li><a href='{$home_link}'><span class='icon-home'></span></a> {$separator}</li>" . PHP_EOL;
    } else {
        /** @todo Use a lang() value in place of home. */
        $output  = "<a href='{$home_link}'>home</a> {$separator}";
	}

	$url = '';
	$count = 0;

	// URI BASED BREADCRUMB
    if (empty($my_segments) || ! is_array($my_segments)) {
        foreach ($segments as $segment) {
            $url .= "/{$segment}";
            ++$count;

            if ($count == $total) {
                $currentSegment = ucfirst(str_replace('_', ' ', $segment));
                if ($wrap === true) {
                    $output .= "<li class='active'>{$currentSegment}</li>" . PHP_EOL;
                } else {
                    $output .= $currentSegment . PHP_EOL;
				}
            } else {
                $currentSegment = str_replace('_', ' ', ucfirst(mb_strtolower($segment)));
                if ($wrap === true) {
                    $output .= "<li><a href='{$url}'>{$currentSegment}</a>{$separator}</li>" . PHP_EOL;
                } else {
                    $output .= "<a href='{$url}'>{$currentSegment}</a>{$separator}" . PHP_EOL;
			}
		}
	}
    } else {
		// USER-SUPPLIED BREADCRUMB
        foreach ($my_segments as $title => $uri) {
            $url .= "/{$uri}";
            ++$count;

            if ($count == $total) {
                $currentTitle = str_replace('_', ' ', $title);
                if ($wrap === true) {
                    $output .= "<li class='active'>{$currentTitle}</li>" . PHP_EOL;
                } else {
                    $output .= $currentTitle;
				}
            } else {
                $currentTitle = str_replace('_', ' ', ucfirst(mb_strtolower($title)));
                if ($wrap === true) {
                    $output .= "<li><a href='{$url}'>{$currentTitle}</a>{$separator}</li>" . PHP_EOL;
                } else {
                    $output .= "<a href='{$url}'>{$currentTitle}</a>{$separator}" . PHP_EOL;
				}
			}
		}
	}

    if ($wrap === true) {
        $output .= "</ul>" . PHP_EOL;
	}

    if ($echo === true) {
		echo $output;
        return;
	}

    return $output;
}
/* End of file ./application/libraries/template.php */||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_STATIC_PROP)
            (
                (AST_ECHO
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_STATIC_PROP))
            (
                (AST_CALL
                    (
                        (AST_BINARY_OP
                            (AST_STATIC_PROP)
                            (AST_VAR))))))))||||||||