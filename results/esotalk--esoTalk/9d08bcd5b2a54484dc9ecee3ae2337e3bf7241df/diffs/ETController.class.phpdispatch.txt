public function dispatch($method, $arguments)
{
	// Create an array of arguments where the first item is $this.
	$eventArguments = array_merge(array(&$this), $arguments);
	$eventName = $this->className."_".$method;

	// Trigger a "before" event for this method.
	ET::trigger($eventName."_before", $eventArguments);

	// Go through plugins and look for a handler for this controller/method.
	$called = false;
	foreach (ET::$plugins as $plugin) {
		if (method_exists($plugin, $eventName)) {
			call_user_func_array(array($plugin, $eventName), $eventArguments);
			$called = true;
			break;
		}
	}

	// If one wasn't found, call the method on $this.
	if (!$called) call_user_func_array(array($this, $method), $arguments);

	// Trigger an "after" event for this method.
	ET::trigger($eventName."_after", $eventArguments);
}


/**
 * Add a message to be displayed on the page. The messages will also be stored in the session so that if the
 * controller redirects instead of rendering, they will be displayed on the next response.
 *
 * @param string $message The message text.
 * @param mixed $options An array of options. Possible keys include:
 * 		id: a unique ID for the message. If specified, this message will overwrite any previous messages with
 * 			the same ID.
 * 		className: the CSS class to apply to the message.
 * 		callback: a JavaScript function to run when the message is dismissed.
 * 		If $options is a string, it will be used as the className.
 * @return void
 */
||||||||public function dispatch($method, $arguments)
{
	// Create an array of arguments where the first item is $this.
	$eventArguments = array_merge(array(&$this), $arguments);
	$eventName = $this->className."_".$method;

	// Trigger a "before" event for this method.
	ET::trigger($eventName."_before", $eventArguments);

	// Go through plugins and look for a handler for this controller/method.
	$called = false;
	foreach (ET::$plugins as $plugin) {
		if (method_exists($plugin, "action_".$eventName)) {
			call_user_func_array(array($plugin, "action_".$eventName), $eventArguments);
			$called = true;
			break;
		}
	}

	// If one wasn't found, call the method on $this.
	if (!$called) call_user_func_array(array($this, $method), $arguments);

	// Trigger an "after" event for this method.
	ET::trigger($eventName."_after", $eventArguments);
}


/**
 * Add a message to be displayed on the page. The messages will also be stored in the session so that if the
 * controller redirects instead of rendering, they will be displayed on the next response.
 *
 * @param string $message The message text.
 * @param mixed $options An array of options. Possible keys include:
 * 		id: a unique ID for the message. If specified, this message will overwrite any previous messages with
 * 			the same ID.
 * 		className: the CSS class to apply to the message.
 * 		callback: a JavaScript function to run when the message is dismissed.
 * 		If $options is a string, it will be used as the className.
 * @return void
 */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_VAR)
                        (NULL)))
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (SCALAR))
            (AST_VAR)))
    (AST_STATIC_CALL
        (
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONST))
    (AST_FOREACH
        (AST_STATIC_PROP)
        (AST_VAR)
        (NULL)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_CALL
                        (
                            (AST_VAR)
                            (AST_VAR)))
                    (
                        (AST_CALL
                            (
                                (AST_ARRAY
                                    (AST_ARRAY_ELEM
                                        (AST_VAR)
                                        (NULL))
                                    (AST_ARRAY_ELEM
                                        (AST_VAR)
                                        (NULL)))
                                (AST_VAR)))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_CONST))
                        (AST_BREAK
                            (NULL)))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_CALL
                    (
                        (AST_ARRAY
                            (AST_ARRAY_ELEM
                                (AST_VAR)
                                (NULL))
                            (AST_ARRAY_ELEM
                                (AST_VAR)
                                (NULL)))
                        (AST_VAR))))))
    (AST_STATIC_CALL
        (
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (AST_VAR))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_ARRAY
                    (AST_ARRAY_ELEM
                        (AST_VAR)
                        (NULL)))
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (AST_PROP
                    (AST_VAR))
                (SCALAR))
            (AST_VAR)))
    (AST_STATIC_CALL
        (
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CONST))
    (AST_FOREACH
        (AST_STATIC_PROP)
        (AST_VAR)
        (NULL)
        (
            (AST_IF
                (AST_IF_ELEM
                    (AST_CALL
                        (
                            (AST_VAR)
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_VAR))))
                    (
                        (AST_CALL
                            (
                                (AST_ARRAY
                                    (AST_ARRAY_ELEM
                                        (AST_VAR)
                                        (NULL))
                                    (AST_ARRAY_ELEM
                                        (AST_BINARY_OP
                                            (SCALAR)
                                            (AST_VAR))
                                        (NULL)))
                                (AST_VAR)))
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_CONST))
                        (AST_BREAK
                            (NULL)))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_CALL
                    (
                        (AST_ARRAY
                            (AST_ARRAY_ELEM
                                (AST_VAR)
                                (NULL))
                            (AST_ARRAY_ELEM
                                (AST_VAR)
                                (NULL)))
                        (AST_VAR))))))
    (AST_STATIC_CALL
        (
            (AST_BINARY_OP
                (AST_VAR)
                (SCALAR))
            (AST_VAR))))