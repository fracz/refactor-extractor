	static function pull($source,$token,$dir,$file){
		$tmpfile=tempnam(sys_get_temp_dir(),'remoteCloudFile');
		$fp=fopen($tmpfile,'w+');
		$url=$source.="/files/pull.php?token=$token";
		$ch=curl_init();
		curl_setopt($ch,CURLOPT_URL,$url);
		curl_setopt($ch, CURLOPT_FILE, $fp);
		curl_exec($ch);
		fclose($fp);
		$info=curl_getinfo($ch);
		$httpCode=$info['http_code'];
		curl_close($ch);
		if($httpCode==200 or $httpCode==0){
			OC_FILESYSTEM::fromTmpFile($tmpfile,$dir.'/'.$file);
			return true;
		}else{
			return false;
		}
	}
}

function zipAddDir($dir,$zip,$internalDir=''){
    $dirname=basename($dir);
    $zip->addEmptyDir($internalDir.$dirname);
    $internalDir.=$dirname.='/';
    $files=OC_FILES::getdirectorycontent($dir);
    foreach($files as $file){
        $filename=$file['name'];
        $file=$dir.'/'.$filename;
        if(OC_FILESYSTEM::is_file($file)){
			$tmpFile=OC_FILESYSTEM::toTmpFile($file);
			OC_FILES::$tmpFiles[]=$tmpFile;
            $zip->addFile($tmpFile,$internalDir.$filename);
        }elseif(OC_FILESYSTEM::is_dir($file)){
            zipAddDir($file,$zip,$internalDir);
        }
    }
}

//remove a dir and it's content
function delTree($dir) {
	if (!file_exists($dir)) return true;
	if (!is_dir($dir) || is_link($dir)) return unlink($dir);
	foreach (scandir($dir) as $item) {
		if ($item == '.' || $item == '..') continue;
		if(is_file($dir.'/'.$item)){
			unlink($dir.'/'.$item);
		}elseif(is_dir($dir.'/'.$item)){
			if (!delTree($dir. "/" . $item)){
				return false;
			};
		}
	}
	$return=rmdir($dir);
	return $return;
}

if(!function_exists('sys_get_temp_dir')) {
    function sys_get_temp_dir() {
        if( $temp=getenv('TMP') )        return $temp;
        if( $temp=getenv('TEMP') )        return $temp;
        if( $temp=getenv('TMPDIR') )    return $temp;
        $temp=tempnam(__FILE__,'');
        if (file_exists($temp)) {
          unlink($temp);
          return dirname($temp);
        }
        return null;
    }
}

function recursive_copy($src,$dst) {
	$dir = opendir($src);
	@mkdir($dst);
	while(false !== ( $file = readdir($dir)) ) {
		if (( $file != '.' ) && ( $file != '..' )) {
			if ( is_dir($src . '/' . $file) ) {
				recursive_copy($src . '/' . $file,$dst . '/' . $file);
			}
			else {
				copy($src . '/' . $file,$dst . '/' . $file);
			}
		}
	}
	closedir($dir);
}

global $FAKEDIRS;
$FAKEDIRS=array();

class fakeDirStream{
	private $name;
	private $data;
	private $index;

	public function dir_opendir($path,$options){
		global $FAKEDIRS;
		$url=parse_url($path);
		$this->name=substr($path,strlen('fakedir://'));
		$this->index=0;
		if(isset($FAKEDIRS[$this->name])){
			$this->data=$FAKEDIRS[$this->name];
		}else{
			$this->data=array();
		}
		return true;
	}

	public function dir_readdir(){
		if($this->index>=count($this->data)){
			return false;
		}
		$filename=$this->data[$this->index];
		$this->index++;
		return $filename;
	}

	public function dir_closedir() {
		$this->data=false;
		$this->name='';
		return true;
	}

	public function dir_rewinddir() {
		$this->index=0;
		return true;
	}
}
stream_wrapper_register("fakedir", "fakeDirStream");
?>||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_CALL)
                (SCALAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR)
                (SCALAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ASSIGN_OP
            (AST_VAR)
            (AST_ENCAPS_LIST
                (SCALAR)
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL))
    (AST_CALL
        (
            (AST_VAR)
            (AST_CONST)
            (AST_VAR)))
    (AST_CALL
        (
            (AST_VAR)
            (AST_CONST)
            (AST_VAR)))
    (AST_CALL
        (
            (AST_VAR)))
    (AST_CALL
        (
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_DIM
            (AST_VAR)
            (SCALAR)))
    (AST_CALL
        (
            (AST_VAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_VAR)
                    (SCALAR))
                (AST_BINARY_OP
                    (AST_VAR)
                    (SCALAR)))
            (
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_BINARY_OP
                            (AST_BINARY_OP
                                (AST_VAR)
                                (SCALAR))
                            (AST_VAR))))
                (AST_RETURN
                    (AST_CONST))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_RETURN
                    (AST_CONST))))))||||||||