    function parseResponse($data = '')
    {
        global $XML_RPC_xh, $XML_RPC_err, $XML_RPC_str, $XML_RPC_defencoding;

        $encoding = $this->getEncoding($data);
        $parser_resource = xml_parser_create($encoding);
        $parser = (int) $parser_resource;

        $XML_RPC_xh = array();
        $XML_RPC_xh[$parser] = array();

        $XML_RPC_xh[$parser]['cm'] = 0;
        $XML_RPC_xh[$parser]['isf'] = 0;
        $XML_RPC_xh[$parser]['ac'] = '';
        $XML_RPC_xh[$parser]['qt'] = '';
        $XML_RPC_xh[$parser]['stack'] = array();
        $XML_RPC_xh[$parser]['valuestack'] = array();

        xml_parser_set_option($parser_resource, XML_OPTION_CASE_FOLDING, true);
        xml_set_element_handler($parser_resource, 'XML_RPC_se', 'XML_RPC_ee');
        xml_set_character_data_handler($parser_resource, 'XML_RPC_cd');

        $hdrfnd = 0;
        if ($this->debug) {
            print "\n<pre>---GOT---\n";
            print isset($_SERVER['SERVER_PROTOCOL']) ? htmlspecialchars($data) : $data;
            print "\n---END---</pre>\n";
        }

        // See if response is a 200 or a 100 then a 200, else raise error.
        // But only do this if we're using the HTTP protocol.
        if (ereg('^HTTP', $data) &&
            !ereg('^HTTP/[0-9\.]+ 200 ', $data) &&
            !preg_match('@^HTTP/[0-9\.]+ 10[0-9]([A-Za-z ]+)?[\r\n]+HTTP/[0-9\.]+ 200@', $data))
        {
                $errstr = substr($data, 0, strpos($data, "\n") - 1);
                error_log('HTTP error, got response: ' . $errstr);
                $r = new XML_RPC_Response(0, $XML_RPC_err['http_error'],
                                          $XML_RPC_str['http_error'] . ' (' .
                                          $errstr . ')');
                xml_parser_free($parser_resource);
                return $r;
        }

        // gotta get rid of headers here
        if (!$hdrfnd && ($brpos = strpos($data,"\r\n\r\n"))) {
            $XML_RPC_xh[$parser]['ha'] = substr($data, 0, $brpos);
            $data = substr($data, $brpos + 4);
            $hdrfnd = 1;
        }

        /*
         * be tolerant of junk after methodResponse
         * (e.g. javascript automatically inserted by free hosts)
         * thanks to Luca Mariano <luca.mariano@email.it>
         */
        $data = substr($data, 0, strpos($data, "</methodResponse>") + 17);

        if (!xml_parse($parser_resource, $data, sizeof($data))) {
            // thanks to Peter Kocks <peter.kocks@baygate.com>
            if (xml_get_current_line_number($parser_resource) == 1) {
                $errstr = 'XML error at line 1, check URL';
            } else {
                $errstr = sprintf('XML error: %s at line %d',
                                  xml_error_string(xml_get_error_code($parser_resource)),
                                  xml_get_current_line_number($parser_resource));
            }
            error_log($errstr);
            $r = new XML_RPC_Response(0, $XML_RPC_err['invalid_return'],
                                      $XML_RPC_str['invalid_return']);
            xml_parser_free($parser_resource);
            return $r;
        }

        xml_parser_free($parser_resource);

        if ($this->debug) {
            print "\n<pre>---PARSED---\n";
            var_dump($XML_RPC_xh[$parser]['value']);
            print "---END---</pre>\n";
        }

        if ($XML_RPC_xh[$parser]['isf'] > 1) {
            $r = new XML_RPC_Response(0, $XML_RPC_err['invalid_return'],
                                      $XML_RPC_str['invalid_return'].' '.$XML_RPC_xh[$parser]['isf_reason']);
        } elseif (!is_object($XML_RPC_xh[$parser]['value'])) {
            // then something odd has happened
            // and it's time to generate a client side error
            // indicating something odd went on
            $r = new XML_RPC_Response(0, $XML_RPC_err['invalid_return'],
                                      $XML_RPC_str['invalid_return']);
        } else {
            $v = $XML_RPC_xh[$parser]['value'];
            $allOK=1;
            if ($XML_RPC_xh[$parser]['isf']) {
                $f = $v->structmem('faultCode');
                $fs = $v->structmem('faultString');
                $r = new XML_RPC_Response($v, $f->scalarval(),
                                          $fs->scalarval());
            } else {
                $r = new XML_RPC_Response($v);
            }
        }
        $r->hdrs = split("\r?\n", $XML_RPC_xh[$parser]['ha'][1]);
        return $r;
    }
}

/**
 * The methods and properties that represent data in XML RPC format
 *
 * @category   Web Services
 * @package    XML_RPC
 * @author     Edd Dumbill <edd@usefulinc.com>
 * @author     Stig Bakken <stig@php.net>
 * @author     Martin Jansen <mj@php.net>
 * @author     Daniel Convissor <danielc@php.net>
 * @copyright  1999-2001 Edd Dumbill, 2001-2005 The PHP Group
 * @version    Release: 1.4.0
 * @link       http://pear.php.net/package/XML_RPC
 */
class XML_RPC_Value extends XML_RPC_Base
{
    var $me = array();
    var $mytype = 0;

    /**
     * @return void
     */
    function XML_RPC_Value($val = -1, $type = '')
    {
        global $XML_RPC_Types;
        $this->me = array();
        $this->mytype = 0;
        if ($val != -1 || $type != '') {
            if ($type == '') {
                $type = 'string';
            }
            if (!array_key_exists($type, $XML_RPC_Types)) {
                // XXX
                // need some way to report this error
            } elseif ($XML_RPC_Types[$type] == 1) {
                $this->addScalar($val, $type);
            } elseif ($XML_RPC_Types[$type] == 2) {
                $this->addArray($val);
            } elseif ($XML_RPC_Types[$type] == 3) {
                $this->addStruct($val);
            }
        }
    }

    /**
     * @return int  returns 1 if successful or 0 if there are problems
     */
    function addScalar($val, $type = 'string')
    {
        global $XML_RPC_Types, $XML_RPC_Boolean;

        if ($this->mytype == 1) {
            $this->raiseError('Scalar can have only one value',
                              XML_RPC_ERROR_INVALID_TYPE);
            return 0;
        }
        $typeof = $XML_RPC_Types[$type];
        if ($typeof != 1) {
            $this->raiseError("Not a scalar type (${typeof})",
                              XML_RPC_ERROR_INVALID_TYPE);
            return 0;
        }

        if ($type == $XML_RPC_Boolean) {
            if (strcasecmp($val, 'true') == 0
                || $val == 1
                || ($val == true && strcasecmp($val, 'false')))
            {
                $val = 1;
            } else {
                $val = 0;
            }
        }

        if ($this->mytype == 2) {
            // we're adding to an array here
            $ar = $this->me['array'];
            $ar[] = new XML_RPC_Value($val, $type);
            $this->me['array'] = $ar;
        } else {
            // a scalar, so set the value and remember we're scalar
            $this->me[$type] = $val;
            $this->mytype = $typeof;
        }
        return 1;
    }

    /**
     * @return int  returns 1 if successful or 0 if there are problems
     */
    function addArray($vals)
    {
        global $XML_RPC_Types;
        if ($this->mytype != 0) {
            $this->raiseError(
                    'Already initialized as a [' . $this->kindOf() . ']',
                    XML_RPC_ERROR_ALREADY_INITIALIZED);
            return 0;
        }
        $this->mytype = $XML_RPC_Types['array'];
        $this->me['array'] = $vals;
        return 1;
    }

    /**
     * @return int  returns 1 if successful or 0 if there are problems
     */
    function addStruct($vals)
    {
        global $XML_RPC_Types;
        if ($this->mytype != 0) {
            $this->raiseError(
                    'Already initialized as a [' . $this->kindOf() . ']',
                    XML_RPC_ERROR_ALREADY_INITIALIZED);
            return 0;
        }
        $this->mytype = $XML_RPC_Types['struct'];
        $this->me['struct'] = $vals;
        return 1;
    }

    /**
     * @return void
     */
    function dump($ar)
    {
        reset($ar);
        foreach ($ar as $key => $val) {
            echo "$key => $val<br />";
            if ($key == 'array') {
                foreach ($val as $key2 => $val2) {
                    echo "-- $key2 => $val2<br />";
                }
            }
        }
    }

    /**
     * @return string  the data type of the current value
     */
    function kindOf()
    {
        switch ($this->mytype) {
        case 3:
            return 'struct';

        case 2:
            return 'array';

        case 1:
            return 'scalar';

        default:
            return 'undef';
        }
    }

    /**
     * @return string  the data in XML format
     */
    function serializedata($typ, $val)
    {
        $rs = '';
        global $XML_RPC_Types, $XML_RPC_Base64, $XML_RPC_String, $XML_RPC_Boolean;
        if (!array_key_exists($typ, $XML_RPC_Types)) {
            // XXX
            // need some way to report this error
            return;
        }
        switch ($XML_RPC_Types[$typ]) {
        case 3:
            // struct
            $rs .= "<struct>\n";
            reset($val);
            foreach ($val as $key2 => $val2) {
                $rs .= "<member><name>${key2}</name>\n";
                $rs .= $this->serializeval($val2);
                $rs .= "</member>\n";
            }
            $rs .= '</struct>';
            break;

        case 2:
            // array
            $rs .= "<array>\n<data>\n";
            for ($i = 0; $i < sizeof($val); $i++) {
                $rs .= $this->serializeval($val[$i]);
            }
            $rs .= "</data>\n</array>";
            break;

        case 1:
            switch ($typ) {
            case $XML_RPC_Base64:
                $rs .= "<${typ}>" . base64_encode($val) . "</${typ}>";
                break;
            case $XML_RPC_Boolean:
                $rs .= "<${typ}>" . ($val ? '1' : '0') . "</${typ}>";
                break;
            case $XML_RPC_String:
                $rs .= "<${typ}>" . htmlspecialchars($val). "</${typ}>";
                break;
            default:
                $rs .= "<${typ}>${val}</${typ}>";
            }
        }
        return $rs;
    }

    /**
     * @return string  the data in XML format
     */
    function serialize()
    {
        return $this->serializeval($this);
    }

    /**
     * @return string  the data in XML format
     */
    function serializeval($o)
    {
        if (!is_object($o) || empty($o->me) || !is_array($o->me)) {
            return '';
        }
        $ar = $o->me;
        reset($ar);
        list($typ, $val) = each($ar);
        return '<value>' .  $this->serializedata($typ, $val) .  "</value>\n";
    }

    /**
     * @return mixed  the contents of the element requested
     */
    function structmem($m)
    {
        return $this->me['struct'][$m];
    }

    /**
     * @return void
     */
    function structreset()
    {
        reset($this->me['struct']);
    }

    /**
     * @return  the key/value pair of the struct's current element
     */
    function structeach()
    {
        return each($this->me['struct']);
    }

    /**
     * @return mixed  the current value
     */
    function getval()
    {
        // UNSTABLE
        global $XML_RPC_BOOLEAN, $XML_RPC_Base64;

        reset($this->me);
        $b = current($this->me);

        // contributed by I Sofer, 2001-03-24
        // add support for nested arrays to scalarval
        // i've created a new method here, so as to
        // preserve back compatibility

        if (is_array($b)) {
            foreach ($b as $id => $cont) {
                $b[$id] = $cont->scalarval();
            }
        }

        // add support for structures directly encoding php objects
        if (is_object($b)) {
            $t = get_object_vars($b);
            foreach ($t as $id => $cont) {
                $t[$id] = $cont->scalarval();
            }
            foreach ($t as $id => $cont) {
                $b->$id = $cont;
            }
        }

        // end contrib
        return $b;
    }

    /**
     * @return mixed
     */
    function scalarval()
    {
        global $XML_RPC_Boolean, $XML_RPC_Base64;
        reset($this->me);
        return current($this->me);
    }

    /**
     * @return string
     */
    function scalartyp()
    {
        global $XML_RPC_I4, $XML_RPC_Int;
        reset($this->me);
        $a = key($this->me);
        if ($a == $XML_RPC_I4) {
            $a = $XML_RPC_Int;
        }
        return $a;
    }

    /**
     * @return mixed  the struct's current element
     */
    function arraymem($m)
    {
        return $this->me['array'][$m];
    }

    /**
     * @return int  the number of elements in the array
     */
    function arraysize()
    {
        reset($this->me);
        list($a, $b) = each($this->me);
        return sizeof($b);
    }

    /**
     * Determines if the item submitted is an XML_RPC_Value object
     *
     * @param mixed $val  the variable to be evaluated
     *
     * @return bool  TRUE if the item is an XML_RPC_Value object
     *
     * @static
     * @since Method available since Release 1.3.0
     */
    function isValue($val)
    {
        return (strtolower(get_class($val)) == 'xml_rpc_value');
    }
}

/**
 * Return an ISO8601 encoded string
 *
 * While timezones ought to be supported, the XML-RPC spec says:
 *
 * "Don't assume a timezone. It should be specified by the server in its
 * documentation what assumptions it makes about timezones."
 *
 * This routine always assumes localtime unless $utc is set to 1, in which
 * case UTC is assumed and an adjustment for locale is made when encoding.
 *
 * @return string  the formatted date
 */
function XML_RPC_iso8601_encode($timet, $utc = 0)
{
    if (!$utc) {
        $t = strftime('%Y%m%dT%H:%M:%S', $timet);
    } else {
        if (function_exists('gmstrftime')) {
            // gmstrftime doesn't exist in some versions
            // of PHP
            $t = gmstrftime('%Y%m%dT%H:%M:%S', $timet);
        } else {
            $t = strftime('%Y%m%dT%H:%M:%S', $timet - date('Z'));
        }
    }
    return $t;
}

/**
 * Convert a datetime string into a Unix timestamp
 *
 * While timezones ought to be supported, the XML-RPC spec says:
 *
 * "Don't assume a timezone. It should be specified by the server in its
 * documentation what assumptions it makes about timezones."
 *
 * This routine always assumes localtime unless $utc is set to 1, in which
 * case UTC is assumed and an adjustment for locale is made when encoding.
 *
 * @return int  the unix timestamp of the date submitted
 */
function XML_RPC_iso8601_decode($idate, $utc = 0)
{
    $t = 0;
    if (ereg('([0-9]{4})([0-9]{2})([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})', $idate, $regs)) {
        if ($utc) {
            $t = gmmktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);
        } else {
            $t = mktime($regs[4], $regs[5], $regs[6], $regs[2], $regs[3], $regs[1]);
        }
    }
    return $t;
}

/**
 * Converts an XML_RPC_Value object into native PHP types
 *
 * @param object $XML_RPC_val  the XML_RPC_Value object to decode
 *
 * @return mixed  the PHP values
 */
function XML_RPC_decode($XML_RPC_val)
{
    $kind = $XML_RPC_val->kindOf();

    if ($kind == 'scalar') {
        return $XML_RPC_val->scalarval();

    } elseif ($kind == 'array') {
        $size = $XML_RPC_val->arraysize();
        $arr = array();
        for ($i = 0; $i < $size; $i++) {
            $arr[] = XML_RPC_decode($XML_RPC_val->arraymem($i));
        }
        return $arr;

    } elseif ($kind == 'struct') {
        $XML_RPC_val->structreset();
        $arr = array();
        while (list($key, $value) = $XML_RPC_val->structeach()) {
            $arr[$key] = XML_RPC_decode($value);
        }
        return $arr;
    }
}

/**
 * Converts native PHP types into an XML_RPC_Value object
 *
 * @param mixed $php_val  the PHP value or variable you want encoded
 *
 * @return object  the XML_RPC_Value object
 */
function XML_RPC_encode($php_val)
{
    global $XML_RPC_Boolean, $XML_RPC_Int, $XML_RPC_Double, $XML_RPC_String,
           $XML_RPC_Array, $XML_RPC_Struct;

    $type = gettype($php_val);
    $XML_RPC_val = new XML_RPC_Value;

    switch ($type) {
    case 'array':
        if (empty($php_val)) {
            $XML_RPC_val->addArray($php_val);
            break;
        }
        $tmp = array_diff(array_keys($php_val), range(0, count($php_val)-1));
        if (empty($tmp)) {
           $arr = array();
           foreach ($php_val as $k => $v) {
               $arr[$k] = XML_RPC_encode($v);
           }
           $XML_RPC_val->addArray($arr);
           break;
        }
        // fall though if it's not an enumerated array

    case 'object':
        $arr = array();
        foreach ($php_val as $k => $v) {
            $arr[$k] = XML_RPC_encode($v);
        }
        $XML_RPC_val->addStruct($arr);
        break;

    case 'integer':
        $XML_RPC_val->addScalar($php_val, $XML_RPC_Int);
        break;

    case 'double':
        $XML_RPC_val->addScalar($php_val, $XML_RPC_Double);
        break;

    case 'string':
    case 'NULL':
        $XML_RPC_val->addScalar($php_val, $XML_RPC_String);
        break;

    case 'boolean':
        // Add support for encoding/decoding of booleans, since they
        // are supported in PHP
        // by <G_Giunta_2001-02-29>
        $XML_RPC_val->addScalar($php_val, $XML_RPC_Boolean);
        break;

    case 'unknown type':
    default:
        $XML_RPC_val = false;
    }
    return $XML_RPC_val;
}

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */

?>||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_GLOBAL
        (AST_VAR))
    (AST_GLOBAL
        (AST_VAR))
    (AST_GLOBAL
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CAST
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (AST_VAR))
        (AST_ARRAY))
    (AST_ASSIGN
        (AST_DIM
            (AST_DIM
                (AST_VAR)
                (AST_VAR))
            (SCALAR))
        (SCALAR))
    (AST_ASSIGN
        (AST_DIM
            (AST_DIM
                (AST_VAR)
                (AST_VAR))
            (SCALAR))
        (SCALAR))
    (AST_ASSIGN
        (AST_DIM
            (AST_DIM
                (AST_VAR)
                (AST_VAR))
            (SCALAR))
        (SCALAR))
    (AST_ASSIGN
        (AST_DIM
            (AST_DIM
                (AST_VAR)
                (AST_VAR))
            (SCALAR))
        (SCALAR))
    (AST_ASSIGN
        (AST_DIM
            (AST_DIM
                (AST_VAR)
                (AST_VAR))
            (SCALAR))
        (AST_ARRAY))
    (AST_ASSIGN
        (AST_DIM
            (AST_DIM
                (AST_VAR)
                (AST_VAR))
            (SCALAR))
        (AST_ARRAY))
    (AST_CALL
        (
            (AST_VAR)
            (AST_CONST)
            (AST_CONST)))
    (AST_CALL
        (
            (AST_VAR)
            (SCALAR)
            (SCALAR)))
    (AST_CALL
        (
            (AST_VAR)
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_PRINT
                    (SCALAR))
                (AST_PRINT
                    (AST_CONDITIONAL
                        (AST_ISSET
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR)))
                        (AST_CALL
                            (
                                (AST_VAR)))
                        (AST_VAR)))
                (AST_PRINT
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_CALL
                        (
                            (SCALAR)
                            (AST_VAR)))
                    (AST_UNARY_OP
                        (AST_CALL
                            (
                                (SCALAR)
                                (AST_VAR)))))
                (AST_UNARY_OP
                    (AST_CALL
                        (
                            (SCALAR)
                            (AST_VAR)))))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_VAR)
                            (SCALAR)
                            (AST_BINARY_OP
                                (AST_CALL
                                    (
                                        (AST_VAR)
                                        (SCALAR)))
                                (SCALAR)))))
                (AST_CALL
                    (
                        (AST_BINARY_OP
                            (SCALAR)
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (SCALAR)
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR))
                            (AST_BINARY_OP
                                (AST_BINARY_OP
                                    (AST_BINARY_OP
                                        (AST_DIM
                                            (AST_VAR)
                                            (SCALAR))
                                        (SCALAR))
                                    (AST_VAR))
                                (SCALAR)))))
                (AST_CALL
                    (
                        (AST_VAR)))
                (AST_RETURN
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_UNARY_OP
                    (AST_VAR))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_VAR)
                            (SCALAR)))))
            (
                (AST_ASSIGN
                    (AST_DIM
                        (AST_DIM
                            (AST_VAR)
                            (AST_VAR))
                        (SCALAR))
                    (AST_CALL
                        (
                            (AST_VAR)
                            (SCALAR)
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_CALL
                        (
                            (AST_VAR)
                            (AST_BINARY_OP
                                (AST_VAR)
                                (SCALAR)))))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR)
                (SCALAR)
                (AST_BINARY_OP
                    (AST_CALL
                        (
                            (AST_VAR)
                            (SCALAR)))
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_CALL
                    (
                        (AST_VAR)
                        (AST_VAR)
                        (AST_CALL
                            (
                                (AST_VAR))))))
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_BINARY_OP
                            (AST_CALL
                                (
                                    (AST_VAR)))
                            (SCALAR))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (SCALAR))))
                    (AST_IF_ELEM
                        (NULL)
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_CALL
                                    (
                                        (SCALAR)
                                        (AST_CALL
                                            (
                                                (AST_CALL
                                                    (
                                                        (AST_VAR)))))
                                        (AST_CALL
                                            (
                                                (AST_VAR)))))))))
                (AST_CALL
                    (
                        (AST_VAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (SCALAR)
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR))
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR)))))
                (AST_CALL
                    (
                        (AST_VAR)))
                (AST_RETURN
                    (AST_VAR)))))
    (AST_CALL
        (
            (AST_VAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_PRINT
                    (SCALAR))
                (AST_CALL
                    (
                        (AST_DIM
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR))
                            (SCALAR))))
                (AST_PRINT
                    (SCALAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_DIM
                    (AST_DIM
                        (AST_VAR)
                        (AST_VAR))
                    (SCALAR))
                (SCALAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (SCALAR)
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR))
                            (AST_BINARY_OP
                                (AST_BINARY_OP
                                    (AST_DIM
                                        (AST_VAR)
                                        (SCALAR))
                                    (SCALAR))
                                (AST_DIM
                                    (AST_DIM
                                        (AST_VAR)
                                        (AST_VAR))
                                    (SCALAR))))))))
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_CALL
                    (
                        (AST_DIM
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR))
                            (SCALAR)))))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (SCALAR)
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR))
                            (AST_DIM
                                (AST_VAR)
                                (SCALAR)))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_DIM
                        (AST_DIM
                            (AST_VAR)
                            (AST_VAR))
                        (SCALAR)))
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_DIM
                            (AST_DIM
                                (AST_VAR)
                                (AST_VAR))
                            (SCALAR))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_METHOD_CALL
                                    (AST_VAR)
                                    (
                                        (SCALAR))))
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_METHOD_CALL
                                    (AST_VAR)
                                    (
                                        (SCALAR))))
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_NEW
                                    (
                                        (AST_VAR)
                                        (AST_METHOD_CALL
                                            (AST_VAR))
                                        (AST_METHOD_CALL
                                            (AST_VAR)))))))
                    (AST_IF_ELEM
                        (NULL)
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_NEW
                                    (
                                        (AST_VAR))))))))))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_CALL
            (
                (SCALAR)
                (AST_DIM
                    (AST_DIM
                        (AST_DIM
                            (AST_VAR)
                            (AST_VAR))
                        (SCALAR))
                    (SCALAR)))))
    (AST_RETURN
        (AST_VAR)))||||||||