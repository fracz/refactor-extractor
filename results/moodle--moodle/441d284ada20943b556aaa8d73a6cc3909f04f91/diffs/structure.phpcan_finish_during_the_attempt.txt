||||||||    public function can_finish_during_the_attempt($slotnumber) {
        if ($this->quizobj->get_quiz()->shufflequestions ||
                $this->quizobj->get_navigation_method() == QUIZ_NAVMETHOD_SEQ) {
            return false;
        }

        if ($this->get_question_type_for_slot($slotnumber) == 'random') {
            return true;
        }

        if (isset($this->slotsinorder[$slotnumber]->canfinish)) {
            return $this->slotsinorder[$slotnumber]->canfinish;
        }

        $quba = \question_engine::make_questions_usage_by_activity('mod_quiz', $this->quizobj->get_context());
        $tempslot = $quba->add_question(\question_bank::load_question(
                $this->slotsinorder[$slotnumber]->questionid));
        $quba->set_preferred_behaviour($this->quizobj->get_quiz()->preferredbehaviour);
        $quba->start_all_questions();

        $this->slotsinorder[$slotnumber]->canfinish = $quba->can_question_finish_during_attempt($tempslot);
        return $this->slotsinorder[$slotnumber]->canfinish;
    }

    /**
     * Whether it would be possible, given the question types, etc. for the
     * question in the given slot to require that the previous question had been
     * answered before this one is displayed.
     * @param int $slotnumber the index of the slot in question.
     * @return bool can this question require the previous one.
     */
||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_PROP
                    (AST_METHOD_CALL
                        (AST_PROP
                            (AST_VAR))))
                (AST_BINARY_OP
                    (AST_METHOD_CALL
                        (AST_PROP
                            (AST_VAR)))
                    (AST_CONST)))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_VAR)))
                (SCALAR))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ISSET
                (AST_PROP
                    (AST_DIM
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_PROP
                        (AST_DIM
                            (AST_PROP
                                (AST_VAR))
                            (AST_VAR)))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (SCALAR)
                (AST_METHOD_CALL
                    (AST_PROP
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_STATIC_CALL
                    (
                        (AST_PROP
                            (AST_DIM
                                (AST_PROP
                                    (AST_VAR))
                                (AST_VAR))))))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_PROP
                (AST_METHOD_CALL
                    (AST_PROP
                        (AST_VAR))))))
    (AST_METHOD_CALL
        (AST_VAR))
    (AST_ASSIGN
        (AST_PROP
            (AST_DIM
                (AST_PROP
                    (AST_VAR))
                (AST_VAR)))
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_RETURN
        (AST_PROP
            (AST_DIM
                (AST_PROP
                    (AST_VAR))
                (AST_VAR)))))