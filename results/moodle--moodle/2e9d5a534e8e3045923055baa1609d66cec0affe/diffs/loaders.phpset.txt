    public function set($key, $data) {
        $this->check_tracked_user();
        if ($this->perfdebug) {
            cache_helper::record_cache_set('**static session**', $this->get_definition()->get_id());
        }
        if (is_object($data) && $data instanceof cacheable_object) {
            $data = new cache_cached_object($data);
        } else if (!is_scalar($data)) {
            // If data is an object it will be a reference.
            // If data is an array if may contain references.
            // We want to break references so that the cache cannot be modified outside of itself.
            // Call the function to unreference it (in the best way possible).
            $data = $this->unref($data);
        }
        // We dont' support native TTL here as we consolidate data for sessions.
        if ($this->has_a_ttl()) {
            $data = new cache_ttl_wrapper($data, $this->get_definition()->get_ttl());
        }
        $session = $this->get_session_data();
        $session[$this->parse_key($key)] = $data;
        return $this->save_session($session);
    }

    /**
     * Delete the given key from the cache.
     *
     * @param string|int $key The key to delete.
     * @param bool $recurse When set to true the key will also be deleted from all stacked cache loaders and their stores.
     *     This happens by default and ensure that all the caches are consistent. It is NOT recommended to change this.
     * @return bool True of success, false otherwise.
     */
||||||||    public function set($key, $data) {
        $this->check_tracked_user();
        if ($this->perfdebug) {
            cache_helper::record_cache_set($this->storetype, $this->get_definition()->get_id());
        }
        if (is_object($data) && $data instanceof cacheable_object) {
            $data = new cache_cached_object($data);
        } else if (!is_scalar($data)) {
            // If data is an object it will be a reference.
            // If data is an array if may contain references.
            // We want to break references so that the cache cannot be modified outside of itself.
            // Call the function to unreference it (in the best way possible).
            $data = $this->unref($data);
        }
        // We dont' support native TTL here as we consolidate data for sessions.
        if ($this->has_a_ttl() && !$this->store_supports_native_ttl()) {
            $data = new cache_ttl_wrapper($data, $this->get_definition()->get_ttl());
        }
        return $this->get_store()->set($this->parse_key($key), $data);
    }

    /**
     * Delete the given key from the cache.
     *
     * @param string|int $key The key to delete.
     * @param bool $recurse When set to true the key will also be deleted from all stacked cache loaders and their stores.
     *     This happens by default and ensure that all the caches are consistent. It is NOT recommended to change this.
     * @return bool True of success, false otherwise.
     */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_METHOD_CALL
        (AST_VAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_STATIC_CALL
                    (
                        (SCALAR)
                        (AST_METHOD_CALL
                            (AST_METHOD_CALL
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_VAR)))
                (AST_INSTANCEOF
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (AST_VAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_UNARY_OP
                            (AST_CALL
                                (
                                    (AST_VAR))))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_METHOD_CALL
                                    (AST_VAR)
                                    (
                                        (AST_VAR))))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (AST_VAR)
                            (AST_METHOD_CALL
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_VAR)
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR))))
        (AST_VAR))
    (AST_RETURN
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR)))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_METHOD_CALL
        (AST_VAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_STATIC_CALL
                    (
                        (AST_PROP
                            (AST_VAR))
                        (AST_METHOD_CALL
                            (AST_METHOD_CALL
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_VAR)))
                (AST_INSTANCEOF
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (AST_VAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_UNARY_OP
                            (AST_CALL
                                (
                                    (AST_VAR))))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_METHOD_CALL
                                    (AST_VAR)
                                    (
                                        (AST_VAR))))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_METHOD_CALL
                    (AST_VAR))
                (AST_UNARY_OP
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_NEW
                        (
                            (AST_VAR)
                            (AST_METHOD_CALL
                                (AST_METHOD_CALL
                                    (AST_VAR)))))))))
    (AST_RETURN
        (AST_METHOD_CALL
            (AST_METHOD_CALL
                (AST_VAR))
            (
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_VAR)))
                (AST_VAR)))))