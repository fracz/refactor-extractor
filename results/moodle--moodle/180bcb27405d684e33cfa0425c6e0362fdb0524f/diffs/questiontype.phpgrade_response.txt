    function grade_response($question, $nameprefix) {
        /// Determines the answers and then lets the
        /// NUMERICAL question type take care of the
        /// grading...

        list($datasetnumber, $individualdata) =
        $this->parse_datasetinput($question->response[$nameprefix]);

        // find the raw answer material
        global $CFG;
        if (!($answers = $this->get_answers($question))) {
            notify("Error no answers found for question $question->id");
        }

        /// Find a default unit:
        if ($unit = get_record('quiz_numerical_units',
                'question', $question->id, 'multiplier', 1.0)) {
            $unit = $unit->unit;
        } else {
            $unit = '';
        }

        // Construct answers for the numerical question type
        foreach ($answers as $aid => $answer) {
            $answernumerical = quiz_qtype_calculated_calculate_answer(
                    $answer->answer, $individualdata,
                    $answer->tolerance, $answer->tolerancetype,
                    $answer->correctanswerlength, $unit);
            $answers[$aid]->answer = $answernumerical->answer;
            $answers[$aid]->min = $answernumerical->min;
            $answers[$aid]->max = $answernumerical->max;
        }

        // Forward the grading to the virtual qtype
        $virtualnameprefix = $this->create_virtual_nameprefix(
                $nameprefix, $question->response[$nameprefix]);
        unset($question->response[$nameprefix]);
        $virtualqtype = $this->get_virtual_qtype();
        $virtualqtype->set_answers($answers);
        return $virtualqtype->grade_response($question,
                                             $virtualnameprefix);
    }
}
//// END OF CLASS ////

//////////////////////////////////////////////////////////////////////////
//// INITIATION - Without this line the question type is not in use... ///
//////////////////////////////////////////////////////////////////////////
$QUIZ_QTYPES[CALCULATED]= new quiz_calculated_qtype();

function quiz_qtype_calculated_calculate_answer($formula, $individualdata,
        $tolerance, $tolerancetype, $answerlength, $unit='') {
/// The return value has these properties:
/// ->answer    the correct answer
/// ->min       the lower bound for an acceptable response
/// ->max       the upper bound for an accetpable response

    /// Exchange formula variables with the correct values...
    foreach ($individualdata as $name => $value) {
        $formula = str_replace('{'.$name.'}', "($value)", $formula);
    }
    if (ereg('\\{([^}]*)\\}', $formula, $regs)) {
        // This is the normal case for a recently added question.
        // Return a notification about it
        $calculated->answer = $calculated->min = $calculated->max = '';
        return $calculated;

    } else if ($error = quiz_qtype_calculated_find_formula_errors($formula)) {
        $calculated->answer = $error;
        $calculated->min = $calculated->max = '';
        return $calculated;
    }

    /// Calculate the correct answer
    eval('$answer = '.$formula.';');

    /// Calculate min and max
    switch ($tolerancetype) {
        case '1': case 'relative':
            /// Recalculate the tolerance and fall through
            /// to the nominal case:
            $tolerance = $answer * $tolerance;

            // Falls through to the nominal case -
        case '2': case 'nominal':
            $tolerance = abs($tolerance); // important
            $max = $answer + $tolerance;
            $min = $answer - $tolerance;
            break;

        case '3': case 'geometric':
            $quotient = 1 + abs($tolerance);
            if ($answer >= 0) {
                $max = $answer * $quotient;
                $min = $answer / $quotient;
            } else {
                $min = $answer * $quotient;
                $max = $answer / $quotient;
            }
            break;

        default:
            error("Unknown tolerance type $tolerancetype");
    }
    $calculated->min    = $min;
    $calculated->max    = $max;

    /// Adjust the number of significant digits for the correct answer
    if ($answer) { // Applies only if the result is non-zero

        // Convert to positive answer...
        if ($answer < 0) {
            $answer = -$answer;
            $sign = '-';
        } else {
            $sign = '';
        }

        // Determine the format 0.[1-9][0-9]* for the answer...
        $p10 = 0;
        while ($answer < 1) {
            --$p10;
            $answer *= 10;
        }
        while ($answer >= 1) {
            ++$p10;
            $answer /= 10;
        }
        // ... and have the answer rounded of to the correct length
        $answer = round($answer, $answerlength);

        // Have the answer written on a suitable format,
        // Either scientific or plain numeric
        if (-2 > $p10 || 4 < $p10) {
            // Use scientific format:
            $eX = 'e'.--$p10;
            $answer *= 10;
            if (1 == $answerlength) {
                $calculated->answer = $sign.$answer.$eX.$unit;
            } else {
                // Attach additional zeros at the end of $answer,
                $answer .= (1==strlen($answer) ? '.' : '')
                        . '00000000000000000000000000000000000000000x';
                $calculated->answer = $sign
                        .substr($answer, 0, $answerlength +1).$eX.$unit;
            }
        } else {
            // Stick to plain numeric format
            $answer *= "1e$p10";
            if (0.1 <= $answer / "1e$answerlength") {
                $calculated->answer = $sign.$answer.$unit;
            } else {
                // Could be an idea to add some zeros here
                $answer .= (ereg('^[0-9]*$', $answer) ? '.' : '')
                        . '00000000000000000000000000000000000000000x';
                $oklen = $answerlength + ($p10 < 1 ? 2-$p10 : 1);
                $calculated->answer = $sign.substr($answer, 0, $oklen).$unit;
            }
        }
    } else {
        $calculated->answer = 0.0;
    }

    /// Return the result
    return $calculated;
}


function quiz_qtype_calculated_find_formula_errors($formula) {
/// Validates the formula submitted from the question edit page.
/// Returns false if everything is alright.
/// Otherwise it constructs an error message

    // Strip away dataset names
    while (ereg('\\{[[:alpha:]][^>} <{"\']*\\}', $formula, $regs)) {
        $formula = str_replace($regs[0], '1', $formula);
    }

    // Strip away empty space and lowercase it
    $formula = strtolower(str_replace(' ', '', $formula));

    $safeoperatorchar = '-+/*%>:^~<?=&|!';
    $operatorornumber = "[$safeoperatorchar.0-9eE]";


    while (ereg("(^|[$safeoperatorchar,(])([a-z0-9_]*)\\(($operatorornumber+(,$operatorornumber+((,$operatorornumber+)+)?)?)?\\)",
            $formula, $regs)) {

        switch ($regs[2]) {
            // Simple parenthesis
            case '':
                if ($regs[4] || empty($regs[3])) {
                    return get_string('illegalformulasyntax', 'quiz', $regs[0]);
                }
                break;

            // Zero argument functions
            case 'pi':
                if ($regs[3]) {
                    return get_string('functiontakesnoargs', 'quiz', $regs[2]);
                }
                break;

            // Single argument functions (the most common case)
            case 'abs': case 'acos': case 'acosh': case 'asin': case 'asinh':
            case 'atan': case 'atanh': case 'bindec': case 'ceil': case 'cos':
            case 'cosh': case 'decbin': case 'decoct': case 'deg2rad':
            case 'exp': case 'expm1': case 'floor': case 'is_finite':
            case 'is_infinite': case 'is_nan': case 'log10': case 'log1p':
            case 'octdec': case 'rad2deg': case 'sin': case 'sinh': case 'sqrt':
            case 'tan': case 'tanh':
                if ($regs[4] || empty($regs[3])) {
                    return get_string('functiontakesonearg','quiz',$regs[2]);
                }
                break;

            // Functions that take one or two arguments
            case 'log': case 'round':
                if ($regs[5] || empty($regs[3])) {
                    return get_string('functiontakesoneortwoargs','quiz',$regs[2]);
                }
                break;

            // Functions that must have two arguments
            case 'atan2': case 'fmod': case 'pow':
                if ($regs[5] || empty($regs[4])) {
                    return get_string('functiontakestwoargs', 'quiz', $regs[2]);
                }
                break;

            // Functions that take two or more arguments
            case 'min': case 'max':
                if (empty($regs[4])) {
                    return get_string('functiontakesatleasttwo','quiz',$regs[2]);
                }
                break;

            default:
                return get_string('unsupportedformulafunction','quiz',$regs[2]);
        }

        // Exchange the function call with '1' and then chack for
        // another function call...
        if ($regs[1]) {
            // The function call is proceeded by an operator
            $formula = str_replace($regs[0], $regs[1] . '1', $formula);
        } else {
            // The function call starts the formula
            $formula = ereg_replace("^$regs[2]\\([^)]*\\)", '1', $formula);
        }
    }

    if (ereg("[^$safeoperatorchar.0-9eE]+", $formula, $regs)) {
        return get_string('illegalformulasyntax', 'quiz', $regs[0]);
    } else {
        // Formula just might be valid
        return false;
    }
}

?>||||||||    function grade_response($question, $nameprefix) {
        /// Determines the answers and then lets the
        /// NUMERICAL question type take care of the
        /// grading...

        list($datasetnumber, $individualdata) =
        $this->parse_datasetinput($question->response[$nameprefix]);

        // find the raw answer material
        global $CFG;
        if (!($answers = $this->get_answers($question))) {
            notify("Error no answers found for question $question->id");
        }

        /// Find a default unit:
        if ($unit = get_record('quiz_numerical_units',
                'question', $question->id, 'multiplier', 1.0)) {
            $unit = $unit->unit;
        } else {
            $unit = '';
        }

        // Construct answers for the numerical question type
        foreach ($answers as $aid => $answer) {
            $answernumerical = quiz_qtype_calculated_calculate_answer(
                    $answer->answer, $individualdata,
                    $answer->tolerance, $answer->tolerancetype,
                    $answer->correctanswerlength,
                    $answer->correctanswerformat, $unit);
            $answers[$aid]->answer = $answernumerical->answer;
            $answers[$aid]->min = $answernumerical->min;
            $answers[$aid]->max = $answernumerical->max;
        }

        // Forward the grading to the virtual qtype
        $virtualnameprefix = $this->create_virtual_nameprefix(
                $nameprefix, $question->response[$nameprefix]);
        unset($question->response[$nameprefix]);
        $virtualqtype = $this->get_virtual_qtype();
        $virtualqtype->set_answers($answers);
        return $virtualqtype->grade_response($question,
                                             $virtualnameprefix);
    }
}
//// END OF CLASS ////

//////////////////////////////////////////////////////////////////////////
//// INITIATION - Without this line the question type is not in use... ///
//////////////////////////////////////////////////////////////////////////
$QUIZ_QTYPES[CALCULATED]= new quiz_calculated_qtype();

function quiz_qtype_calculated_calculate_answer($formula, $individualdata,
        $tolerance, $tolerancetype, $answerlength, $answerformat='1', $unit='') {
/// The return value has these properties:
/// ->answer    the correct answer
/// ->min       the lower bound for an acceptable response
/// ->max       the upper bound for an accetpable response

    /// Exchange formula variables with the correct values...
    foreach ($individualdata as $name => $value) {
        $formula = str_replace('{'.$name.'}', "($value)", $formula);
    }
    if (ereg('\\{([^}]*)\\}', $formula, $regs)) {
        // This is the normal case for a recently added question.
        // Return a notification about it
        $calculated->answer = $calculated->min = $calculated->max = '';
        return $calculated;

    } else if ($error = quiz_qtype_calculated_find_formula_errors($formula)) {
        $calculated->answer = $error;
        $calculated->min = $calculated->max = '';
        return $calculated;
    }

    /// Calculate the correct answer
    eval('$answer = '.$formula.';');

    /// Calculate min and max
    switch ($tolerancetype) {
        case '1': case 'relative':
            /// Recalculate the tolerance and fall through
            /// to the nominal case:
            $tolerance = $answer * $tolerance;

            // Falls through to the nominal case -
        case '2': case 'nominal':
            $tolerance = abs($tolerance); // important
            $max = $answer + $tolerance;
            $min = $answer - $tolerance;
            break;

        case '3': case 'geometric':
            $quotient = 1 + abs($tolerance);
            if ($answer >= 0) {
                $max = $answer * $quotient;
                $min = $answer / $quotient;
            } else {
                $min = $answer * $quotient;
                $max = $answer / $quotient;
            }
            break;

        default:
            error("Unknown tolerance type $tolerancetype");
    }
    $calculated->min    = $min;
    $calculated->max    = $max;

    if ('1' == $answerformat) { /* Answer is to have $answerlength decimals */
        /*** Adjust to the correct number of decimals ***/

        $calculated->answer = round($answer, $answerlength);

        if ($answerlength) {
            /* Try to include missing zeros at the end */

            if (ereg('^(.*\\.)(.*)$', $calculated->answer, $regs)) {
                $calculated->answer = $regs[1] . substr(
                        $regs[2] . '00000000000000000000000000000000000000000x',
                        0, $answerlength)
                        . $unit;
            } else {
                $calculated->answer .=
                        substr('.00000000000000000000000000000000000000000x',
                        0, $answerlength + 1) . $unit;
            }
        } else {
            /* Attach unit */
            $calculated->answer .= $unit;
        }

    } else if ($answer) { // Significant figures does only apply if the result is non-zero

        // Convert to positive answer...
        if ($answer < 0) {
            $answer = -$answer;
            $sign = '-';
        } else {
            $sign = '';
        }

        // Determine the format 0.[1-9][0-9]* for the answer...
        $p10 = 0;
        while ($answer < 1) {
            --$p10;
            $answer *= 10;
        }
        while ($answer >= 1) {
            ++$p10;
            $answer /= 10;
        }
        // ... and have the answer rounded of to the correct length
        $answer = round($answer, $answerlength);

        // Have the answer written on a suitable format,
        // Either scientific or plain numeric
        if (-2 > $p10 || 4 < $p10) {
            // Use scientific format:
            $eX = 'e'.--$p10;
            $answer *= 10;
            if (1 == $answerlength) {
                $calculated->answer = $sign.$answer.$eX.$unit;
            } else {
                // Attach additional zeros at the end of $answer,
                $answer .= (1==strlen($answer) ? '.' : '')
                        . '00000000000000000000000000000000000000000x';
                $calculated->answer = $sign
                        .substr($answer, 0, $answerlength +1).$eX.$unit;
            }
        } else {
            // Stick to plain numeric format
            $answer *= "1e$p10";
            if (0.1 <= $answer / "1e$answerlength") {
                $calculated->answer = $sign.$answer.$unit;
            } else {
                // Could be an idea to add some zeros here
                $answer .= (ereg('^[0-9]*$', $answer) ? '.' : '')
                        . '00000000000000000000000000000000000000000x';
                $oklen = $answerlength + ($p10 < 1 ? 2-$p10 : 1);
                $calculated->answer = $sign.substr($answer, 0, $oklen).$unit;
            }
        }

    } else {
        $calculated->answer = 0.0;
    }

    /// Return the result
    return $calculated;
}


function quiz_qtype_calculated_find_formula_errors($formula) {
/// Validates the formula submitted from the question edit page.
/// Returns false if everything is alright.
/// Otherwise it constructs an error message

    // Strip away dataset names
    while (ereg('\\{[[:alpha:]][^>} <{"\']*\\}', $formula, $regs)) {
        $formula = str_replace($regs[0], '1', $formula);
    }

    // Strip away empty space and lowercase it
    $formula = strtolower(str_replace(' ', '', $formula));

    $safeoperatorchar = '-+/*%>:^~<?=&|!';
    $operatorornumber = "[$safeoperatorchar.0-9eE]";


    while (ereg("(^|[$safeoperatorchar,(])([a-z0-9_]*)\\(($operatorornumber+(,$operatorornumber+((,$operatorornumber+)+)?)?)?\\)",
            $formula, $regs)) {

        switch ($regs[2]) {
            // Simple parenthesis
            case '':
                if ($regs[4] || empty($regs[3])) {
                    return get_string('illegalformulasyntax', 'quiz', $regs[0]);
                }
                break;

            // Zero argument functions
            case 'pi':
                if ($regs[3]) {
                    return get_string('functiontakesnoargs', 'quiz', $regs[2]);
                }
                break;

            // Single argument functions (the most common case)
            case 'abs': case 'acos': case 'acosh': case 'asin': case 'asinh':
            case 'atan': case 'atanh': case 'bindec': case 'ceil': case 'cos':
            case 'cosh': case 'decbin': case 'decoct': case 'deg2rad':
            case 'exp': case 'expm1': case 'floor': case 'is_finite':
            case 'is_infinite': case 'is_nan': case 'log10': case 'log1p':
            case 'octdec': case 'rad2deg': case 'sin': case 'sinh': case 'sqrt':
            case 'tan': case 'tanh':
                if ($regs[4] || empty($regs[3])) {
                    return get_string('functiontakesonearg','quiz',$regs[2]);
                }
                break;

            // Functions that take one or two arguments
            case 'log': case 'round':
                if ($regs[5] || empty($regs[3])) {
                    return get_string('functiontakesoneortwoargs','quiz',$regs[2]);
                }
                break;

            // Functions that must have two arguments
            case 'atan2': case 'fmod': case 'pow':
                if ($regs[5] || empty($regs[4])) {
                    return get_string('functiontakestwoargs', 'quiz', $regs[2]);
                }
                break;

            // Functions that take two or more arguments
            case 'min': case 'max':
                if (empty($regs[4])) {
                    return get_string('functiontakesatleasttwo','quiz',$regs[2]);
                }
                break;

            default:
                return get_string('unsupportedformulafunction','quiz',$regs[2]);
        }

        // Exchange the function call with '1' and then chack for
        // another function call...
        if ($regs[1]) {
            // The function call is proceeded by an operator
            $formula = str_replace($regs[0], $regs[1] . '1', $formula);
        } else {
            // The function call starts the formula
            $formula = ereg_replace("^$regs[2]\\([^)]*\\)", '1', $formula);
        }
    }

    if (ereg("[^$safeoperatorchar.0-9eE]+", $formula, $regs)) {
        return get_string('illegalformulasyntax', 'quiz', $regs[0]);
    } else {
        // Formula just might be valid
        return false;
    }
}

?>||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL)))
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))))
    (AST_GLOBAL
        (AST_VAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR)))))
            (
                (AST_CALL
                    (
                        (AST_ENCAPS_LIST
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (SCALAR)
                        (SCALAR)
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR)
                        (SCALAR))))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_PROP
                        (AST_VAR)))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR)))))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR)
                        (AST_PROP
                            (AST_VAR))
                        (AST_PROP
                            (AST_VAR))
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_PROP
                    (AST_DIM
                        (AST_VAR)
                        (AST_VAR)))
                (AST_PROP
                    (AST_VAR)))
            (AST_ASSIGN
                (AST_PROP
                    (AST_DIM
                        (AST_VAR)
                        (AST_VAR)))
                (AST_PROP
                    (AST_VAR)))
            (AST_ASSIGN
                (AST_PROP
                    (AST_DIM
                        (AST_VAR)
                        (AST_VAR)))
                (AST_PROP
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR)
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))))
    (AST_UNSET
        (AST_DIM
            (AST_PROP
                (AST_VAR))
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)))
    (AST_RETURN
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR)
                (AST_VAR)))))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL)))
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))))
    (AST_GLOBAL
        (AST_VAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR)))))
            (
                (AST_CALL
                    (
                        (AST_ENCAPS_LIST
                            (SCALAR)
                            (AST_PROP
                                (AST_VAR))))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (SCALAR)
                        (SCALAR)
                        (AST_PROP
                            (AST_VAR))
                        (SCALAR)
                        (SCALAR))))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_PROP
                        (AST_VAR)))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (SCALAR)))))
    (AST_FOREACH
        (AST_VAR)
        (AST_VAR)
        (AST_VAR)
        (
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR)
                        (AST_PROP
                            (AST_VAR))
                        (AST_PROP
                            (AST_VAR))
                        (AST_PROP
                            (AST_VAR))
                        (AST_PROP
                            (AST_VAR))
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_PROP
                    (AST_DIM
                        (AST_VAR)
                        (AST_VAR)))
                (AST_PROP
                    (AST_VAR)))
            (AST_ASSIGN
                (AST_PROP
                    (AST_DIM
                        (AST_VAR)
                        (AST_VAR)))
                (AST_PROP
                    (AST_VAR)))
            (AST_ASSIGN
                (AST_PROP
                    (AST_DIM
                        (AST_VAR)
                        (AST_VAR)))
                (AST_PROP
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR)
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))))
    (AST_UNSET
        (AST_DIM
            (AST_PROP
                (AST_VAR))
            (AST_VAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)))
    (AST_RETURN
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR)
                (AST_VAR)))))