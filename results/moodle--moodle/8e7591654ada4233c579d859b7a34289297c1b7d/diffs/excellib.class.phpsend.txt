    function send($filename) {
        $this->pear_excel_workbook->send($filename);
    }
}

/**
 * Define and operate over one Worksheet.
 *
 * A big part of this class acts as a wrapper over the PEAR
 * Spreadsheet_Excel_Writer_Workbook and OLE libraries
 * maintaining Moodle functions isolated from underlying code.
 *
 * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @package moodlecore
 */
class MoodleExcelWorksheet {
    /** @var object */
    var $pear_excel_worksheet;
    /** @var bool Only if don't want to use latin (win1252) stronger output */
    var $latin_output;

    /**
     * Constructs one Moodle Worksheet.
     *
     * @param string $filename The name of the file
     * @param object $workbook The internal PEAR Workbook onject we are creating
     * @param bool $latin_output Only if don't want to use latin (win1252) stronger output
     */
    function MoodleExcelWorksheet($name, &$workbook, $latin_output=false) {

        // Replace any characters in the name that Excel cannot cope with.
        $name = strtr($name, '[]*/\?:', '       ');

        if (strlen($name) > 31) {
            // Excel does not seem able to cope with sheet names > 31 chars.
            // With $latin_output = false, it does not cope at all.
            // With $latin_output = true it is supposed to work, but in our experience,
            // it doesn't. Therefore, truncate in all circumstances.
            $name = textlib::substr($name, 0, 31);
        }

    /// Internally, add one sheet to the workbook
        $this->pear_excel_worksheet =& $workbook->addWorksheet($name);
        $this->latin_output = $latin_output;
    /// Set encoding to UTF-16LE
        if (!$this->latin_output) { /// Only if don't want to use latin (win1252) stronger output
            $this->pear_excel_worksheet->setInputEncoding('UTF-16LE');
        }
    }

    /**
     * Write one string somewhere in the worksheet
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $str    The string to write
     * @param mixed   $format The XF format for the cell
     */
    function write_string($row, $col, $str, $format=null) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Convert the text from its original encoding to UTF-16LE
        if (!$this->latin_output) { /// Only if don't want to use latin (win1252) stronger output
            $str = textlib::convert($str, 'utf-8', 'utf-16le');
        } else { /// else, convert to latin (win1252)
            $str = textlib::convert($str, 'utf-8', 'windows-1252');
        }
    /// Add the string safely to the PEAR Worksheet
        $this->pear_excel_worksheet->writeString($row, $col, $str, $format);
    }

    /**
     * Write one number somewhere in the worksheet
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param float   $num    The number to write
     * @param mixed   $format The XF format for the cell
     */
    function write_number($row, $col, $num, $format=null) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Add  the number safely to the PEAR Worksheet
        $this->pear_excel_worksheet->writeNumber($row, $col, $num, $format);
    }

    /**
     * Write one url somewhere in the worksheet
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $url    The url to write
     * @param mixed   $format The XF format for the cell
     */
    function write_url($row, $col, $url, $format=null) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Add  the url safely to the PEAR Worksheet
        $this->pear_excel_worksheet->writeUrl($row, $col, $url, $format);
    }

    /**
     * Write one date somewhere in the worksheet
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $date   The date to write in UNIX timestamp format
     * @param mixed   $format The XF format for the cell
     */
    function write_date($row, $col, $date, $format=null) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Convert the date to Excel format
        $timezone = get_user_timezone_offset();
        if ($timezone == 99) {
            // system timezone offset in seconds
            $offset = (int)date('Z');
        } else {
            $offset = (int)($timezone * HOURSECS * 2);
        }
        $value = ((usertime($date) + $offset) / 86400) + 25569;
    /// Add  the date safely to the PEAR Worksheet
        $this->pear_excel_worksheet->writeNumber($row, $col, $value, $format);
    }

    /**
     * Write one formula somewhere in the worksheet
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $formula The formula to write
     * @param mixed   $format The XF format for the cell
     */
    function write_formula($row, $col, $formula, $format=null) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Add  the formula safely to the PEAR Worksheet
        $this->pear_excel_worksheet->writeFormula($row, $col, $formula, $format);
    }

    /**
     * Write one blanck somewhere in the worksheet
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param mixed   $format The XF format for the cell
     */
    function write_blank($row, $col, $format=null) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Add  the blank safely to the PEAR Worksheet
        $this->pear_excel_worksheet->writeBlank($row, $col, $format);
    }

    /**
     * Write anything somewhere in the worksheet
     * Type will be automatically detected
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param mixed   $token  What we are writing
     * @param mixed   $format The XF format for the cell
     * @return void
     */
    function write($row, $col, $token, $format=null) {

    /// Analyse what are we trying to send
        if (preg_match("/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/", $token)) {
        /// Match number
            return $this->write_number($row, $col, $token, $format);
        } elseif (preg_match("/^[fh]tt?p:\/\//", $token)) {
        /// Match http or ftp URL
            return $this->write_url($row, $col, $token, '', $format);
        } elseif (preg_match("/^mailto:/", $token)) {
        /// Match mailto:
            return $this->write_url($row, $col, $token, '', $format);
        } elseif (preg_match("/^(?:in|ex)ternal:/", $token)) {
        /// Match internal or external sheet link
            return $this->write_url($row, $col, $token, '', $format);
        } elseif (preg_match("/^=/", $token)) {
        /// Match formula
            return $this->write_formula($row, $col, $token, $format);
        } elseif (preg_match("/^@/", $token)) {
        /// Match formula
            return $this->write_formula($row, $col, $token, $format);
        } elseif ($token == '') {
        /// Match blank
            return $this->write_blank($row, $col, $format);
        } else {
        /// Default: match string
            return $this->write_string($row, $col, $token, $format);
        }
    }

    /**
     * Sets the height (and other settings) of one row
     *
     * @param integer $row    The row to set
     * @param integer $height Height we are giving to the row (null to set just format withouth setting the height)
     * @param mixed   $format The optional XF format we are giving to the row
     * @param bool    $hidden The optional hidden attribute
     * @param integer $level  The optional outline level (0-7)
     */
    function set_row ($row, $height, $format = null, $hidden = false, $level = 0) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Set the row safely to the PEAR Worksheet
        $this->pear_excel_worksheet->setRow($row, $height, $format, $hidden, $level);
    }

    /**
     * Sets the width (and other settings) of one column
     *
     * @param integer $firstcol first column on the range
     * @param integer $lastcol  last column on the range
     * @param integer $width    width to set
     * @param mixed   $format   The optional XF format to apply to the columns
     * @param integer $hidden   The optional hidden atribute
     * @param integer $level    The optional outline level (0-7)
     */
    function set_column ($firstcol, $lastcol, $width, $format = null, $hidden = false, $level = 0) {
    /// Calculate the internal PEAR format
        $format = $this->MoodleExcelFormat2PearExcelFormat($format);
    /// Set the column safely to the PEAR Worksheet
        $this->pear_excel_worksheet->setColumn($firstcol, $lastcol, $width, $format, $hidden, $level);
    }

    /**
    * Set the option to hide gridlines on the printed page.
    *
    * @access public
    */
    function hide_gridlines() {
        $this->pear_excel_worksheet->hideGridLines();
    }

    /**
    * Set the option to hide gridlines on the worksheet (as seen on the screen).
    *
    * @access public
    */
    function hide_screen_gridlines() {
        $this->pear_excel_worksheet->hideScreenGridlines();
    }

    /**
    * Insert a 24bit bitmap image in a worksheet.
    *
    * @access public
    * @param integer $row     The row we are going to insert the bitmap into
    * @param integer $col     The column we are going to insert the bitmap into
    * @param string  $bitmap  The bitmap filename
    * @param integer $x       The horizontal position (offset) of the image inside the cell.
    * @param integer $y       The vertical position (offset) of the image inside the cell.
    * @param integer $scale_x The horizontal scale
    * @param integer $scale_y The vertical scale
    */
    function insert_bitmap($row, $col, $bitmap, $x = 0, $y = 0, $scale_x = 1, $scale_y = 1) {
    /// Add the bitmap safely to the PEAR Worksheet
        $this->pear_excel_worksheet->insertBitmap($row, $col, $bitmap, $x, $y, $scale_x, $scale_y);
    }

    /**
    * Merges the area given by its arguments.
    * This is an Excel97/2000 method. It is required to perform more complicated
    * merging than the normal setAlign('merge').
    *
    * @access public
    * @param integer $first_row First row of the area to merge
    * @param integer $first_col First column of the area to merge
    * @param integer $last_row  Last row of the area to merge
    * @param integer $last_col  Last column of the area to merge
    */
    function merge_cells($first_row, $first_col, $last_row, $last_col) {
        /// Merge cells safely to the PEAR Worksheet
        $this->pear_excel_worksheet->mergeCells($first_row, $first_col, $last_row, $last_col);
    }

    /**
     * Returns the PEAR Excel Format for one Moodle Excel Format
     *
     * @param mixed $format MoodleExcelFormat object
     * @return mixed PEAR Excel Format object
     */
    function MoodleExcelFormat2PearExcelFormat($format) {
        if ($format) {
            return $format->pear_excel_format;
        } else {
            return null;
        }
    }
}


/**
 * Define and operate over one Format.
 *
 * A big part of this class acts as a wrapper over the PEAR
 * Spreadsheet_Excel_Writer_Workbook and OLE libraries
 * maintaining Moodle functions isolated from underlying code.
 *
 * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @package moodlecore
 */
class MoodleExcelFormat {
    /** @var object */
    var $pear_excel_format;

    /**
     * Constructs one Moodle Format.
     *
     * @param object $workbook The internal PEAR Workbook onject we are creating
     * @param array $properties
     */
    function MoodleExcelFormat(&$workbook, $properties = array()) {
    /// Internally, add one sheet to the workbook
        $this->pear_excel_format =& $workbook->addFormat();
    /// If we have something in the array of properties, compute them
        foreach($properties as $property => $value) {
            if(method_exists($this,"set_$property")) {
                $aux = 'set_'.$property;
                $this->$aux($value);
            }
        }
    }

    /**
     * Set the size of the text in the format (in pixels).
     * By default all texts in generated sheets are 10px.
     *
     * @param integer $size Size of the text (in pixels)
     */
    function set_size($size) {
    /// Set the size safely to the PEAR Format
        $this->pear_excel_format->setSize($size);
    }

    /**
     * Set weight of the format
     *
     * @param integer $weight Weight for the text, 0 maps to 400 (normal text),
     *                        1 maps to 700 (bold text). Valid range is: 100-1000.
     *                        It's Optional, default is 1 (bold).
     */
    function set_bold($weight = 1) {
    /// Set the bold safely to the PEAR Format
        $this->pear_excel_format->setBold($weight);
    }

    /**
     * Set underline of the format
     *
     * @param integer $underline The value for underline. Possible values are:
     *                           1 => underline, 2 => double underline
     */
    function set_underline($underline) {
    /// Set the underline safely to the PEAR Format
        $this->pear_excel_format->setUnderline($underline);
    }

    /**
     * Set italic of the format
     */
    function set_italic() {
    /// Set the italic safely to the PEAR Format
        $this->pear_excel_format->setItalic();
    }

    /**
     * Set strikeout of the format
     */
    function set_strikeout() {
    /// Set the strikeout safely to the PEAR Format
        $this->pear_excel_format->setStrikeOut();
    }

    /**
     * Set outlining of the format
     */
    function set_outline() {
    /// Set the outlining safely to the PEAR Format
        $this->pear_excel_format->setOutLine();
    }

    /**
     * Set shadow of the format
     */
    function set_shadow() {
    /// Set the shadow safely to the PEAR Format
        $this->pear_excel_format->setShadow();
    }

    /**
     * Set the script of the text
     *
     * @param integer $script The value for script type. Possible values are:
     *                        1 => superscript, 2 => subscript
     */
    function set_script($script) {
    /// Set the script safely to the PEAR Format
        $this->pear_excel_format->setScript($script);
    }

    /**
     * Set color of the format. Used to specify the color of the text to be formatted.
     *
     * @param mixed $color either a string (like 'blue'), or an integer (range is [8...63])
     */
    function set_color($color) {
    /// Set the background color safely to the PEAR Format
        $this->pear_excel_format->setColor($color);
    }

    /**
     * Set foreground color (top layer) of the format. About formatting colors note that cells backgrounds
     * have TWO layers, in order to support patterns and paint them with two diferent colors.
     * This method set the color of the TOP layer of the background format. So, when filling
     * cells with plain colors (no patterns) this is the method to use.
     *
     * @param mixed $color either a string (like 'blue'), or an integer (range is [8...63])
     */
    function set_fg_color($color) {
    /// Set the foreground color safely to the PEAR Format
        $this->pear_excel_format->setFgColor($color);
    }

    /**
     * Set background color (bottom layer) of the format. About formatting colors note that cells backgrounds
     * have TWO layers, in order to support patterns and paint them with two diferent colors.
     * This method set the color of the BOTTOM layer of the background format. So, the color
     * specified here only will be visible if using patterns. Use set_fg_color() to fill
     * cells with plain colors (no patterns).
     *
     * @param mixed $color either a string (like 'blue'), or an integer (range is [8...63])
     */
    function set_bg_color($color) {
    /// Set the background color safely to the PEAR Format
        $this->pear_excel_format->setBgColor($color);
    }

    /**
     * Set the fill pattern of the format
     * @param integer Optional. Defaults to 1. Meaningful values are: 0-18
     *                0 meaning no background.
     */
    function set_pattern($pattern=1) {
    /// Set the fill pattern safely to the PEAR Format
        $this->pear_excel_format->setPattern($pattern);
    }

    /**
     * Set text wrap of the format
     */
    function set_text_wrap() {
    /// Set the shadow safely to the PEAR Format
        $this->pear_excel_format->setTextWrap();
    }

    /**
     * Set the cell alignment of the format
     *
     * @param string $location alignment for the cell ('left', 'right', etc...)
     */
    function set_align($location) {
    /// Set the alignment of the cell safely to the PEAR Format
        $this->pear_excel_format->setAlign($location);
    }

    /**
     * Set the cell horizontal alignment of the format
     *
     * @param string $location alignment for the cell ('left', 'right', etc...)
     */
    function set_h_align($location) {
    /// Set the alignment of the cell safely to the PEAR Format
        $this->pear_excel_format->setHAlign($location);
    }

    /**
     * Set the cell vertical alignment of the format
     *
     * @param string $location alignment for the cell ('top', 'vleft', etc...)
     */
    function set_v_align($location) {
    /// Set the alignment of the cell safely to the PEAR Format
        $this->pear_excel_format->setVAlign($location);
    }

    /**
     * Set the top border of the format
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    function set_top($style) {
    /// Set the top border of the cell safely to the PEAR Format
        $this->pear_excel_format->setTop($style);
    }

    /**
     * Set the bottom border of the format
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    function set_bottom($style) {
    /// Set the bottom border of the cell safely to the PEAR Format
        $this->pear_excel_format->setBottom($style);
    }

    /**
     * Set the left border of the format
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    function set_left($style) {
    /// Set the left border of the cell safely to the PEAR Format
        $this->pear_excel_format->setLeft($style);
    }

    /**
     * Set the right border of the format
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    function set_right($style) {
    /// Set the right border of the cell safely to the PEAR Format
        $this->pear_excel_format->setRight($style);
    }

    /**
     * Set cells borders to the same style
     *
     * @param integer $style style to apply for all cell borders. 1 => thin, 2 => thick.
     */
    function set_border($style) {
    /// Set all the borders of the cell safely to the PEAR Format
        $this->pear_excel_format->setBorder($style);
    }

    /**
     * Set the numerical format of the format
     * It can be date, time, currency, etc...
     *
     * @param integer $num_format The numeric format
     */
    function set_num_format($num_format) {
    /// Set the numerical format safely to the PEAR Format
        $this->pear_excel_format->setNumFormat($num_format);
    }

}||||||||    public function send($filename) {
        $this->filename = $filename;
    }
}

/**
 * Define and operate over one Worksheet.
 *
 * This class acts as a wrapper around another library
 * maintaining Moodle functions isolated from underlying code.
 *
 * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @package   core
 */
class MoodleExcelWorksheet {
    /** @var PHPExcel_Worksheet */
    protected $worksheet;

    /**
     * Constructs one Moodle Worksheet.
     *
     * @param string $name The name of the file
     * @param PHPExcel $workbook The internal Workbook object we are creating.
     */
    public function __construct($name, PHPExcel $workbook) {
        // Replace any characters in the name that Excel cannot cope with.
        $name = strtr($name, '[]*/\?:', '       ');
        // Shorten the title if necessary.
        $name = textlib::substr($name, 0, 31);

        if ($name === '') {
            // Name is required!
            $name = 'Sheet'.($workbook->getSheetCount()+1);
        }

        $this->worksheet = new PHPExcel_Worksheet($workbook, $name);
        $this->worksheet->setPrintGridlines(false);

        $workbook->addSheet($this->worksheet);
    }

    /**
     * Write one string somewhere in the worksheet.
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $str    The string to write
     * @param mixed   $format The XF format for the cell
     */
    public function write_string($row, $col, $str, $format = null) {
        $this->worksheet->getStyleByColumnAndRow($col, $row+1)->getNumberFormat()->setFormatCode(PHPExcel_Style_NumberFormat::FORMAT_TEXT);
        $this->worksheet->setCellValueExplicitByColumnAndRow($col, $row+1, $str, PHPExcel_Cell_DataType::TYPE_STRING);
        $this->apply_format($row, $col, $format);
    }

    /**
     * Write one number somewhere in the worksheet.
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param float   $num    The number to write
     * @param mixed   $format The XF format for the cell
     */
    public function write_number($row, $col, $num, $format = null) {
        $this->worksheet->getStyleByColumnAndRow($col, $row+1)->getNumberFormat()->setFormatCode(PHPExcel_Style_NumberFormat::FORMAT_GENERAL);
        $this->worksheet->setCellValueExplicitByColumnAndRow($col, $row+1, $num, PHPExcel_Cell_DataType::TYPE_NUMERIC);
        $this->apply_format($row, $col, $format);
    }

    /**
     * Write one url somewhere in the worksheet.
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $url    The url to write
     * @param mixed   $format The XF format for the cell
     */
    public function write_url($row, $col, $url, $format = null) {
        $this->worksheet->setCellValueByColumnAndRow($col, $row+1, $url);
        $this->worksheet->getCellByColumnAndRow($col, $row+1)->getHyperlink()->setUrl($url);
        $this->apply_format($row, $col, $format);
    }

    /**
     * Write one date somewhere in the worksheet.
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $date   The date to write in UNIX timestamp format
     * @param mixed   $format The XF format for the cell
     */
    public function write_date($row, $col, $date, $format = null) {
        $getdate = usergetdate($date);
        $exceldate = PHPExcel_Shared_Date::FormattedPHPToExcel(
            $getdate['year'],
            $getdate['mon'],
            $getdate['mday'],
            $getdate['hours'],
            $getdate['minutes'],
            $getdate['seconds']
        );

        $this->worksheet->setCellValueByColumnAndRow($col, $row+1, $exceldate);
        $this->worksheet->getStyleByColumnAndRow($col, $row+1)->getNumberFormat()->setFormatCode(PHPExcel_Style_NumberFormat::FORMAT_DATE_XLSX22);
        $this->apply_format($row, $col, $format);
    }

    /**
     * Write one formula somewhere in the worksheet.
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param string  $formula The formula to write
     * @param mixed   $format The XF format for the cell
     */
    public function write_formula($row, $col, $formula, $format = null) {
        $this->worksheet->setCellValueExplicitByColumnAndRow($col, $row+1, $formula, PHPExcel_Cell_DataType::TYPE_FORMULA);
        $this->apply_format($row, $col, $format);
    }

    /**
     * Write one blank somewhere in the worksheet.
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param mixed   $format The XF format for the cell
     */
    public function write_blank($row, $col, $format = null) {
        $this->worksheet->setCellValueByColumnAndRow($col, $row+1, '');
        $this->apply_format($row, $col, $format);
    }

    /**
     * Write anything somewhere in the worksheet,
     * type will be automatically detected.
     *
     * @param integer $row    Zero indexed row
     * @param integer $col    Zero indexed column
     * @param mixed   $token  What we are writing
     * @param mixed   $format The XF format for the cell
     */
    public function write($row, $col, $token, $format = null) {
        // Analyse what are we trying to send.
        if (preg_match("/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/", $token)) {
            // Match number
            return $this->write_number($row, $col, $token, $format);
        } elseif (preg_match("/^[fh]tt?p:\/\//", $token)) {
            // Match http or ftp URL
            return $this->write_url($row, $col, $token, '', $format);
        } elseif (preg_match("/^mailto:/", $token)) {
            // Match mailto:
            return $this->write_url($row, $col, $token, '', $format);
        } elseif (preg_match("/^(?:in|ex)ternal:/", $token)) {
            // Match internal or external sheet link
            return $this->write_url($row, $col, $token, '', $format);
        } elseif (preg_match("/^=/", $token)) {
            // Match formula
            return $this->write_formula($row, $col, $token, $format);
        } elseif (preg_match("/^@/", $token)) {
            // Match formula
            return $this->write_formula($row, $col, $token, $format);
        } elseif ($token == '') {
            // Match blank
            return $this->write_blank($row, $col, $format);
        } else {
            // Default: match string
            return $this->write_string($row, $col, $token, $format);
        }
    }

    /**
     * Sets the height (and other settings) of one row.
     *
     * @param integer $row    The row to set
     * @param integer $height Height we are giving to the row (null to set just format without setting the height)
     * @param mixed   $format The optional format we are giving to the row
     * @param bool    $hidden The optional hidden attribute
     * @param integer $level  The optional outline level (0-7)
     */
    public function set_row($row, $height, $format = null, $hidden = false, $level = 0) {
        if ($level < 0) {
            $level = 0;
        } else if ($level > 7) {
            $level = 7;
        }
        if (isset($height)) {
            $this->worksheet->getRowDimension($row+1)->setRowHeight($height);
        }
        $this->worksheet->getRowDimension($row+1)->setVisible(!$hidden);
        $this->worksheet->getRowDimension($row+1)->setOutlineLevel($level);
        $this->apply_row_format($row, $format);
    }

    /**
     * Sets the width (and other settings) of one column.
     *
     * @param integer $firstcol first column on the range
     * @param integer $lastcol  last column on the range
     * @param integer $width    width to set  (null to set just format without setting the width)
     * @param mixed   $format   The optional format to apply to the columns
     * @param bool    $hidden   The optional hidden attribute
     * @param integer $level    The optional outline level (0-7)
     */
    public function set_column($firstcol, $lastcol, $width, $format = null, $hidden = false, $level = 0) {
        if ($level < 0) {
            $level = 0;
        } else if ($level > 7) {
            $level = 7;
        }
        $i = $firstcol;
        while($i <= $lastcol) {
            if (isset($width)) {
                $this->worksheet->getColumnDimensionByColumn($i)->setWidth($width);
            }
            $this->worksheet->getColumnDimensionByColumn($i)->setVisible(!$hidden);
            $this->worksheet->getColumnDimensionByColumn($i)->setOutlineLevel($level);
            $this->apply_column_format($i, $format);
            $i++;
        }
    }

   /**
    * Set the option to hide grid lines on the printed page.
    */
    public function hide_gridlines() {
        // Not implemented - always off.
    }

   /**
    * Set the option to hide gridlines on the worksheet (as seen on the screen).
    */
    public function hide_screen_gridlines() {
        $this->worksheet->setShowGridlines(false);
    }

   /**
    * Insert an image in a worksheet.
    *
    * @param integer $row     The row we are going to insert the bitmap into
    * @param integer $col     The column we are going to insert the bitmap into
    * @param string  $bitmap  The bitmap filename
    * @param integer $x       The horizontal position (offset) of the image inside the cell.
    * @param integer $y       The vertical position (offset) of the image inside the cell.
    * @param integer $scale_x The horizontal scale
    * @param integer $scale_y The vertical scale
    */
    public function insert_bitmap($row, $col, $bitmap, $x = 0, $y = 0, $scale_x = 1, $scale_y = 1) {
        $objDrawing = new PHPExcel_Worksheet_Drawing();
        $objDrawing->setPath($bitmap);
        $objDrawing->setCoordinates(PHPExcel_Cell::stringFromColumnIndex($col) . ($row+1));
        $objDrawing->setOffsetX($x);
        $objDrawing->setOffsetY($y);
        $objDrawing->setWorksheet($this->worksheet);
        if ($scale_x != 1) {
            $objDrawing->setResizeProportional(false);
            $objDrawing->getWidth($objDrawing->getWidth()*$scale_x);
        }
        if ($scale_y != 1) {
            $objDrawing->setResizeProportional(false);
            $objDrawing->setHeight($objDrawing->getHeight()*$scale_y);
        }
    }

   /**
    * Merges the area given by its arguments.
    *
    * @param integer $first_row First row of the area to merge
    * @param integer $first_col First column of the area to merge
    * @param integer $last_row  Last row of the area to merge
    * @param integer $last_col  Last column of the area to merge
    */
    public function merge_cells($first_row, $first_col, $last_row, $last_col) {
        $this->worksheet->mergeCellsByColumnAndRow($first_col, $first_row+1, $last_col, $last_row+1);
    }

    protected function apply_format($row, $col, $format = null) {
        if (!$format) {
            $format = new MoodleExcelFormat();
        } else if (is_array($format)) {
            $format = new MoodleExcelFormat($format);
        }
        $this->worksheet->getStyleByColumnAndRow($col, $row+1)->applyFromArray($format->get_format_array());
    }

    protected function apply_column_format($col, $format = null) {
        if (!$format) {
            $format = new MoodleExcelFormat();
        } else if (is_array($format)) {
            $format = new MoodleExcelFormat($format);
        }
        $this->worksheet->getStyle(PHPExcel_Cell::stringFromColumnIndex($col))->applyFromArray($format->get_format_array());
    }

    protected function apply_row_format($row, $format = null) {
        if (!$format) {
            $format = new MoodleExcelFormat();
        } else if (is_array($format)) {
            $format = new MoodleExcelFormat($format);
        }
        $this->worksheet->getStyle($row+1)->applyFromArray($format->get_format_array());
    }
}


/**
 * Define and operate over one Format.
 *
 * A big part of this class acts as a wrapper over the PEAR
 * Spreadsheet_Excel_Writer_Workbook and OLE libraries
 * maintaining Moodle functions isolated from underlying code.
 *
 * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @package moodlecore
 */
class MoodleExcelFormat {
    /** @var array */
    protected $format = array('font'=>array('size'=>10, 'name'=>'Arial'));

    /**
     * Constructs one Moodle Format.
     *
     * @param array $properties
     */
    public function __construct($properties = array()) {
        // If we have something in the array of properties, compute them
        foreach($properties as $property => $value) {
            if(method_exists($this,"set_$property")) {
                $aux = 'set_'.$property;
                $this->$aux($value);
            }
        }
    }

    /**
     * Returns standardised Excel format array.
     * @private
     *
     * @return array
     */
    public function get_format_array() {
        return $this->format;
    }
    /**
     * Set the size of the text in the format (in pixels).
     * By default all texts in generated sheets are 10pt.
     *
     * @param integer $size Size of the text (in points)
     */
    public function set_size($size) {
        $this->format['font']['size'] = $size;
    }

    /**
     * Set weight of the format.
     *
     * @param integer $weight Weight for the text, 0 maps to 400 (normal text),
     *                        1 maps to 700 (bold text). Valid range is: 100-1000.
     *                        It's Optional, default is 1 (bold).
     */
    public function set_bold($weight = 1) {
        if ($weight == 1) {
            $weight = 700;
        }
        $this->format['font']['bold'] = ($weight > 400);
    }

    /**
     * Set underline of the format.
     *
     * @param integer $underline The value for underline. Possible values are:
     *                           1 => underline, 2 => double underline
     */
    public function set_underline($underline) {
        if ($underline == 1) {
            $this->format['font']['underline'] = PHPExcel_Style_Font::UNDERLINE_SINGLE;
        } else if ($underline == 2) {
            $this->format['font']['underline'] = PHPExcel_Style_Font::UNDERLINE_DOUBLE;
        } else {
            $this->format['font']['underline'] = PHPExcel_Style_Font::UNDERLINE_NONE;
        }
    }

    /**
     * Set italic of the format.
     */
    public function set_italic() {
        $this->format['font']['italic'] = true;
    }

    /**
     * Set strikeout of the format.
     */
    public function set_strikeout() {
        $this->format['font']['strike'] = true;
    }

    /**
     * Set outlining of the format.
     */
    public function set_outline() {
        // Not implemented.
    }

    /**
     * Set shadow of the format.
     */
    public function set_shadow() {
        // Not implemented.
    }

    /**
     * Set the script of the text.
     *
     * @param integer $script The value for script type. Possible values are:
     *                        1 => superscript, 2 => subscript
     */
    public function set_script($script) {
        if ($script == 1) {
            $this->format['font']['superScript'] = true;
        } else if ($script == 2) {
            $this->format['font']['subScript'] = true;
        } else {
            $this->format['font']['superScript'] = false;
            $this->format['font']['subScript'] = false;
        }
    }

    /**
     * Set color of the format. Used to specify the color of the text to be formatted.
     *
     * @param mixed $color either a string (like 'blue'), or an integer (range is [8...63])
     */
    public function set_color($color) {
        $this->format['font']['color']['rgb'] = $this->parse_color($color);
    }

    /**
     * Standardise colour name.
     *
     * @param mixed $color name of the color (i.e.: 'blue', 'red', etc..), or an integer (range is [8...63]).
     * @return string the RGB color value
     */
    protected function parse_color($color) {
        if (strpos($color, '#') === 0) {
            // No conversion should be needed.
            return substr($color, 1);
        }

        if ($color > 7 and $color < 53) {
            $numbers = array(
                8  => 'black',
                12 => 'blue',
                16 => 'brown',
                15 => 'cyan',
                23 => 'gray',
                17 => 'green',
                11 => 'lime',
                14 => 'magenta',
                18 => 'navy',
                53 => 'orange',
                33 => 'pink',
                20 => 'purple',
                10 => 'red',
                22 => 'silver',
                9  => 'white',
                13 => 'yellow',
            );
            if (isset($numbers[$color])) {
                $color = $numbers[$color];
            } else {
                $color = 'black';
            }
        }

        $colors = array(
            'aqua'    => '00FFFF',
            'black'   => '000000',
            'blue'    => '0000FF',
            'brown'   => 'A52A2A',
            'cyan'    => '00FFFF',
            'fuchsia' => 'FF00FF',
            'gray'    => '808080',
            'grey'    => '808080',
            'green'   => '00FF00',
            'lime'    => '00FF00',
            'magenta' => 'FF00FF',
            'maroon'  => '800000',
            'navy'    => '000080',
            'orange'  => 'FFA500',
            'olive'   => '808000',
            'pink'    => 'FAAFBE',
            'purple'  => '800080',
            'red'     => 'FF0000',
            'silver'  => 'C0C0C0',
            'teal'    => '008080',
            'white'   => 'FFFFFF',
            'yellow'  => 'FFFF00',
        );

        if (isset($colors[$color])) {
            return($colors[$color]);
        }

        return($colors['black']);
    }

    /**
     * Not used.
     *
     * @param mixed $color
     */
    public function set_fg_color($color) {
        // Not implemented.
    }

    /**
     * Set background color of the cell.
     *
     * @param mixed $color either a string (like 'blue'), or an integer (range is [8...63])
     */
    public function set_bg_color($color) {
        if (!isset($this->format['fill']['type'])) {
            $this->format['fill']['type'] = PHPExcel_Style_Fill::FILL_SOLID;
        }
        $this->format['fill']['color']['rgb'] = $this->parse_color($color);
    }

    /**
     * Set the cell fill pattern.
     *
     * @deprecated use set_bg_color() instead.
     * @param integer
     */
    public function set_pattern($pattern=1) {
        if ($pattern > 0) {
            if (!isset($this->format['fill']['color']['rgb'])) {
                $this->set_bg_color('black');
            }
        } else {
            unset($this->format['fill']['color']['rgb']);
            unset($this->format['fill']['type']);
        }
    }

    /**
     * Set text wrap of the format.
     */
    public function set_text_wrap() {
        $this->format['alignment']['wrap'] = true;
    }

    /**
     * Set the cell alignment of the format.
     *
     * @param string $location alignment for the cell ('left', 'right', 'justify', etc...)
     */
    public function set_align($location) {
        if (in_array($location, array('left', 'centre', 'center', 'right', 'fill', 'merge', 'justify', 'equal_space'))) {
            $this->set_h_align($location);

        } else if (in_array($location, array('top', 'vcentre', 'vcenter', 'bottom', 'vjustify', 'vequal_space'))) {
            $this->set_v_align($location);
        }
    }

    /**
     * Set the cell horizontal alignment of the format.
     *
     * @param string $location alignment for the cell ('left', 'right', 'justify', etc...)
     */
    public function set_h_align($location) {
        switch ($location) {
            case 'left':
                $this->format['alignment']['horizontal'] = PHPExcel_Style_Alignment::HORIZONTAL_LEFT;
                break;
            case 'center':
            case 'centre':
                $this->format['alignment']['horizontal'] = PHPExcel_Style_Alignment::HORIZONTAL_CENTER;
                break;
            case 'right':
                $this->format['alignment']['horizontal'] = PHPExcel_Style_Alignment::HORIZONTAL_RIGHT;
                break;
            case 'justify':
                $this->format['alignment']['horizontal'] = PHPExcel_Style_Alignment::HORIZONTAL_JUSTIFY;
                break;
            default:
                $this->format['alignment']['horizontal'] = PHPExcel_Style_Alignment::HORIZONTAL_GENERAL;
        }
    }

    /**
     * Set the cell vertical alignment of the format.
     *
     * @param string $location alignment for the cell ('top', 'bottom', 'center', 'justify')
     */
    public function set_v_align($location) {
        switch ($location) {
            case 'top':
                $this->format['alignment']['vertical'] = PHPExcel_Style_Alignment::VERTICAL_TOP;
                break;
            case 'vcentre':
            case 'vcenter':
            case 'centre':
            case 'center':
                $this->format['alignment']['vertical'] = PHPExcel_Style_Alignment::VERTICAL_CENTER;
                break;
            case 'vjustify':
            case 'justify':
                $this->format['alignment']['vertical'] = PHPExcel_Style_Alignment::VERTICAL_JUSTIFY;
                break;
            default:
                $this->format['alignment']['vertical'] = PHPExcel_Style_Alignment::VERTICAL_BOTTOM;
        }
    }

    /**
     * Set the top border of the format.
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    public function set_top($style) {
        if ($style == 1) {
            $this->format['borders']['top']['style'] = PHPExcel_Style_Border::BORDER_THIN;
        } else if ($style == 2) {
            $this->format['borders']['top']['style'] = PHPExcel_Style_Border::BORDER_THICK;
        } else {
            $this->format['borders']['top']['style'] = PHPExcel_Style_Border::BORDER_NONE;
        }
    }

    /**
     * Set the bottom border of the format.
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    public function set_bottom($style) {
        if ($style == 1) {
            $this->format['borders']['bottom']['style'] = PHPExcel_Style_Border::BORDER_THIN;
        } else if ($style == 2) {
            $this->format['borders']['bottom']['style'] = PHPExcel_Style_Border::BORDER_THICK;
        } else {
            $this->format['borders']['bottom']['style'] = PHPExcel_Style_Border::BORDER_NONE;
        }
    }

    /**
     * Set the left border of the format.
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    public function set_left($style) {
        if ($style == 1) {
            $this->format['borders']['left']['style'] = PHPExcel_Style_Border::BORDER_THIN;
        } else if ($style == 2) {
            $this->format['borders']['left']['style'] = PHPExcel_Style_Border::BORDER_THICK;
        } else {
            $this->format['borders']['left']['style'] = PHPExcel_Style_Border::BORDER_NONE;
        }
    }

    /**
     * Set the right border of the format.
     *
     * @param integer $style style for the cell. 1 => thin, 2 => thick
     */
    public function set_right($style) {
        if ($style == 1) {
            $this->format['borders']['right']['style'] = PHPExcel_Style_Border::BORDER_THIN;
        } else if ($style == 2) {
            $this->format['borders']['right']['style'] = PHPExcel_Style_Border::BORDER_THICK;
        } else {
            $this->format['borders']['right']['style'] = PHPExcel_Style_Border::BORDER_NONE;
        }
    }

    /**
     * Set cells borders to the same style.
     *
     * @param integer $style style to apply for all cell borders. 1 => thin, 2 => thick.
     */
    public function set_border($style) {
        $this->set_top($style);
        $this->set_bottom($style);
        $this->set_left($style);
        $this->set_right($style);
    }

    /**
     * Set the numerical format of the format.
     * It can be date, time, currency, etc...
     *
     * @param mixed $num_format The numeric format
     */
    public function set_num_format($num_format) {
        $numbers = array();

        $numbers[1] = '0';
        $numbers[2] = '0.00';
        $numbers[3] = '#,##0';
        $numbers[4] = '#,##0.00';
        $numbers[11] = '0.00E+00';
        $numbers[12] = '# ?/?';
        $numbers[13] = '# ??/??';
        $numbers[14] = 'mm-dd-yy';
        $numbers[15] = 'd-mmm-yy';
        $numbers[16] = 'd-mmm';
        $numbers[17] = 'mmm-yy';
        $numbers[22] = 'm/d/yy h:mm';
        $numbers[49] = '@';

        if ($num_format !== 0 and in_array($num_format, $numbers)) {
            $this->format['numberformat']['code'] = $num_format;
        }

        if (!isset($numbers[$num_format])) {
            return;
        }

        $this->format['numberformat']['code'] = $numbers[$num_format];
    }
}||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_METHOD_CALL
        (AST_PROP
            (AST_VAR))
        (
            (AST_VAR))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_VAR)))