    protected static function get_modules_info($disablecache=false) {
        global $DB;

        $cache = cache::make('core', 'plugininfo_mod');

        $modulesinfo = $cache->get('modulesinfo');

        if ($modulesinfo === false or $disablecache) {
            try {
                $modulesinfo = $DB->get_records('modules', null, 'name', 'name,id,version,visible');
            } catch (dml_exception $e) {
                // before install
                $modulesinfo = array();
            }
            $cache->set('modulesinfo', $modulesinfo);
        }

        return $modulesinfo;
    }
}


/**
 * Class for question behaviours.
 */
class plugininfo_qbehaviour extends plugininfo_base {

    public function is_uninstall_allowed() {
        return true;
    }

    public function get_uninstall_url() {
        return new moodle_url('/admin/qbehaviours.php',
                array('delete' => $this->name, 'sesskey' => sesskey()));
    }
}


/**
 * Class for question types
 */
class plugininfo_qtype extends plugininfo_base {

    public function is_uninstall_allowed() {
        return true;
    }

    public function get_uninstall_url() {
        return new moodle_url('/admin/qtypes.php',
                array('delete' => $this->name, 'sesskey' => sesskey()));
    }

    public function get_settings_section_name() {
        return 'qtypesetting' . $this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        global $CFG, $USER, $DB, $OUTPUT, $PAGE; // in case settings.php wants to refer to them
        $ADMIN = $adminroot; // may be used in settings.php
        $qtype = $this; // also can be used inside settings.php
        $section = $this->get_settings_section_name();

        $settings = null;
        $systemcontext = context_system::instance();
        if (($hassiteconfig || has_capability('moodle/question:config', $systemcontext)) &&
                file_exists($this->full_path('settings.php'))) {
            $settings = new admin_settingpage($section, $this->displayname,
                    'moodle/question:config', $this->is_enabled() === false);
            include($this->full_path('settings.php')); // this may also set $settings to null
        }
        if ($settings) {
            $ADMIN->add($parentnodename, $settings);
        }
    }
}


/**
 * Class for authentication plugins
 */
class plugininfo_auth extends plugininfo_base {

    public function is_enabled() {
        global $CFG;

        if (in_array($this->name, array('nologin', 'manual'))) {
            // these two are always enabled and can't be disabled
            return null;
        }

        $enabled = array_flip(explode(',', $CFG->auth));

        return isset($enabled[$this->name]);
    }

    public function get_settings_section_name() {
        return 'authsetting' . $this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        global $CFG, $USER, $DB, $OUTPUT, $PAGE; // in case settings.php wants to refer to them
        $ADMIN = $adminroot; // may be used in settings.php
        $auth = $this; // also to be used inside settings.php
        $section = $this->get_settings_section_name();

        $settings = null;
        if ($hassiteconfig) {
            if (file_exists($this->full_path('settings.php'))) {
                // TODO: finish implementation of common settings - locking, etc.
                $settings = new admin_settingpage($section, $this->displayname,
                        'moodle/site:config', $this->is_enabled() === false);
                include($this->full_path('settings.php')); // this may also set $settings to null
            } else {
                $settingsurl = new moodle_url('/admin/auth_config.php', array('auth' => $this->name));
                $settings = new admin_externalpage($section, $this->displayname,
                        $settingsurl, 'moodle/site:config', $this->is_enabled() === false);
            }
        }
        if ($settings) {
            $ADMIN->add($parentnodename, $settings);
        }
    }
}


/**
 * Class for enrolment plugins
 */
class plugininfo_enrol extends plugininfo_base {

    public function is_enabled() {
        global $CFG;

        // We do not actually need whole enrolment classes here so we do not call
        // {@link enrol_get_plugins()}. Note that this may produce slightly different
        // results, for example if the enrolment plugin does not contain lib.php
        // but it is listed in $CFG->enrol_plugins_enabled

        $enabled = array_flip(explode(',', $CFG->enrol_plugins_enabled));

        return isset($enabled[$this->name]);
    }

    public function get_settings_section_name() {
        if (file_exists($this->full_path('settings.php'))) {
            return 'enrolsettings' . $this->name;
        } else {
            return null;
        }
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        global $CFG, $USER, $DB, $OUTPUT, $PAGE; // in case settings.php wants to refer to them

        if (!$hassiteconfig or !file_exists($this->full_path('settings.php'))) {
            return;
        }
        $section = $this->get_settings_section_name();

        $ADMIN = $adminroot; // may be used in settings.php
        $enrol = $this; // also can be used inside settings.php
        $settings = new admin_settingpage($section, $this->displayname,
                'moodle/site:config', $this->is_enabled() === false);

        include($this->full_path('settings.php')); // This may also set $settings to null!

        if ($settings) {
            $ADMIN->add($parentnodename, $settings);
        }
    }

    public function is_uninstall_allowed() {
        if ($this->name === 'manual') {
            return false;
        }
        return true;
    }

    /**
     * Return warning with number of activities and number of affected courses.
     *
     * @return string
     */
    public function get_uninstall_extra_warning() {
        global $DB, $OUTPUT;

        $sql = "SELECT COUNT('x')
                  FROM {user_enrolments} ue
                  JOIN {enrol} e ON e.id = ue.enrolid
                 WHERE e.enrol = :plugin";
        $count = $DB->count_records_sql($sql, array('plugin'=>$this->name));

        if (!$count) {
            return '';
        }

        $migrateurl = new moodle_url('/admin/enrol.php', array('action'=>'migrate', 'enrol'=>$this->name, 'sesskey'=>sesskey()));
        $migrate = new single_button($migrateurl, get_string('migratetomanual', 'core_enrol'));
        $button = $OUTPUT->render($migrate);

        $result = '<p>'.get_string('uninstallextraconfirmenrol', 'core_plugin', array('enrolments'=>$count)).'</p>';
        $result .= $button;

        return $result;
    }
}


/**
 * Class for messaging processors
 */
class plugininfo_message extends plugininfo_base {

    public function get_settings_section_name() {
        return 'messagesetting' . $this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        global $CFG, $USER, $DB, $OUTPUT, $PAGE; // in case settings.php wants to refer to them
        $ADMIN = $adminroot; // may be used in settings.php
        if (!$hassiteconfig) {
            return;
        }
        $section = $this->get_settings_section_name();

        $settings = null;
        $processors = get_message_processors();
        if (isset($processors[$this->name])) {
            $processor = $processors[$this->name];
            if ($processor->available && $processor->hassettings) {
                $settings = new admin_settingpage($section, $this->displayname,
                        'moodle/site:config', $this->is_enabled() === false);
                include($this->full_path('settings.php')); // this may also set $settings to null
            }
        }
        if ($settings) {
            $ADMIN->add($parentnodename, $settings);
        }
    }

    /**
     * @see plugintype_interface::is_enabled()
     */
    public function is_enabled() {
        $processors = get_message_processors();
        if (isset($processors[$this->name])) {
            return $processors[$this->name]->configured && $processors[$this->name]->enabled;
        } else {
            return parent::is_enabled();
        }
    }

    public function is_uninstall_allowed() {
        $processors = get_message_processors();
        if (isset($processors[$this->name])) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * @see plugintype_interface::get_uninstall_url()
     */
    public function get_uninstall_url() {
        $processors = get_message_processors();
        return new moodle_url('/admin/message.php', array('uninstall' => $processors[$this->name]->id, 'sesskey' => sesskey()));
    }
}


/**
 * Class for repositories
 */
class plugininfo_repository extends plugininfo_base {

    public function is_enabled() {

        $enabled = self::get_enabled_repositories();

        return isset($enabled[$this->name]);
    }

    public function get_settings_section_name() {
        return 'repositorysettings'.$this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        if ($hassiteconfig && $this->is_enabled()) {
            // completely no access to repository setting when it is not enabled
            $sectionname = $this->get_settings_section_name();
            $settingsurl = new moodle_url('/admin/repository.php',
                    array('sesskey' => sesskey(), 'action' => 'edit', 'repos' => $this->name));
            $settings = new admin_externalpage($sectionname, $this->displayname,
                    $settingsurl, 'moodle/site:config', false);
            $adminroot->add($parentnodename, $settings);
        }
    }

    /**
     * Provides access to the records in {repository} table
     *
     * @param bool $disablecache do not attempt to obtain data from the cache
     * @return array array of stdClasses
     */
    protected static function get_enabled_repositories($disablecache=false) {
        global $DB;

        $cache = cache::make('core', 'plugininfo_repository');

        $enabled = $cache->get('enabled');

        if ($enabled === false or $disablecache) {
            $enabled = $DB->get_records('repository', null, 'type', 'type,visible,sortorder');
            $cache->set('enabled', $enabled);
        }

        return $enabled;
    }
}


/**
 * Class for portfolios
 */
class plugininfo_portfolio extends plugininfo_base {

    public function is_enabled() {

        $enabled = self::get_enabled_portfolios();

        return isset($enabled[$this->name]);
    }

    /**
     * Returns list of enabled portfolio plugins
     *
     * Portfolio plugin is enabled if there is at least one record in the {portfolio_instance}
     * table for it.
     *
     * @param bool $disablecache do not attempt to obtain data from the cache
     * @return array array of stdClasses with properties plugin and visible indexed by plugin
     */
    protected static function get_enabled_portfolios($disablecache=false) {
        global $DB;

        $cache = cache::make('core', 'plugininfo_portfolio');

        $enabled = $cache->get('enabled');

        if ($enabled === false or $disablecache) {
            $enabled = array();
            $instances = $DB->get_recordset('portfolio_instance', null, '', 'plugin,visible');
            foreach ($instances as $instance) {
                if (isset($enabled[$instance->plugin])) {
                    if ($instance->visible) {
                        $enabled[$instance->plugin]->visible = $instance->visible;
                    }
                } else {
                    $enabled[$instance->plugin] = $instance;
                }
            }
            $instances->close();
            $cache->set('enabled', $enabled);
        }

        return $enabled;
    }
}


/**
 * Class for themes
 */
class plugininfo_theme extends plugininfo_base {

    public function is_enabled() {
        global $CFG;

        if ((!empty($CFG->theme) and $CFG->theme === $this->name) or
            (!empty($CFG->themelegacy) and $CFG->themelegacy === $this->name)) {
            return true;
        } else {
            return parent::is_enabled();
        }
    }
}


/**
 * Class representing an MNet service
 */
class plugininfo_mnetservice extends plugininfo_base {

    public function is_enabled() {
        global $CFG;

        if (empty($CFG->mnet_dispatcher_mode) || $CFG->mnet_dispatcher_mode !== 'strict') {
            return false;
        } else {
            return parent::is_enabled();
        }
    }
}


/**
 * Class for admin tool plugins
 */
class plugininfo_tool extends plugininfo_base {

    public function is_uninstall_allowed() {
        return true;
    }
}


/**
 * Class for admin tool plugins
 */
class plugininfo_report extends plugininfo_base {

    public function is_uninstall_allowed() {
        return true;
    }
}


/**
 * Class for local plugins
 */
class plugininfo_local extends plugininfo_base {

    public function is_uninstall_allowed() {
        return true;
    }
}

/**
 * Class for HTML editors
 */
class plugininfo_editor extends plugininfo_base {

    public function get_settings_section_name() {
        return 'editorsettings' . $this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        global $CFG, $USER, $DB, $OUTPUT, $PAGE; // in case settings.php wants to refer to them
        $ADMIN = $adminroot; // may be used in settings.php
        $editor = $this; // also can be used inside settings.php
        $section = $this->get_settings_section_name();

        $settings = null;
        if ($hassiteconfig && file_exists($this->full_path('settings.php'))) {
            $settings = new admin_settingpage($section, $this->displayname,
                    'moodle/site:config', $this->is_enabled() === false);
            include($this->full_path('settings.php')); // this may also set $settings to null
        }
        if ($settings) {
            $ADMIN->add($parentnodename, $settings);
        }
    }

    /**
     * Basic textarea editor can not be uninstalled.
     */
    public function is_uninstall_allowed() {
        if ($this->name === 'textarea') {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Returns the information about plugin availability
     *
     * True means that the plugin is enabled. False means that the plugin is
     * disabled. Null means that the information is not available, or the
     * plugin does not support configurable availability or the availability
     * can not be changed.
     *
     * @return null|bool
     */
    public function is_enabled() {
        global $CFG;
        if (empty($CFG->texteditors)) {
            $CFG->texteditors = 'tinymce,textarea';
        }
        if (in_array($this->name, explode(',', $CFG->texteditors))) {
            return true;
        }
        return false;
    }
}

/**
 * Class for plagiarism plugins
 */
class plugininfo_plagiarism extends plugininfo_base {

    public function get_settings_section_name() {
        return 'plagiarism'. $this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        // plagiarism plugin just redirect to settings.php in the plugins directory
        if ($hassiteconfig && file_exists($this->full_path('settings.php'))) {
            $section = $this->get_settings_section_name();
            $settingsurl = new moodle_url($this->get_dir().'/settings.php');
            $settings = new admin_externalpage($section, $this->displayname,
                    $settingsurl, 'moodle/site:config', $this->is_enabled() === false);
            $adminroot->add($parentnodename, $settings);
        }
    }

    public function is_uninstall_allowed() {
        return true;
    }
}

/**
 * Class for webservice protocols
 */
class plugininfo_webservice extends plugininfo_base {

    public function get_settings_section_name() {
        return 'webservicesetting' . $this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        global $CFG, $USER, $DB, $OUTPUT, $PAGE; // in case settings.php wants to refer to them
        $ADMIN = $adminroot; // may be used in settings.php
        $webservice = $this; // also can be used inside settings.php
        $section = $this->get_settings_section_name();

        $settings = null;
        if ($hassiteconfig && file_exists($this->full_path('settings.php'))) {
            $settings = new admin_settingpage($section, $this->displayname,
                    'moodle/site:config', $this->is_enabled() === false);
            include($this->full_path('settings.php')); // this may also set $settings to null
        }
        if ($settings) {
            $ADMIN->add($parentnodename, $settings);
        }
    }

    public function is_enabled() {
        global $CFG;
        if (empty($CFG->enablewebservices)) {
            return false;
        }
        $active_webservices = empty($CFG->webserviceprotocols) ? array() : explode(',', $CFG->webserviceprotocols);
        if (in_array($this->name, $active_webservices)) {
            return true;
        }
        return false;
    }

    public function is_uninstall_allowed() {
        return false;
    }
}

/**
 * Class for course formats
 */
class plugininfo_format extends plugininfo_base {

    /**
     * Gathers and returns the information about all plugins of the given type
     *
     * @param string $type the name of the plugintype, eg. mod, auth or workshopform
     * @param string $typerootdir full path to the location of the plugin dir
     * @param string $typeclass the name of the actually called class
     * @return array of plugintype classes, indexed by the plugin name
     */
    public static function get_plugins($type, $typerootdir, $typeclass) {
        global $CFG;
        $formats = parent::get_plugins($type, $typerootdir, $typeclass);
        require_once($CFG->dirroot.'/course/lib.php');
        $order = get_sorted_course_formats();
        $sortedformats = array();
        foreach ($order as $formatname) {
            $sortedformats[$formatname] = $formats[$formatname];
        }
        return $sortedformats;
    }

    public function get_settings_section_name() {
        return 'formatsetting' . $this->name;
    }

    public function load_settings(part_of_admin_tree $adminroot, $parentnodename, $hassiteconfig) {
        global $CFG, $USER, $DB, $OUTPUT, $PAGE; // in case settings.php wants to refer to them
        $ADMIN = $adminroot; // also may be used in settings.php
        $section = $this->get_settings_section_name();

        $settings = null;
        if ($hassiteconfig && file_exists($this->full_path('settings.php'))) {
            $settings = new admin_settingpage($section, $this->displayname,
                    'moodle/site:config', $this->is_enabled() === false);
            include($this->full_path('settings.php')); // this may also set $settings to null
        }
        if ($settings) {
            $ADMIN->add($parentnodename, $settings);
        }
    }

    public function is_enabled() {
        return !get_config($this->component, 'disabled');
    }

    public function is_uninstall_allowed() {
        if ($this->name !== get_config('moodlecourse', 'format') && $this->name !== 'site') {
            return true;
        } else {
            return false;
        }
    }

    public function get_uninstall_extra_warning() {
        global $DB;

        $coursecount = $DB->count_records('course', array('format' => $this->name));

        if (!$coursecount) {
            return '';
        }

        $defaultformat = $this->get_plugin_manager()->plugin_name('format_'.get_config('moodlecourse', 'format'));
        $message = get_string(
            'formatuninstallwithcourses', 'core_admin',
            (object)array('count' => $coursecount, 'format' => $this->displayname,
            'defaultformat' => $defaultformat));

        return $message;
    }
}||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL
            (
                (SCALAR)
                (SCALAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (SCALAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_VAR)
                    (AST_CONST))
                (AST_VAR))
            (
                (AST_TRY
                    (
                        (AST_ASSIGN
                            (AST_VAR)
                            (AST_METHOD_CALL
                                (AST_VAR)
                                (
                                    (SCALAR)
                                    (AST_CONST)
                                    (SCALAR)
                                    (SCALAR)))))
                    (AST_CATCH_LIST
                        (AST_CATCH
                            (AST_NAME_LIST)
                            (AST_VAR)
                            (
                                (AST_ASSIGN
                                    (AST_VAR)
                                    (AST_ARRAY)))))
                    (NULL))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)
                        (AST_VAR))))))
    (AST_RETURN
        (AST_VAR)))||||||||