    public function is_uninstall_allowed() {
        return false;
    }
}


/**
 * Modified {@link plugin_manager} suitable for testing purposes
 */
class testable_plugin_manager extends plugin_manager {

    /**
     * Factory method for this class
     *
     * @return plugin_manager the singleton instance
     */
    public static function instance() {
        global $CFG;

        if (is_null(self::$singletoninstance)) {
            self::$singletoninstance = new self();
        }
        return self::$singletoninstance;
    }

    /**
     * A version of {@link plugin_manager::get_plugins()} that prepares some faked
     * testable instances.
     *
     * @param bool $disablecache ignored in this class
     * @return array
     */
    public function get_plugins($disablecache = false) {

        $dirroot = dirname(__FILE__).'/fixtures/mockplugins';

        $this->pluginsinfo = array(
            'mod' => array(
                'foo' => plugininfo_default_factory::make('mod', $dirroot.'/mod', 'foo',
                    $dirroot.'/mod/foo', 'testable_plugininfo_mod'),
                'bar' => plugininfo_default_factory::make('mod', $dirroot.'/bar', 'bar',
                    $dirroot.'/mod/bar', 'testable_plugininfo_mod'),
                'baz' => plugininfo_default_factory::make('mod', $dirroot.'/baz', 'baz',
                    $dirroot.'/mod/baz', 'testable_plugininfo_mod'),
                'qux' => plugininfo_default_factory::make('mod', $dirroot.'/qux', 'qux',
                    $dirroot.'/mod/qux', 'testable_plugininfo_mod'),
                'new' => plugininfo_default_factory::make('mod', $dirroot.'/new', 'new',
                    $dirroot.'/mod/new', 'testable_plugininfo_mod'),
            ),
            'foolish' => array(
                'frog' => plugininfo_default_factory::make('foolish', $dirroot.'/mod/foo/lish', 'frog',
                    $dirroot.'/mod/foo/lish/frog', 'testable_pluginfo_foolish'),
                'hippo' => plugininfo_default_factory::make('foolish', $dirroot.'/mod/foo/lish', 'hippo',
                    $dirroot.'/mod/foo/lish/hippo', 'testable_pluginfo_foolish'),
            ),
            'bazmeg' => array(
                'one' => plugininfo_default_factory::make('bazmeg', $dirroot.'/mod/baz/meg', 'one',
                    $dirroot.'/mod/baz/meg/one', 'testable_pluginfo_bazmeg'),
            ),
            'quxcat' => array(
                'one' => plugininfo_default_factory::make('quxcat', $dirroot.'/mod/qux/cat', 'one',
                    $dirroot.'/mod/qux/cat/one', 'testable_pluginfo_quxcat'),
            ),
        );

        $checker = testable_available_update_checker::instance();
        $this->pluginsinfo['mod']['foo']->check_available_updates($checker);
        $this->pluginsinfo['mod']['bar']->check_available_updates($checker);
        $this->pluginsinfo['mod']['baz']->check_available_updates($checker);
        $this->pluginsinfo['mod']['new']->check_available_updates($checker);
        $this->pluginsinfo['bazmeg']['one']->check_available_updates($checker);
        $this->pluginsinfo['quxcat']['one']->check_available_updates($checker);

        return $this->pluginsinfo;
    }

    /**
     * Testable version of {@link plugin_manager::get_subplugins()} that works with
     * the simulated environment.
     *
     * In this case, the mod_foo fake module provides subplugins of type 'foolish',
     * mod_baz provides subplugins of type 'bazmeg' and mod_qux has 'quxcat'.
     *
     * @param bool $disablecache ignored in this class
     * @return array
     */
    public function get_subplugins($disablecache = false) {

        $this->subpluginsinfo = array(
            'mod_foo' => array(
                'foolish' => (object)array(
                    'type' => 'foolish',
                    'typerootdir' => 'mod/foo/lish',
                ),
            ),
            'mod_baz' => array(
                'bazmeg' => (object)array(
                    'type' => 'bazmeg',
                    'typerootdir' => 'mod/baz/meg',
                ),
            ),
            'mod_qux' => array(
                'quxcat' => (object)array(
                    'type' => 'quxcat',
                    'typerootdir' => 'mod/qux/cat',
                ),
            ),
        );

        return $this->subpluginsinfo;
    }

    /**
     * Adds support for mock plugin types.
     */
    protected function normalize_component($component) {

        // List of mock plugin types used in these unit tests.
        $faketypes = array('foolish', 'bazmeg', 'quxcat');

        foreach ($faketypes as $faketype) {
            if (strpos($component, $faketype.'_') === 0) {
                return explode('_', $component, 2);
            }
        }

        return parent::normalize_component($component);
    }

    public function plugintype_name($type) {
        return ucfirst($type);
    }

    public function plugintype_name_plural($type) {
        return ucfirst($type).'s'; // Simple, isn't it? ;-).
    }

    public function plugin_external_source($component) {
        if ($component === 'foolish_frog') {
            return true;
        }
        return false;
    }
}


/**
 * Modified version of {@link available_update_checker} suitable for testing.
 */
class testable_available_update_checker extends available_update_checker {

    /** @var replaces the default DB table storage for the fetched response */
    protected $fakeresponsestorage;
    /** @var int stores the fake recentfetch value */
    public $fakerecentfetch = -1;
    /** @var int stores the fake value of time() */
    public $fakecurrenttimestamp = -1;

    /**
     * Factory method for this class.
     *
     * @return testable_available_update_checker the singleton instance
     */
    public static function instance() {
        global $CFG;

        if (is_null(self::$singletoninstance)) {
            self::$singletoninstance = new self();
        }
        return self::$singletoninstance;
    }

    protected function validate_response($response) {
    }

    protected function store_response($response) {
        $this->fakeresponsestorage = $response;
    }

    protected function restore_response($forcereload = false) {
        $this->recentfetch = time();
        $this->recentresponse = $this->decode_response($this->get_fake_response());
    }

    public function compare_responses(array $old, array $new) {
        return parent::compare_responses($old, $new);
    }

    public function is_same_release($remote, $local=null) {
        return parent::is_same_release($remote, $local);
    }

    protected function load_current_environment($forcereload=false) {
    }

    public function fake_current_environment($version, $release, $branch, array $plugins) {
        $this->currentversion = $version;
        $this->currentrelease = $release;
        $this->currentbranch = $branch;
        $this->currentplugins = $plugins;
    }

    public function get_last_timefetched() {
        if ($this->fakerecentfetch == -1) {
            return parent::get_last_timefetched();
        } else {
            return $this->fakerecentfetch;
        }
    }

    private function get_fake_response() {
        $fakeresponse = array(
            'status' => 'OK',
            'provider' => 'http://download.moodle.org/api/1.0/updates.php',
            'apiver' => '1.0',
            'timegenerated' => time(),
            'forversion' => '2012010100.00',
            'forbranch' => '2.3',
            'ticket' => sha1('No, I am not going to mention the word "frog" here. Oh crap. I just did.'),
            'updates' => array(
                'core' => array(
                    array(
                        'version' => 2012060103.00,
                        'release' => '2.3.3 (Build: 20121201)',
                        'maturity' => 200,
                        'url' => 'http://download.moodle.org/',
                        'download' => 'http://download.moodle.org/download.php/MOODLE_23_STABLE/moodle-2.3.3-latest.zip',
                    ),
                    array(
                        'version' => 2012120100.00,
                        'release' => '2.4dev (Build: 20121201)',
                        'maturity' => 50,
                        'url' => 'http://download.moodle.org/',
                        'download' => 'http://download.moodle.org/download.php/MOODLE_24_STABLE/moodle-2.4.0-latest.zip',
                    ),
                ),
                'mod_foo' => array(
                    array(
                        'version' => 2012030501,
                        'requires' => 2012010100,
                        'maturity' => 200,
                        'release' => '1.1',
                        'url' => 'http://moodle.org/plugins/blahblahblah/',
                        'download' => 'http://moodle.org/plugins/download.php/blahblahblah',
                    ),
                    array(
                        'version' => 2012030502,
                        'requires' => 2012010100,
                        'maturity' => 100,
                        'release' => '1.2 beta',
                        'url' => 'http://moodle.org/plugins/',
                    ),
                ),
            ),
        );

        return json_encode($fakeresponse);
    }

    protected function cron_current_timestamp() {
        if ($this->fakecurrenttimestamp == -1) {
            return parent::cron_current_timestamp();
        } else {
            return $this->fakecurrenttimestamp;
        }
    }

    protected function cron_mtrace($msg, $eol = PHP_EOL) {
    }

    protected function cron_autocheck_enabled() {
        return true;
    }

    protected function cron_execution_offset() {
        // Autofetch should run by the first cron after 01:42 AM.
        return 42 * MINSECS;
    }

    protected function cron_execute() {
        throw new testable_available_update_checker_cron_executed('Cron executed!');
    }
}


/**
 * Exception used to detect {@link available_update_checker::cron_execute()} calls.
 */
class testable_available_update_checker_cron_executed extends Exception {
}


/**
 * Modified {@link available_update_deployer} suitable for testing purposes.
 */
class testable_available_update_deployer extends available_update_deployer {
}


/**
 * Test cases for {@link available_update_deployer} class.
 *
 * @group core_plugin
 */
class core_available_update_deployer_testcase extends advanced_testcase {

    public function test_magic_setters() {
        $deployer = testable_available_update_deployer::instance();
        $value = new moodle_url('/');
        $deployer->set_returnurl($value);
        $this->assertSame($deployer->get_returnurl(), $value);
    }

    public function test_prepare_authorization() {
        global $CFG;

        $deployer = testable_available_update_deployer::instance();
        list($passfile, $password) = $deployer->prepare_authorization();
        $filename = $CFG->phpunit_dataroot.'/mdeploy/auth/'.$passfile;
        $this->assertFileExists($filename);
        $stored = file($filename, FILE_IGNORE_NEW_LINES);
        $this->assertCount(2, $stored);
        $this->assertGreaterThan(23, strlen($stored[0]));
        $this->assertSame($stored[0], $password);
        $this->assertLessThan(60, time() - (int)$stored[1]);
    }
}||||||||||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_RETURN
        (AST_CONST)))||||||||