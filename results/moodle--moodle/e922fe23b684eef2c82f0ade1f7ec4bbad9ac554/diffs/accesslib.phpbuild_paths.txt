||||||||    protected static function build_paths($force) {
        global $DB;

        if ($force or $DB->record_exists_select('context', "contextlevel = ".CONTEXT_BLOCK." AND (depth = 0 OR path IS NULL)")) {
            if ($force) {
                $ctxemptyclause = '';
            } else {
                $ctxemptyclause = "AND (ctx.path IS NULL OR ctx.depth = 0)";
            }

            // pctx.path IS NOT NULL prevents fatal problems with broken block instances that point to invalid context parent
            $sql = "INSERT INTO {context_temp} (id, path, depth)
                    SELECT ctx.id, ".$DB->sql_concat('pctx.path', "'/'", 'ctx.id').", pctx.depth+1
                      FROM {context} ctx
                      JOIN {block_instances} bi ON (bi.id = ctx.instanceid AND ctx.contextlevel = ".CONTEXT_BLOCK.")
                      JOIN {context} pctx ON (pctx.id = bi.parentcontextid)
                     WHERE (pctx.path IS NOT NULL AND pctx.depth > 0)
                           $ctxemptyclause";
            $trans = $DB->start_delegated_transaction();
            $DB->delete_records('context_temp');
            $DB->execute($sql);
            context::merge_context_temp_table();
            $DB->delete_records('context_temp');
            $trans->allow_commit();
        }
    }
}


// ============== DEPRECATED ========================


/**
 * Use load_temp_course_role() instead.
 * @deprecated
 * @param stdClass $context
 * @param int $roleid
 * @param array $accessdata
 * @return array
 */
function load_temp_role($context, $roleid, array $accessdata) {
    debugging('load_temp_role() is deprecated, please use load_temp_course_role() instead, temp role not loaded.');
    return $accessdata;
}

/**
 * Use remove_temp_course_roles() instead
 * @deprecated
 * @param object $context
 * @param array $accessdata
 * @return array access data
 */
function remove_temp_roles($context, array $accessdata) {
    debugging('remove_temp_role() is deprecated, please use remove_temp_course_roles() instead.');
    return $accessdata;
}

/**
 * Returns system context or null if can not be created yet.
 *
 * @deprecated
 * @param bool $cache use caching
 * @return context system context (null if context table not created yet)
 */
function get_system_context($cache = true) {
    return context_system::instance(0, IGNORE_MISSING, $cache);
}

/**
 * Get the context instance as an object. This function will create the
 * context instance if it does not exist yet.
 *
 * @deprecated
 * @param integer $contextlevel The context level, for example CONTEXT_COURSE, or CONTEXT_MODULE.
 * @param integer $instance The instance id. For $level = CONTEXT_COURSE, this would be $course->id,
 *      for $level = CONTEXT_MODULE, this would be $cm->id. And so on. Defaults to 0
 * @param int $strictness IGNORE_MISSING means compatible mode, false returned if record not found, debug message if more found;
 *      MUST_EXIST means throw exception if no record or multiple records found
 * @return context The context object.
 */
function get_context_instance($contextlevel, $instance = 0, $strictness = IGNORE_MISSING) {
    $instances = (array)$instance;
    $contexts = array();

    $classname = context_helper::get_class_for_level($contextlevel);

    // we do not load multiple contexts any more, PAGE should be responsible for any preloading
    foreach ($instances as $inst) {
        $contexts[$inst] = $classname::instance($inst, $strictness);
    }

    if (is_array($instance)) {
        return $contexts;
    } else {
        return $contexts[$instance];
    }
}

/**
 * Get a context instance as an object, from a given context id.
 *
 * @deprecated
 * @param int $id context id
 * @param int $strictness IGNORE_MISSING means compatible mode, false returned if record not found, debug message if more found;
 *                        MUST_EXIST means throw exception if no record or multiple records found
 * @return context|bool the context object or false if not found.
 */
function get_context_instance_by_id($id, $strictness = IGNORE_MISSING) {
    return context::instance_by_id($id, $strictness);
}

/**
 * Recursive function which, given a context, find all parent context ids,
 * and return the array in reverse order, i.e. parent first, then grand
 * parent, etc.
 *
 * @deprecated
 * @param context $context
 * @param bool $includeself optional, defaults to false
 * @return array
 */
function get_parent_contexts(context $context, $includeself = false) {
    return $context->get_parent_context_ids($includeself);
}

/**
 * Return the id of the parent of this context, or false if there is no parent (only happens if this
 * is the site context.)
 *
 * @deprecated
 * @param context $context
 * @return integer the id of the parent context.
 */
function get_parent_contextid(context $context) {
    if ($parent = $context->get_parent_context()) {
        return $parent->id;
    } else {
        return false;
    }
}

/**
 * Recursive function which, given a context, find all its children context ids.
 *
 * For course category contexts it will return immediate children only categories and courses.
 * It will NOT recurse into courses or child categories.
 * If you want to do that, call it on the returned courses/categories.
 *
 * When called for a course context, it will return the modules and blocks
 * displayed in the course page.
 *
 * If called on a user/course/module context it _will_ populate the cache with the appropriate
 * contexts ;-)
 *
 * @deprecated
 * @param context $context.
 * @return array Array of child records
 */
function get_child_contexts(context $context) {
    return $context->get_child_contexts();
}

/**
 * Precreates all contexts including all parents
 *
 * @deprecated
 * @param int $contextlevel empty means all
 * @param bool $buildpaths update paths and depths
 * @return void
 */
function create_contexts($contextlevel = null, $buildpaths = true) {
    context_helper::create_instances($contextlevel, $buildpaths);
}

/**
 * Remove stale context records
 *
 * @deprecated
 * @return bool
 */
function cleanup_contexts() {
    context_helper::cleanup_instances();
    return true;
}

/**
 * Populate context.path and context.depth where missing.
 *
 * @deprecated
 * @param bool $force force a complete rebuild of the path and depth fields, defaults to false
 * @return void
 */
function build_context_path($force = false) {
    context_helper::build_all_paths($force);
}

/**
 * Rebuild all related context depth and path caches
 *
 * @deprecated
 * @param array $fixcontexts array of contexts, strongtyped
 * @return void
 */
function rebuild_contexts(array $fixcontexts) {
    foreach ($fixcontexts as $fixcontext) {
        $fixcontext->reset_paths(false);
    }
    context_helper::build_all_paths(false);
}

/**
 * Preloads all contexts relating to a course: course, modules. Block contexts
 * are no longer loaded here. The contexts for all the blocks on the current
 * page are now efficiently loaded by {@link block_manager::load_blocks()}.
 *
 * @deprecated
 * @param int $courseid Course ID
 * @return void
 */
function preload_course_contexts($courseid) {
    context_helper::preload_course($courseid);
}

/**
 * Preloads context information together with instances.
 * Use context_instance_preload() to strip the context info from the record and cache the context instance.
 *
 * @deprecated
 * @param string $joinon for example 'u.id'
 * @param string $contextlevel context level of instance in $joinon
 * @param string $tablealias context table alias
 * @return array with two values - select and join part
 */
function context_instance_preload_sql($joinon, $contextlevel, $tablealias) {
    $select = ", ".context_helper::get_preload_record_columns_sql($tablealias);
    $join = "LEFT JOIN {context} $tablealias ON ($tablealias.instanceid = $joinon AND $tablealias.contextlevel = $contextlevel)";
    return array($select, $join);
}

/**
 * Preloads context information from db record and strips the cached info.
 * The db request has to contain both the $join and $select from context_instance_preload_sql()
 *
 * @deprecated
 * @param stdClass $rec
 * @return void (modifies $rec)
 */
function context_instance_preload(stdClass $rec) {
    context_helper::preload_from_record($rec);
}

/**
 * Mark a context as dirty (with timestamp) so as to force reloading of the context.
 *
 * NOTE: use $context->mark_dirty() instead
 *
 * @deprecated
 * @param string $path context path
 */
function mark_context_dirty($path) {
    global $CFG, $USER, $ACCESSLIB_PRIVATE;

    if (during_initial_install()) {
        return;
    }

    // only if it is a non-empty string
    if (is_string($path) && $path !== '') {
        set_cache_flag('accesslib/dirtycontexts', $path, 1, time()+$CFG->sessiontimeout);
        if (isset($ACCESSLIB_PRIVATE->dirtycontexts)) {
            $ACCESSLIB_PRIVATE->dirtycontexts[$path] = 1;
        } else {
            if (CLI_SCRIPT) {
                $ACCESSLIB_PRIVATE->dirtycontexts = array($path => 1);
            } else {
                if (isset($USER->access['time'])) {
                    $ACCESSLIB_PRIVATE->dirtycontexts = get_cache_flags('accesslib/dirtycontexts', $USER->access['time']-2);
                } else {
                    $ACCESSLIB_PRIVATE->dirtycontexts = array($path => 1);
                }
                // flags not loaded yet, it will be done later in $context->reload_if_dirty()
            }
        }
    }
}

/**
 * Update the path field of the context and all dep. subcontexts that follow
 *
 * Update the path field of the context and
 * all the dependent subcontexts that follow
 * the move.
 *
 * The most important thing here is to be as
 * DB efficient as possible. This op can have a
 * massive impact in the DB.
 *
 * @deprecated
 * @param context $context context obj
 * @param context $newparent new parent obj
 * @return void
 */
function context_moved(context $context, context $newparent) {
    $context->update_moved($newparent);
}

/**
 * Remove a context record and any dependent entries,
 * removes context from static context cache too
 *
 * @deprecated
 * @param int $contextlevel
 * @param int $instanceid
 * @param bool $deleterecord false means keep record for now
 * @return bool returns true or throws an exception
 */
function delete_context($contextlevel, $instanceid, $deleterecord = true) {
    if ($deleterecord) {
        context_helper::delete_instance($contextlevel, $instanceid);
    } else {
        $classname = context_helper::get_class_for_level($contextlevel);
        if ($context = $classname::instance($instanceid, IGNORE_MISSING)) {
            $context->delete_content();
        }
    }

    return true;
}

/**
 *
 * @deprecated
 * @param integer $contextlevel $context->context level. One of the CONTEXT_... constants.
 * @return string the name for this type of context.
 */
function get_contextlevel_name($contextlevel) {
    return context_helper::get_level_name($contextlevel);
}

/**
 * Prints human readable context identifier.
 *
 * @deprecated
 * @param context $context the context.
 * @param boolean $withprefix whether to prefix the name of the context with the
 *      type of context, e.g. User, Course, Forum, etc.
 * @param boolean $short whether to user the short name of the thing. Only applies
 *      to course contexts
 * @return string the human readable context name.
 */
function print_context_name(context $context, $withprefix = true, $short = false) {
    return $context->get_context_name($withprefix, $short);
}

/**
 * Get a URL for a context, if there is a natural one. For example, for
 * CONTEXT_COURSE, this is the course page. For CONTEXT_USER it is the
 * user profile page.
 *
 * @deprecated
 * @param context $context the context.
 * @return moodle_url
 */
function get_context_url(context $context) {
    return $context->get_url();
}

/**
 * Is this context part of any course? if yes return course context,
 * if not return null or throw exception.
 *
 * @deprecated
 * @param context $context
 * @return course_context context of the enclosing course, null if not found or exception
 */
function get_course_context(context $context) {
    return $context->get_course_context(true);
}

/**
 * Returns current course id or null if outside of course based on context parameter.
 *
 * @deprecated
 * @param context $context
 * @return int|bool related course id or false
 */
function get_courseid_from_context(context $context) {
    if ($coursecontext = $context->get_course_context(false)) {
        return $coursecontext->instanceid;
    } else {
        return false;
    }
}

/**
 * Get an array of courses where cap requested is available
 * and user is enrolled, this can be relatively slow.
 *
 * @deprecated
 * @param int    $userid A user id. By default (null) checks the permissions of the current user.
 * @param string $cap - name of the capability
 * @param array  $accessdata_ignored
 * @param bool   $doanything_ignored
 * @param string $sort - sorting fields - prefix each fieldname with "c."
 * @param array  $fields - additional fields you are interested in...
 * @param int    $limit_ignored
 * @return array $courses - ordered array of course objects - see notes above
 */
function get_user_courses_bycap($userid, $cap, $accessdata_ignored, $doanything_ignored, $sort = 'c.sortorder ASC', $fields = null, $limit_ignored = 0) {

    $courses = enrol_get_users_courses($userid, true, $fields, $sort);
    foreach ($courses as $id=>$course) {
        $context = context_course::instance($id);
        if (!has_capability($cap, $context, $userid)) {
            unset($courses[$id]);
        }
    }

    return $courses;
}

/**
 * Extracts the relevant capabilities given a contextid.
 * All case based, example an instance of forum context.
 * Will fetch all forum related capabilities, while course contexts
 * Will fetch all capabilities
 *
 * capabilities
 * `name` varchar(150) NOT NULL,
 * `captype` varchar(50) NOT NULL,
 * `contextlevel` int(10) NOT NULL,
 * `component` varchar(100) NOT NULL,
 *
 * @deprecated
 * @param context $context
 * @return array
 */
function fetch_context_capabilities(context $context) {
    return $context->get_capabilities();
}

/**
 * Runs get_records select on context table and returns the result
 * Does get_records_select on the context table, and returns the results ordered
 * by contextlevel, and then the natural sort order within each level.
 * for the purpose of $select, you need to know that the context table has been
 * aliased to ctx, so for example, you can call get_sorted_contexts('ctx.depth = 3');
 *
 * @deprecated
 * @param string $select the contents of the WHERE clause. Remember to do ctx.fieldname.
 * @param array $params any parameters required by $select.
 * @return array the requested context records.
 */
function get_sorted_contexts($select, $params = array()) {

    //TODO: we should probably rewrite all the code that is using this thing, the trouble is we MUST NOT modify the context instances...

    global $DB;
    if ($select) {
        $select = 'WHERE ' . $select;
    }
    return $DB->get_records_sql("
            SELECT ctx.*
              FROM {context} ctx
              LEFT JOIN {user} u ON ctx.contextlevel = " . CONTEXT_USER . " AND u.id = ctx.instanceid
              LEFT JOIN {course_categories} cat ON ctx.contextlevel = " . CONTEXT_COURSECAT . " AND cat.id = ctx.instanceid
              LEFT JOIN {course} c ON ctx.contextlevel = " . CONTEXT_COURSE . " AND c.id = ctx.instanceid
              LEFT JOIN {course_modules} cm ON ctx.contextlevel = " . CONTEXT_MODULE . " AND cm.id = ctx.instanceid
              LEFT JOIN {block_instances} bi ON ctx.contextlevel = " . CONTEXT_BLOCK . " AND bi.id = ctx.instanceid
           $select
          ORDER BY ctx.contextlevel, bi.defaultregion, COALESCE(cat.sortorder, c.sortorder, cm.section, bi.defaultweight), u.lastname, u.firstname, cm.id
            ", $params);
}

/**
 * This is really slow!!! do not use above course context level
 *
 * @deprecated
 * @param int $roleid
 * @param context $context
 * @return array
 */
function get_role_context_caps($roleid, context $context) {
    global $DB;

    //this is really slow!!!! - do not use above course context level!
    $result = array();
    $result[$context->id] = array();

    // first emulate the parent context capabilities merging into context
    $searchcontexts = array_reverse($context->get_parent_context_ids(true));
    foreach ($searchcontexts as $cid) {
        if ($capabilities = $DB->get_records('role_capabilities', array('roleid'=>$roleid, 'contextid'=>$cid))) {
            foreach ($capabilities as $cap) {
                if (!array_key_exists($cap->capability, $result[$context->id])) {
                    $result[$context->id][$cap->capability] = 0;
                }
                $result[$context->id][$cap->capability] += $cap->permission;
            }
        }
    }

    // now go through the contexts bellow given context
    $searchcontexts = array_keys($context->get_child_contexts());
    foreach ($searchcontexts as $cid) {
        if ($capabilities = $DB->get_records('role_capabilities', array('roleid'=>$roleid, 'contextid'=>$cid))) {
            foreach ($capabilities as $cap) {
                if (!array_key_exists($cap->contextid, $result)) {
                    $result[$cap->contextid] = array();
                }
                $result[$cap->contextid][$cap->capability] = $cap->permission;
            }
        }
    }

    return $result;
}

/**
 * Gets a string for sql calls, searching for stuff in this context or above
 *
 * NOTE: use $DB->get_in_or_equal($context->get_parent_context_ids()...
 *
 * @deprecated
 * @param context $context
 * @return string
 */
function get_related_contexts_string(context $context) {

    if ($parents = $context->get_parent_context_ids()) {
        return (' IN ('.$context->id.','.implode(',', $parents).')');
    } else {
        return (' ='.$context->id);
    }
}||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_GLOBAL
        (AST_VAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)
                        (AST_BINARY_OP
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_CONST))
                            (SCALAR)))))
            (
                (AST_IF
                    (AST_IF_ELEM
                        (AST_VAR)
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (SCALAR))))
                    (AST_IF_ELEM
                        (NULL)
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (SCALAR)))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (AST_BINARY_OP
                            (AST_BINARY_OP
                                (AST_BINARY_OP
                                    (SCALAR)
                                    (AST_METHOD_CALL
                                        (AST_VAR)
                                        (
                                            (SCALAR)
                                            (SCALAR)
                                            (SCALAR))))
                                (SCALAR))
                            (AST_CONST))
                        (AST_ENCAPS_LIST
                            (SCALAR)
                            (AST_VAR))))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)))
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_VAR)))
                (AST_STATIC_CALL)
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)))
                (AST_METHOD_CALL
                    (AST_VAR))))))