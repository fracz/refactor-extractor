	public function __construct(View $View, $settings = array()) {
		$className = 'Jquery';
		if (is_array($settings) && isset($settings[0])) {
			$className = $settings[0];
		} elseif (is_string($settings)) {
			$className = $settings;
		}
		$engineName = $className;
		list($plugin, $className) = pluginSplit($className);

		$this->_engineName = $className . 'Engine';
		$engineClass = $engineName . 'Engine';
		$this->helpers[] = $engineClass;
		parent::__construct($View, $settings);
	}

/**
 * call__ Allows for dispatching of methods to the Engine Helper.
 * methods in the Engines bufferedMethods list will be automatically buffered.
 * You can control buffering with the buffer param as well. By setting the last parameter to
 * any engine method to a boolean you can force or disable buffering.
 *
 * e.g. `$js->get('#foo')->effect('fadeIn', array('speed' => 'slow'), true);`
 *
 * Will force buffering for the effect method. If the method takes an options array you may also add
 * a 'buffer' param to the options array and control buffering there as well.
 *
 * e.g. `$js->get('#foo')->event('click', $functionContents, array('buffer' => true));`
 *
 * The buffer parameter will not be passed onto the EngineHelper.
 *
 * @param string $method Method to be called
 * @param array $params Parameters for the method being called.
 * @return mixed Depends on the return of the dispatched method, or it could be an instance of the EngineHelper
 */
||||||||	public function __construct(View $View, $settings = array()) {
		$className = 'Jquery';
		if (is_array($settings) && isset($settings[0])) {
			$className = $settings[0];
		} elseif (is_string($settings)) {
			$className = $settings;
		}
		$engineName = $className;
		list(, $className) = pluginSplit($className);

		$this->_engineName = $className . 'Engine';
		$engineClass = $engineName . 'Engine';
		$this->helpers[] = $engineClass;
		parent::__construct($View, $settings);
	}

/**
 * call__ Allows for dispatching of methods to the Engine Helper.
 * methods in the Engines bufferedMethods list will be automatically buffered.
 * You can control buffering with the buffer param as well. By setting the last parameter to
 * any engine method to a boolean you can force or disable buffering.
 *
 * e.g. `$js->get('#foo')->effect('fadeIn', array('speed' => 'slow'), true);`
 *
 * Will force buffering for the effect method. If the method takes an options array you may also add
 * a 'buffer' param to the options array and control buffering there as well.
 *
 * e.g. `$js->get('#foo')->event('click', $functionContents, array('buffer' => true));`
 *
 * The buffer parameter will not be passed onto the EngineHelper.
 *
 * @param string $method Method to be called
 * @param array $params Parameters for the method being called.
 * @return mixed Depends on the return of the dispatched method, or it could be an instance of the EngineHelper
 */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_VAR)))
                (AST_ISSET
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR)))))
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_VAR))
    (AST_ASSIGN
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL))
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL)))
        (AST_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_BINARY_OP
            (AST_VAR)
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_VAR)
            (SCALAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_PROP
                (AST_VAR))
            (NULL))
        (AST_VAR))
    (AST_STATIC_CALL
        (
            (AST_VAR)
            (AST_VAR))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CALL
                    (
                        (AST_VAR)))
                (AST_ISSET
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR))))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_DIM
                        (AST_VAR)
                        (SCALAR)))))
        (AST_IF_ELEM
            (AST_CALL
                (
                    (AST_VAR)))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_VAR))
    (AST_ASSIGN
        (AST_ARRAY
            (NULL)
            (AST_ARRAY_ELEM
                (AST_VAR)
                (NULL)))
        (AST_CALL
            (
                (AST_VAR))))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_BINARY_OP
            (AST_VAR)
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_VAR)
            (SCALAR)))
    (AST_ASSIGN
        (AST_DIM
            (AST_PROP
                (AST_VAR))
            (NULL))
        (AST_VAR))
    (AST_STATIC_CALL
        (
            (AST_VAR)
            (AST_VAR))))