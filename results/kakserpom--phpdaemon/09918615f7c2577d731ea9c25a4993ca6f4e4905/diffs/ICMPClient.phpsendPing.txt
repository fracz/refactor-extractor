	public function sendPing($host, $cb) {

		$connId = $this->connectTo('raw:' . $host);
		if (!$connId) {
			return false;
		}
		$conn = $this->getConnectionById($connId);
		$conn->sendEcho($cb);
		return $connId;
	}
}

class ICMPClientConnection extends NetworkClientConnection {
	public $seq = 0;
	public function sendEcho($cb) {
		++$this->seq;

		$data = 'phpdaemon';
		$packet = pack('ccnnn', strlen($data), 0, 0, Daemon::$process->pid,	$this->seq) . $data;
		$packet = substr_replace($packet, self::checksum($packet), 2, 2);
		$this->write($packet);
		$this->onResponse->push(array($cb, microtime(true)));
	}

	public static function checksum($data) {
		$bit = unpack('n*', $data);
		$sum = array_sum($bit);
		if (strlen($data) % 2) {
			$temp = unpack('C*', $data[strlen($data) - 1]);
			$sum += $temp[1];
		}
		$sum = ($sum >> 16) + ($sum & 0xffff);
		$sum += ($sum >> 16);
		return pack('n*', ~$sum);
	}


	/**
	 * Called when new data received
	 * @param string New data
	 * @return void
	 */
	public function stdin($buf) {
		// TODO: implement sequential packet exchange, incoming packet check
		$el = $this->onResponse->pop();
		if ($el) {
			list ($cb, $st) = $el;
			$cb(microtime(true) - $st);
		}
		$this->finish();
	}
}||||||||	public function sendPing($host, $cb) {
		$this->connectTo('raw:' . $host, 0, function($conn) use ($cb) {
			$conn->sendEcho($cb);
		});
	}
}

class ICMPClientConnection extends NetworkClientConnection {
	public $seq = 0;

	public function sendEcho($cb) {
		++$this->seq;

		$data = 'phpdaemon';
		$packet = pack('ccnnn', strlen($data), 0, 0, Daemon::$process->pid,	$this->seq) . $data;
		$packet = substr_replace($packet, self::checksum($packet), 2, 2);
		$this->write($packet);
		$this->onResponse->push(array($cb, microtime(true)));
	}

	public static function checksum($data) {
		$bit = unpack('n*', $data);
		$sum = array_sum($bit);
		if (strlen($data) % 2) {
			$temp = unpack('C*', $data[strlen($data) - 1]);
			$sum += $temp[1];
		}
		$sum = ($sum >> 16) + ($sum & 0xffff);
		$sum += ($sum >> 16);
		return pack('n*', ~$sum);
	}


	/**
	 * Called when new data received
	 * @param string New data
	 * @return void
	 */
	public function stdin($buf) {
		// TODO: implement sequential packet exchange, incoming packet check
		while (!$this->onResponse->isEmpty()) {
			$el = $this->onResponse->shift();
			list ($cb, $st) = $el;
			call_user_func($cb, microtime(true) - $st);
		}
		$this->finish();
	}
}||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_BINARY_OP
                    (SCALAR)
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_VAR)))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (SCALAR)
            (AST_CLOSURE
                (NO_PARAM_TYPENO_PARAM_DEFAULT)
                (AST_CLOSURE_USES
                    (AST_CLOSURE_VAR))
                (
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR))))))))