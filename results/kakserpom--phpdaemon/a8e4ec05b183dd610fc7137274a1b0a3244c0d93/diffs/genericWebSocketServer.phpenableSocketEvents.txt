||||||||    public function enableSocketEvents()
	{
        foreach ($this->socketEvents as $ev)
		{
            event_base_set($ev, Daemon::$process->eventBase);
            event_add($ev, $this->config->ev_timeout->value); // With specified timeout
        }
    }

	/**
	 * Called when a request to HTTP-server looks like WebSocket handshake query.
	 * @return void
	 */
/*
	public function inheritFromRequest($req, $appInstance)
	{
		$connId = $req->attrs->connId;

		unset(Daemon::$process->queue[$connId . '-' . $req->attrs->id]);

		$this->buf[$connId] = $appInstance->buf[$connId];

		unset($appInstance->buf[$connId]);
		unset($appInstance->poolState[$connId]);

		$set = event_buffer_set_callback(
			$this->buf[$connId],
			$this->directReads ? NULL : array($this, 'onReadEvent'),
			array($this, 'onWriteEvent'),
			array($this, 'onFailureEvent'),
			array($connId)
		);

		unset(Daemon::$process->readPoolState[$connId]);

		$this->poolState[$connId] = array();

		$this->sessions[$connId] = new genericWebSocketSession($connId, $this);
		$this->sessions[$connId]->clientAddr = $req->attrs->server['REMOTE_ADDR'];
		$this->sessions[$connId]->server = $req->attrs->server;
		$this->sessions[$connId]->firstline = TRUE;
		$this->sessions[$connId]->stdin("\r\n" . $req->attrs->inbuf);
	}
*/
	/**
	 * Adds a route if it doesn't exist already.
	 * @param string Route name.
	 * @param mixed Route's callback.
	 * @return boolean Success.
	 */

||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_FOREACH
        (AST_PROP
            (AST_VAR))
        (AST_VAR)
        (NULL)
        (
            (AST_CALL
                (
                    (AST_VAR)
                    (AST_PROP
                        (AST_STATIC_PROP))))
            (AST_CALL
                (
                    (AST_VAR)
                    (AST_PROP
                        (AST_PROP
                            (AST_PROP
                                (AST_VAR)))))))))