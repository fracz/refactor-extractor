 namespace TokenReflection;use ReflectionClass as InternalReflectionClass,ReflectionProperty as InternalReflectionProperty;use RuntimeException,InvalidArgumentException;class ReflectionClass extends ReflectionBase implements IReflectionClass{const PACKAGE_NONE='None';const IS_INTERFACE=128;const IMPLEMENTS_INTERFACES=0x80000;private$namespaceName;private$constants=array();private$properties=array();private$methods=array();private$aliases=array();private$modifiers=0;private$parentClassName;private$interfaces=array();protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFileNamespace){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseModifiers($tokenStream)->parseName($tokenStream)->parseParent($tokenStream,$parent)->parseInterfaces($tokenStream,$parent);}protected function parseChildren(Stream$tokenStream){while(true){switch($tokenStream->getType()){case null:break 2;case T_FUNCTION:$stream=$tokenStream->getMethodStream();$method=new ReflectionMethod($stream,$this->getBroker(),$this);$this->methods[$method->getName()]=$method;break;case T_CONST:$tokenStream->skipWhitespaces();while($tokenStream->is(T_STRING)){$stream=$tokenStream->getConstantStream();$constant=new ReflectionConstant($stream,$this->getBroker(),$this);$this->constants[$constant->getName()]=$constant;$tokenStream->skipWhitespaces();}break;case T_VARIABLE:$stream=$tokenStream->getPropertyStream();$property=new ReflectionProperty($stream,$this->getBroker(),$this);$this->properties[$property->getName()]=$property;break;default:$tokenStream->skipWhitespaces();}}return$this;}public function getConstant($name){try{return$this->getConstantReflection($name)->getValue();}catch(Exception$e){if($e->getCode()=== Exception::DOES_NOT_EXIST){return false;}throw$e;}}public function getConstantReflection($name){$constants=$this->getConstantReflections();if(isset($constants[$name])){return$constants[$name];}throw new Exception(sprintf('Constant "%s" is not defined in class "%s"',$name,$this->name),Exception::DOES_NOT_EXIST);}public function getConstants(){return array_map(function(IReflectionConstant$constant){return$constant->getValue();},$this->getConstantReflections());}public function getConstantReflections(){if(null ===$this->parentClassName){return$this->constants;}else{return array_merge($this->constants,$this->getParentClass()->getConstantReflections());}}public function getConstructor(){$methods=$this->getMethods();foreach($methods as$reflectionMethod){if($reflectionMethod->isConstructor()){return$reflectionMethod;}}return null;}public function getDestructor(){$methods=$this->getMethods();foreach($methods as$reflectionMethod){if($reflectionMethod->isDestructor()){return$reflectionMethod;}}return null;}public function getDefaultProperties(){$defaults=array();foreach($this->getProperties()as$name =>$property){if($property instanceof ReflectionProperty){$defaults[$name]=$property->getDefaultValue();}}return$defaults;}public function getInterfaceNames(){$parentClass=$this->getParentClass();$names=$parentClass?$parentClass->getInterfaceNames():array();foreach(array_reverse($this->interfaces)as$interfaceName){$names=array_merge($names,$this->getBroker()->getClass($interfaceName)->getInterfaceNames());$names[]=$interfaceName;}return array_unique($names);}public function getOwnInterfaceNames(){return array_reverse($this->interfaces);}public function getInterfaces(){$interfaceNames=$this->getInterfaceNames();if(empty($interfaceNames)){return array();}$broker=$this->getBroker();return array_combine($interfaceNames,array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$interfaceNames));}public function getMethod($name){$methods=$this->getMethods();if(!isset($methods[$name])){throw new Exception(sprintf('There is no method %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}return$methods[$name];}public function getMethods($filter=null){$methods=$this->getOwnMethods($filter);if(null !==$this->parentClassName){$methods=array_merge($this->getParentClass()->getMethods($filter),$methods);}return$methods;}public function getModifiers(){if(($this->modifiers&InternalReflectionClass::IS_EXPLICIT_ABSTRACT)&&!($this->modifiers&InternalReflectionClass::IS_IMPLICIT_ABSTRACT)){foreach($this->getMethods()as$reflectionMethod){if($reflectionMethod->isAbstract()){$this->modifiers |= InternalReflectionClass::IS_IMPLICIT_ABSTRACT;}}}if(count($this->getInterfaceNames())){$this->modifiers |= self::IMPLEMENTS_INTERFACES;}return$this->modifiers;}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function getParentClass(){$className=$this->getParentClassName();if(null ===$className){return null;}return$this->getBroker()->getClass($className);}public function getParentClasses(){$parent=$this->getParentClass();if(null ===$parent){return array();}return array_merge(array($parent->getName()=>$parent),$parent->getParentClasses());}public function getParentClassNameList(){$parent=$this->getParentClass();if(null ===$parent){return array();}return array_merge(array($parent->getName()),$parent->getParentClassNameList());}public function getParentClassName(){return$this->parentClassName;}public function getProperties($filter=null){$properties=$this->getOwnProperties($filter);if(null !==$this->parentClassName){$properties=array_merge($this->getParentClass()->getProperties($filter),$properties);}return$properties;}public function getProperty($name){$properties=$this->getProperties();if(!isset($properties[$name])){throw new Exception(sprintf('There is no property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}return$properties[$name];}public function getShortName(){$name=$this->getName();if($this->namespaceName !== ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}public function getStaticProperties(){$defaults=array();foreach($this->getProperties(InternalReflectionProperty::IS_STATIC)as$name =>$property){if($property instanceof ReflectionProperty){$defaults[$name]=$property->getDefaultValue();}}return$defaults;}public function getStaticPropertyValue($name,$default=null){$properties=$this->getProperties(InternalReflectionProperty::IS_STATIC);if(!isset($properties[$name])){throw new Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}$property=$properties[$name];if(!$property instanceof ReflectionProperty){return$property->getDeclaringClass()->getStaticPropertyValue($name,$default);}if(!$property->isPublic()&&!$property->isAccessible()){throw new Exception('Only public or accessible properties can return thier values');}return$property->getDefaultValue();}public function getOwnInterfaces(){$interfaceNames=$this->getOwnInterfaceNames();if(empty($interfaceNames)){return array();}$broker=$this->getBroker();return array_combine($interfaceNames,array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$interfaceNames));}public function getOwnMethods($filter=null){$methods=$this->methods;if(null !==$filter){$methods=array_filter($methods,function(ReflectionMethod$method)use($filter){return (bool)($method->getModifiers()&$filter);});}return$methods;}public function getOwnProperties($filter=null){$properties=$this->properties;if(null !==$filter){$properties=array_filter($properties,function(ReflectionProperty$property)use($filter){return (bool)($property->getModifiers()&$filter);});}return$properties;}public function getOwnConstants(){return array_map(function(ReflectionConstant$constant){return$constant->getValue();},$this->constants);}public function getOwnConstantReflections(){return$this->constants;}public function hasConstant($name){$constants=$this->getConstants();return isset($constants[$name]);}public function hasOwnConstant($name){return isset($this->constants[$name]);}public function hasMethod($name){$methods=$this->getMethods();return isset($methods[$name]);}public function hasOwnMethod($name){return isset($this->methods[$name]);}public function hasProperty($name){$properties=$this->getProperties();return isset($properties[$name]);}public function hasOwnProperty($name){return isset($this->properties[$name]);}public function implementsInterface($interface){if(is_object($interface)){if($interface instanceof InternalReflectionClass ||$interface instanceof IReflectionClass){$interfaceName=$interface->getName();}else{throw new InvalidArgumentException('Parameter must be a string or an instance of class reflection');}if(!$interface->isInterface()){throw new RuntimeException(sprintf('%s is not an interface.',$interfaceName));}}else{$reflection=$this->getBroker()->getClass($interface);if(!$reflection->isInterface()){throw new RuntimeException(sprintf('%s is not an interface.',$interface));}$interfaceName=$interface;}return in_array($interfaceName,$this->getInterfaceNames());}public function inNamespace(){return null !==$this->namespaceName &&ReflectionNamespace::NO_NAMESPACE_NAME !==$this->namespaceName;}public function isAbstract(){return (bool)($this->modifiers&InternalReflectionClass::IS_EXPLICIT_ABSTRACT);}public function isFinal(){return$this->modifiers === InternalReflectionClass::IS_FINAL;}public function isInstance($object){if(!is_object($object)){throw new Exception(sprintf('A class instance must be provided (%s set)',gettype($object)));}return$this->name === get_class($object)|| is_subclass_of($object,$this->name);}public function isInstantiable(){if($this->isInterface()||$this->isAbstract()){return false;}if(null ===($constructor=$this->getConstructor())){return true;}return$constructor->isPublic();}public function isCloneable(){if(!$this->isInstantiable()){return false;}$methods=$this->getMethods();return isset($methods['__clone'])?$methods['__clone']->isPublic():true;}public function isInterface(){return self::IS_INTERFACE ===$this->modifiers;}public function isException(){return 'Exception' ===$this->name ||$this->isSubclassOf('Exception');}public function isIterateable(){return$this->implementsInterface('Traversable');}public function isSubclassOf($class){if(is_object($class)){if(!$class instanceof InternalReflectionClass &&!$class instanceof IReflectionClass){throw new InvalidArgumentException('Parameter must be a string or an instance of class reflection');}$class=$class->getName();}if($class ===$this->parentClassName){return true;}$parent=$this->getParentClass();return null ===$parent?false:$parent->isSubclassOf($class);}public function getDirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->isSubClassOf($that);});}public function getDirectSubclassNames(){return array_keys($this->getDirectSubclasses());}public function getIndirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->isSubClassOf($that);});}public function getIndirectSubclassNames(){return array_keys($this->getIndirectSubclasses());}public function getDirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->implementsInterface($that);});}public function getDirectImplementerNames(){return array_keys($this->getDirectImplementers());}public function getIndirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->implementsInterface($that);});}public function getIndirectImplementerNames(){return array_keys($this->getIndirectImplementers());}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())&&false === strpos($docComment,'@inheritdoc')){return$docComment;}return null ===$this->parentClassName?false:$this->getParentClass()->getInheritedDocComment();}public function newInstance($args){return$this->newInstanceArgs(func_get_args());}public function newInstanceArgs(array$args=array()){if(!class_exists($this->name,true)){throw new Exception(sprintf('Could not create an instance of class %s; class not found',$this->name));}$reflection=new InternalReflectionClass($this->name);return$reflection->newInstanceArgs($args);}public function setStaticPropertyValue($name,$value){$properties=$this->getProperties(InternalReflectionProperty::IS_STATIC);if(!isset($properties[$name])){throw new Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}$reflectionProperty=$properties[$name];if(!$reflectionProperty->isPublic()&&!$reflectionProperty->isAccessible()){throw new Exception(sprintf('Cannot set property value; property %s is not public nor set accessible.',$name));}$reflectionProperty->setDefaultValue($value);}private function parseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case null:break 2;case T_ABSTRACT:$this->modifiers=InternalReflectionClass::IS_EXPLICIT_ABSTRACT;break;case T_FINAL:$this->modifiers=InternalReflectionClass::IS_FINAL;break;case T_INTERFACE:$this->modifiers=self::IS_INTERFACE;case T_CLASS:$tokenStream->skipWhitespaces();break 2;}$tokenStream->skipWhitespaces();}return$this;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw new RuntimeException('The class name could not be determined');}if($this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME){$this->name=$tokenStream->getTokenValue();}else{$this->name=$this->namespaceName.'\\'.$tokenStream->getTokenValue();}$tokenStream->skipWhitespaces();return$this;}private function parseParent(Stream$tokenStream,ReflectionBase$parent=null){if(!$tokenStream->is(T_EXTENDS)){return$this;}$tokenStream->skipWhitespaces();$parentClassName='';while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$parentClassName .=$tokenStream->getTokenValue();break;default:break 2;}$tokenStream->next();}$tokenStream->skipWhitespaces();$this->parentClassName=self::resolveClassFQN($parentClassName,$this->aliases,$this->namespaceName);return$this;}public function getNamespaceAliases(){return$this->aliases;}private function parseInterfaces(Stream$tokenStream,ReflectionBase$parent=null){if(!$tokenStream->is(T_IMPLEMENTS)){return$this;}while(true){$interfaceName='';$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$interfaceName .=$tokenStream->getTokenValue();break;default:break 2;}$tokenStream->next();}$this->interfaces[]=self::resolveClassFQN($interfaceName,$this->aliases,$this->namespaceName);$tokenStream->skipWhitespaces(false);$type=$tokenStream->getType();if('{' ===$type){break;}elseif(',' !==$type){throw new RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}return$this;}}
 namespace TokenReflection;use RuntimeException;class ReflectionConstant extends ReflectionBase implements IReflectionConstant{private$declaringClassName;private$namespaceName;private$value;private$valueDefinition='';protected function processParent(IReflection$parent){if($parent instanceof ReflectionFileNamespace){$this->namespaceName=$parent->getName();}elseif($parent instanceof ReflectionClass){$this->declaringClassName=$parent->getName();}else{throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace or TokenReflection\ReflectionClass, %s given.',get_class($parent)));}return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseName($tokenStream)->parseValue($tokenStream,$parent);}protected function parseName(Stream$tokenStream){if($tokenStream->is(T_CONST)){$tokenStream->skipWhitespaces();}if(!$tokenStream->is(T_STRING)){throw new RuntimeException('Could not determine the constant name');}if(null ===$this->namespaceName ||$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME){$this->name=$tokenStream->getTokenValue();}else{$this->name=$this->namespaceName.'\\'.$tokenStream->getTokenValue();}$tokenStream->skipWhitespaces();return$this;}private function parseValue(Stream$tokenStream,IReflection$parent){if(!$tokenStream->is('=')){throw new RuntimeException('Could not find the value definition start');}$tokenStream->skipWhitespaces();static$acceptedStrings=array('true','false','null');$evalValue=true;while($tokenStream->valid()){$value=$tokenStream->getTokenValue();if($tokenStream->is(T_STRING)&&!in_array(strtolower($value),$acceptedStrings)){$evalValue=false;}$this->valueDefinition .=$value;$tokenStream->next();}if(',' ===$value || ';' ===$value){$this->valueDefinition=trim(substr($this->valueDefinition,0,-1));}else{throw new RuntimeException(sprintf('Invalid value definition: "%s".',$this->valueDefinition));}if($evalValue){$this->value=eval(sprintf('return %s;',$this->valueDefinition));}else{if('\\' !==$this->valueDefinition{0}){$namespaceName=$this->namespaceName?:$parent->getNamespaceName();if($pos=strpos($this->valueDefinition,'::')){$className=substr($this->valueDefinition,0,$pos);$this->valueDefinition=ReflectionBase::resolveClassFQN($className,$parent->getNamespaceAliases(),$namespaceName).substr($this->valueDefinition,$pos);}elseif(ReflectionNamespace::NO_NAMESPACE_NAME !==$namespaceName){$this->valueDefinition=$namespaceName.'\\'.$this->valueDefinition;}}}return$this;}public function getValueDefinition(){return$this->valueDefinition;}public function getValue(){if(null ===$this->value &&'null' !== strtolower($this->valueDefinition)){if($position=strpos($this->valueDefinition,'::')){$className=substr($this->valueDefinition,0,$position);$constantName=substr($this->valueDefinition,$position+2);$this->value=$this->getBroker()->getClass($className)->getConstant($constantName);}else{$constant=$this->getBroker()->getConstant($this->valueDefinition);$this->value=$constant?$constant->getValue():null;}}return$this->value;}public function getDeclaringClassName(){return$this->declaringClassName;}public function getClass(){return$this->getDeclaringClassName();}public function getDeclaringClass(){if(null ===$this->declaringClassName){return null;}return$this->getBroker()->getClass($this->declaringClassName);}public function getInheritedDocComment(){return$this->getDocComment();}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function inNamespace(){return null !==$this->getNamespaceName();}public function getShortName(){$name=$this->getName();if(null !==$this->namespaceName &&$this->namespaceName !== ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}}
 namespace TokenReflection;use RuntimeException;class ReflectionFileNamespace extends ReflectionBase{private$aliases=array();private$classes=array();private$functions=array();private$constants=array();public function getClasses(){return$this->classes;}public function getFunctions(){return$this->functions;}public function getConstants(){return$this->constants;}public function getInheritedDocComment(){return$this->getDocComment();}public function getAliases(){return$this->aliases;}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFile){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFile, %s given.',get_class($parent)));}return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseName($tokenStream)->parseAliases($tokenStream);}protected function parseChildren(Stream$tokenStream){while(true){switch($tokenStream->getType()){case null:break 2;case T_CLASS:case T_INTERFACE:$stream=$tokenStream->getClassStream();$class=new ReflectionClass($stream,$this->getBroker(),$this);$this->classes[$class->getName()]=$class;break;case T_CONST:$tokenStream->skipWhitespaces();while($tokenStream->is(T_STRING)){$stream=$tokenStream->getConstantStream();$constant=new ReflectionConstant($stream,$this->getBroker(),$this);$this->constants[$constant->getName()]=$constant;$tokenStream->skipWhitespaces();}break;case T_FUNCTION:static$skipped=array(T_WHITESPACE,T_COMMENT,T_DOC_COMMENT);$position=$tokenStream->key();while(in_array($type=$tokenStream->getType($position+1),$skipped)){$position++;}if('(' ===$type){$tokenStream->skipWhitespaces();continue;}$stream=$tokenStream->getFunctionStream();$function=new ReflectionFunction($stream,$this->getBroker(),$this);$this->functions[$function->getName()]=$function;break;default:$tokenStream->skipWhitespaces();}}return$this;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_NAMESPACE)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;return$this;}$tokenStream->skipWhitespaces();$name='';while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$name .=$tokenStream->getTokenValue();break;default: break 2;}$tokenStream->next();}$name=ltrim($name,'\\');if(empty($name)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;}else{$this->name=$name;$tokenStream->skipWhitespaces();}return$this;}private function parseAliases(Stream$tokenStream){if(ReflectionNamespace::NO_NAMESPACE_NAME ===$this->name){return$this;}$aliases=array();while(true){if($tokenStream->is(T_USE)){while(true){$namespaceName='';$alias=null;$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$namespaceName .=$tokenStream->getTokenValue();break;default:break 2;}$tokenStream->next();}$namespaceName=ltrim($namespaceName,'\\');if(empty($namespaceName)){throw new RuntimeException('Imported namespace name could not be determined');}elseif('\\' === substr($namespaceName,-1)){throw new RuntimeException(sprintf('Invalid namespace name "%s"',$namespaceName));}$tokenStream->skipWhitespaces(false);if($tokenStream->is(T_AS)){$tokenStream->skipWhitespaces();if(!$tokenStream->is(T_STRING)){throw new RuntimeException(sprintf('The imported namespace "%s" seems aliased but the alias name could not be determined',$namespaceName));}$alias=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();}else{if(false !==($pos=strrpos($namespaceName,'\\'))){$alias=substr($namespaceName,$pos+1);}else{$alias=$namespaceName;}}if(isset($aliases[$alias])){throw new RuntimeException(sprintf('Namespace alias "%s" already defined',$alias));}$aliases[$alias]=$namespaceName;$type=$tokenStream->getType();if(';' ===$type){$tokenStream->skipWhitespaces();continue 2;}elseif(',' ===$type){continue;}throw new RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}else{break;}}$this->aliases=$aliases;return$this;}}
 namespace TokenReflection;use RuntimeException;abstract class ReflectionFunctionBase extends ReflectionBase implements IReflectionFunctionBase{protected$modifiers=0;private$staticVariables=array();protected$namespaceName;private$returnsReference=false;private$parameters=array();public function getModifiers(){return$this->modifiers;}public function inNamespace(){return null !==$this->getNamespaceName();}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function getNumberOfParameters(){return count($this->parameters);}public function getNumberOfRequiredParameters(){$count=0;array_walk($this->parameters,function(ReflectionParameter$parameter)use(&$count){if(!$parameter->isOptional()){$count++;}});return$count;}public function getParameters(){return$this->parameters;}public function getParameter($parameter){if(is_numeric($parameter)){if(isset($this->parameters[$parameter])){return$this->parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($this->parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getStaticVariables(){return$this->staticVariables;}public function isClosure(){return false;}public function returnsReference(){return$this->returnsReference;}public function getName(){if(null !==$this->namespaceName &&ReflectionNamespace::NO_NAMESPACE_NAME !==$this->namespaceName){return$this->namespaceName.'\\'.$this->name;}return$this->name;}public function getShortName(){return$this->name;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw new RuntimeException('Could not determine the method/function name');}$this->name=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();return$this;}final protected function parseChildren(Stream$tokenStream){return$this ->parseParameters($tokenStream)->parseStaticVariables($tokenStream);}final protected function parseParameters(Stream$tokenStream){if(!$tokenStream->is('(')){throw new RuntimeException('Could not determine parameters start');}$tokenStream->skipWhitespaces();while(null !==($type=$tokenStream->getType())&&')' !==$type){if(T_VARIABLE ===$type){$parameter=new ReflectionParameter($tokenStream->getParameterStream(),$this->getBroker(),$this);$this->parameters[]=$parameter;}if($tokenStream->is(')')){break;}else{$tokenStream->skipWhitespaces();}}return$this;}final protected function parseStaticVariables(Stream$tokenStream){return$this;}final protected function parseReturnsReference(Stream$tokenStream){if(!$tokenStream->is(T_FUNCTION)){throw new RuntimeException('Could not find the function keyword.');}$tokenStream->skipWhitespaces();$type=$tokenStream->getType();if('&' ===$type){$this->returnsReference=true;$tokenStream->skipWhitespaces();}elseif(!T_STRING ===$type){throw new RuntimeException(sprintf('Unexpected token type: %s',$tokenStream->getTokenName()));}return$this;}}
 namespace TokenReflection;use RuntimeException;class ReflectionNamespace implements IReflectionNamespace{const NO_NAMESPACE_NAME='no-namespace';private$broker;private$name;private$classes=array();private$functions=array();private$constants=array();public function __construct($name,Broker$broker){$this->name=$name;$this->broker=$broker;}public function getClass($className){$className=ltrim($className,'\\');if(false === strpos($className,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$className=$this->getName().'\\'.$className;}if(!isset($this->classes[$className])){throw new Exception(sprintf('Class %s does not exist',$className),Exception::DOES_NOT_EXIST);}return$this->classes[$className];}public function getClasses(){return$this->classes;}public function getClassNames(){return array_keys($this->classes);}public function getClassShortNames(){return array_map(function(IReflectionClass$class){return$class->getShortName();},$this->classes);}public function getFunction($functionName){$functionName=ltrim($functionName,'\\');if(false === strpos($functionName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$functionName=$this->getName().'\\'.$functionName;}if(!isset($this->functions[$functionName])){throw new Exception(sprintf('Function %s does not exist',$functionName),Exception::DOES_NOT_EXIST);}return$this->functions[$functionName];}public function getFunctions(){return$this->functions;}public function getFunctionNames(){return array_keys($this->functions);}public function getFunctionShortNames(){return array_map(function(IReflectionFunction$function){return$function->getShortName();},$this->functions);}public function getConstant($constantName){$constantName=ltrim($constantName,'\\');if(false === strpos($constantName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$constantName=$this->getName().'\\'.$constantName;}if(!isset($this->constants[$constantName])){throw new Exception(sprintf('Constant %s does not exist',$constantName),Exception::DOES_NOT_EXIST);}return$this->constants[$constantName];}public function getConstants(){return$this->constants;}public function getConstantNames(){return array_keys($this->constants);}public function getConstantShortNames(){return array_map(function(IReflectionConstant$constant){return$constant->getShortName();},$this->constants);}public function getName(){return$this->name;}public function getBroker(){return$this->broker;}public function isTokenized(){return true;}public function isInternal(){return false;}public function isUserDefined(){return true;}public function addFileNamespace(ReflectionFileNamespace$namespace){$classes=$namespace->getClasses();foreach($this->classes as$className =>$reflection){if(isset($classes[$className])){throw new RuntimeException(sprintf('Class %s was defined multiple times',$className));}}$this->classes=array_merge($this->classes,$classes);$functions=$namespace->getFunctions();foreach($this->functions as$functionName =>$reflection){if(isset($functions[$functionName])){throw new RuntimeException(sprintf('Function %s was defined multiple times',$functionName));}}$this->functions=array_merge($this->functions,$functions);$constants=$namespace->getConstants();foreach($this->constants as$constantName =>$reflection){if(isset($constants[$constantName])){throw new RuntimeException(sprintf('Constant %s was defined multiple times',$constantName));}}$this->constants=array_merge($this->constants,$constants);}public function __toString(){return '';}public static function export($argument,$return=false){return ReflectionBase::export($argument,$return);}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}}
 namespace TokenReflection;use RuntimeException,TokenReflection\Exception;class ReflectionParameter extends ReflectionBase implements IReflectionParameter{CONST ARRAY_CONSTRAINT='array';private static$parseValueDefinitions=false;private$valueConstraint;private$originalValueConstraint;private$defaultValueDefinition;private$defaultValue;private$declaringClassName;private$declaringFunctionName;private$passedByReference=false;private$isOptional;private$position;public function allowsNull(){return true;}public function getClass(){$name=$this->getClassName();if(null ===$name){return null;}return$this->getBroker()->getClass($name);}public function getClassName(){if($this->isArray()){return null;}if(null ===$this->valueConstraint &&null !==$this->originalValueConstraint){if(null !==$this->declaringClassName){$parent=$this->getDeclaringClass();if(null ===$parent ||!$parent->isTokenized()){throw new Exception(sprintf('Could not load class %s reflection',$this->declaringClassName));}}else{$parent=$this->getDeclaringFunction();if(null ===$parent ||!$parent->isTokenized()){throw new Exception(sprintf('Could not load function %s reflection',$this->declaringFunctionName));}}$this->valueConstraint=self::resolveClassFQN($this->originalValueConstraint,$parent->getNamespaceAliases(),$parent->getNamespaceName());}return$this->valueConstraint;}public function getOriginalClassName(){return!$this->isArray()?ltrim($this->originalValueConstraint,'\\'):null;}public function getDeclaringClass(){return null ===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getDeclaringFunction(){if(null !==$this->declaringClassName){$class=$this->getBroker()->getClass($this->declaringClassName);if(null !==$class){return$class->getMethod($this->declaringFunctionName);}}else{return$this->getBroker()->getFunction($this->declaringFunctionName);}}public function getDeclaringFunctionName(){return$this->declaringFunctionName;}public function getDefaultValue(){if(null ===$this->defaultValueDefinition){throw new Exception('Property has no default value',Exception::DOES_NOT_EXIST);}return$this->defaultValue;}public function getDefaultValueDefinition(){return$this->defaultValueDefinition;}public function getPosition(){return$this->position;}public function isArray(){return$this->valueConstraint === self::ARRAY_CONSTRAINT;}public function isDefaultValueAvailable(){return null !==$this->defaultValueDefinition;}public function getInheritedDocComment(){return$this->getDocComment();}public function isOptional(){if(null ===$this->isOptional){$function=$this->getDeclaringFunction();if(null ===$function){throw new RuntimeException(sprintf('Could not get the declaring function %s reflection.',$this->declaringFunctionName));}$this->isOptional=true;foreach(array_slice($function->getParameters(),$this->position)as$reflectionParameter){if(!$reflectionParameter->isDefaultValueAvailable()){$this->isOptional=false;break;}}}return$this->isOptional;}public function isPassedByReference(){return$this->passedByReference;}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFunctionBase){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFunctionBase descendant class, %s given.',get_class($parent)));}$this->declaringFunctionName=$parent->getName();$this->position=count($parent->getParameters());if($parent instanceof ReflectionMethod){$this->declaringClassName=$parent->getDeclaringClassName();}return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return$this ->parseConstraint($tokenStream)->parsePassedByReference($tokenStream)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw new RuntimeException('Could not find the parameter variable definition');}$token=$tokenStream->current();$this->name=substr($token[1],1);$tokenStream->skipWhitespaces();return$this;}private function parseConstraint(Stream$tokenStream){$type=$tokenStream->getType();if(T_ARRAY ===$type){$this->valueConstraint=self::ARRAY_CONSTRAINT;$this->originalValueConstraint=self::ARRAY_CONSTRAINT;$tokenStream->skipWhitespaces();}elseif(T_STRING ===$type || T_NS_SEPARATOR ===$type){$className='';do{$token=$tokenStream->current();$className .=$token[1];$tokenStream->skipWhitespaces();$type=$tokenStream->getType();}while(T_STRING ===$type || T_NS_SEPARATOR ===$type);if('' === ltrim($className,'\\')){throw new RuntimeException('Invalid value constraint definition');}$this->originalValueConstraint=$className;}return$this;}private function parsePassedByReference(Stream$tokenStream){if($tokenStream->is('&')){$this->passedByReference=true;$tokenStream->skipWhitespaces();}return$this;}private function parseDefaultValue(Stream$tokenStream){if($tokenStream->is('=')){$tokenStream->skipWhitespaces();$this->defaultValueDefinition=Stream::tokensToCode(array_slice($tokenStream->getArrayCopy(),$tokenStream->key()));if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}}return$this;}public static function setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public static function getParseValueDefinitions(){return self::$parseValueDefinitions;}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionFunction,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionFunction as InternalReflectionFunction,ReflectionParameter as InternalReflectionParameter;use RuntimeException;class ReflectionFunction extends InternalReflectionFunction implements IReflection,IReflectionFunction{private$broker;private$parameters;public function __construct($functionName,Broker$broker){parent::__construct($functionName);$this->broker=$broker;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getExtension(){return ReflectionExtension::create(parent::getExtension(),$this->broker);}public function getParameters(){if(null ===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public function getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getInheritedDocComment(){return$this->getDocComment();}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){if(!$internalReflection instanceof InternalReflectionFunction){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionFunction expected.',get_class($internalReflection)));}return$broker->getFunction($internalReflection->getName());}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionMethod,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionMethod as InternalReflectionMethod,ReflectionParameter as InternalReflectionParameter;use RuntimeException;class ReflectionMethod extends InternalReflectionMethod implements IReflection,IReflectionMethod{private$broker;private$parameters;public function __construct($class,$methodName,Broker$broker){parent::__construct($class,$methodName);$this->broker=$broker;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getParameters(){if(null ===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if($parent &&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return false;}public function getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getDeclaringClass(){return ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public function getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public function getClass(){return$this->getDeclaringClassName();}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function getPrototype(){return self::create(parent::getPrototype(),$this->broker);}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection instanceof InternalReflectionMethod){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionMethod expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}
 namespace TokenReflection;use RuntimeException;class ReflectionFunction extends ReflectionFunctionBase implements IReflectionFunction{private$aliases=array();public function isDisabled(){return$this->hasAnnotation('disabled');}public function getInheritedDocComment(){return$this->getDocComment();}public function invoke(){return$this->invokeArgs(func_get_args());}public function invokeArgs(array$args=array()){if(!function_exists($this->getName())){throw new RuntimeException('Function %s is not defined in the current scope.',$this->getName());}return call_user_func_array($this->getName(),$args);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseReturnsReference($tokenStream)->parseName($tokenStream);}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFileNamespace){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return parent::processParent($parent);}public function getNamespaceAliases(){return$this->aliases;}}
 namespace TokenReflection;use ReflectionMethod as InternalReflectionMethod,ReflectionClass as InternalReflectionClass;use RuntimeException,InvalidArgumentException;class ReflectionMethod extends ReflectionFunctionBase implements IReflectionMethod{const IS_IMPLEMENTED_ABSTRACT=0x08;const ACCESS_LEVEL_CHANGED=0x800;const IS_CONSTRUCTOR=0x2000;const IS_DESTRUCTOR=0x4000;const IS_CLONE=0x8000;const IS_ALLOWED_STATIC=0x10000;private$declaringClassName;private$accessible=false;public function getDeclaringClass(){return null ===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getClass(){return$this->getDeclaringClassName();}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())&&false === strpos($docComment,'@inheritdoc')){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null !==$parent &&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return false;}public function getModifiers(){if(!($this->modifiers&(self::ACCESS_LEVEL_CHANGED|self::IS_IMPLEMENTED_ABSTRACT))){$declaringClass=$this->getDeclaringClass();if(null ===$declaringClass){throw new RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null !==$parentClass){$parentClassMethods=$parentClass->getMethods();if($this->modifiers&InternalReflectionMethod::IS_PUBLIC){if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::ACCESS_LEVEL_CHANGED|InternalReflectionMethod::IS_PRIVATE))){$this->modifiers |= self::ACCESS_LEVEL_CHANGED;}}if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::IS_IMPLEMENTED_ABSTRACT|InternalReflectionMethod::IS_ABSTRACT))){$this->modifiers |= self::IS_IMPLEMENTED_ABSTRACT;}}}return$this->modifiers;}public function invoke($object,$args){$params=func_get_args();return$this->invokeArgs(array_shift($params),$params);}public function invokeArgs($object,array$args=array()){$declaringClass=$this->getDeclaringClass();if(!$declaringClass->isInstance($object)){throw new InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return call_user_func_array(array($object,$this->getName()),$args);}elseif($this->isAccessible()){$refClass=new InternalReflectionClass($object);$refMethod=$refClass->getMethod($this->name);$refMethod->setAccessible(true);$value=$refMethod->invokeArgs($object,$args);$refMethod->setAccessible(false);return$value;}throw new RuntimeException('Only public methods can be invoked.');}public function isAbstract(){return (bool)($this->modifiers&InternalReflectionMethod::IS_ABSTRACT);}public function isConstructor(){return (bool)($this->modifiers&self::IS_CONSTRUCTOR);}public function isDestructor(){return (bool)($this->modifiers&self::IS_DESTRUCTOR);}public function isFinal(){return (bool)($this->modifiers&InternalReflectionMethod::IS_FINAL);}public function isPrivate(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PRIVATE);}public function isProtected(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PROTECTED);}public function isPublic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PUBLIC);}public function isStatic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_STATIC);}public function setAccessible($accessible){$this->accessible=$accessible;}public function isAccessible(){return$this->accessible;}public function getPrototype(){$declaring=$this->getDeclaringClass();if($declaring->getParentClassName()){foreach($declaring->getParentClass()->getMethods()as$method){if($method->getName()===$this->name &&!$method->isPrivate()){return$method;}}}foreach($declaring->getInterfaces()as$interface){if($interface->hasMethod($this->name)){return$interface->getMethod($this->name);}}throw new Exception('Method has no prototype',Exception::DOES_NOT_EXIST);}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionClass){throw new RuntimeException('The parent object has to be either an instance of TokenReflection\ReflectionClass or NULL, %s given.',get_class($parent));}$this->declaringClassName=$parent->getName();return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseBaseModifiers($tokenStream)->parseReturnsReference($tokenStream)->parseName($tokenStream)->parseInternalModifiers($parent);}private function parseBaseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case T_ABSTRACT:$this->modifiers |= InternalReflectionMethod::IS_ABSTRACT;break;case T_FINAL:$this->modifiers |= InternalReflectionMethod::IS_FINAL;break;case T_PUBLIC:$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;break;case T_PRIVATE:$this->modifiers |= InternalReflectionMethod::IS_PRIVATE;break;case T_PROTECTED:$this->modifiers |= InternalReflectionMethod::IS_PROTECTED;break;case T_STATIC:$this->modifiers |= InternalReflectionMethod::IS_STATIC;break;case T_FUNCTION:case null:break 2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&InternalReflectionMethod::IS_PRIVATE)&&!($this->modifiers&InternalReflectionMethod::IS_PROTECTED)){$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;}return$this;}private function parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct' ===$name ||($class &&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers |= self::IS_CONSTRUCTOR;}elseif('__destruct' ===$name){$this->modifiers |= self::IS_DESTRUCTOR;}elseif('__clone' ===$name){$this->modifiers |= self::IS_CLONE;}if(!$this->isConstructor()&&!$this->isDestructor()&&!in_array($name,array('__clone','__tostring','__get','__set','__isset','__unset'),true)){$this->modifiers |= self::IS_ALLOWED_STATIC;}return$this;}}||||||||function
parseInterfaces(Stream$tokenStream,ReflectionBase$parent=null){if(!$tokenStream->is(T_IMPLEMENTS)){return$this;}while(true){$interfaceName='';$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case
T_STRING:case
T_NS_SEPARATOR:$interfaceName
.=$tokenStream->getTokenValue();break;default:break
2;}$tokenStream->skipWhitespaces();}$this->interfaces[]=self::resolveClassFQN($interfaceName,$this->aliases,$this->namespaceName);$type=$tokenStream->getType();if('{'
===$type){break;}elseif(','
!==$type){throw
new
RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}return$this;}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionConstant
extends
ReflectionBase
implements
IReflectionConstant{private$declaringClassName;private$namespaceName;private$value;private$valueDefinition='';protected
function
processParent(IReflection$parent){if($parent
instanceof
ReflectionFileNamespace){$this->namespaceName=$parent->getName();}elseif($parent
instanceof
ReflectionClass){$this->declaringClassName=$parent->getName();}else{throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace or TokenReflection\ReflectionClass, %s given.',get_class($parent)));}return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseName($tokenStream)->parseValue($tokenStream,$parent);}protected
function
parseName(Stream$tokenStream){if($tokenStream->is(T_CONST)){$tokenStream->skipWhitespaces();}if(!$tokenStream->is(T_STRING)){throw
new
RuntimeException('Could not determine the constant name');}if(null
===$this->namespaceName
||$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME){$this->name=$tokenStream->getTokenValue();}else{$this->name=$this->namespaceName.'\\'.$tokenStream->getTokenValue();}$tokenStream->skipWhitespaces();return$this;}protected
function
parseDocComment(Stream$tokenStream){static$skipped=array(T_WHITESPACE,T_COMMENT,T_CONST);$position=$tokenStream->key()-1;while($position>0
&&in_array($tokenStream->getType($position),$skipped)){$position--;}if($tokenStream->is(T_DOC_COMMENT,$position)){$this->docComment=$tokenStream->getTokenValue($position);}else{$this->docComment=false;}return$this;}private
function
parseValue(Stream$tokenStream,IReflection$parent){if(!$tokenStream->is('=')){throw
new
RuntimeException('Could not find the value definition start');}$tokenStream->skipWhitespaces();static$acceptedStrings,$acceptedTokens;if(null
===$acceptedStrings){$acceptedStrings=array_flip(array('true','false','null'));$acceptedTokens=array_flip(array('-','+',T_STRING,T_CONSTANT_ENCAPSED_STRING,T_DNUMBER,T_LNUMBER,T_DOUBLE_COLON));}$evalValue=true;while(null
!==($type=$tokenStream->getType())){$value=$tokenStream->getTokenValue();if(!isset($acceptedTokens[$type])){break;}elseif($tokenStream->is(T_STRING)&&!isset($acceptedStrings[strtolower($value)])){$evalValue=false;}$this->valueDefinition
.=$value;$tokenStream->next();}if(null
!==$type
&&(','
===$value
||
';'
===$value)){$this->valueDefinition=trim($this->valueDefinition);}else{throw
new
RuntimeException(sprintf('Invalid value definition: "%s".',$this->valueDefinition));}if($evalValue){$this->value=eval(sprintf('return %s;',$this->valueDefinition));}else{if('\\'
!==$this->valueDefinition{0}){$namespaceName=$this->namespaceName?:$parent->getNamespaceName();if($pos=strpos($this->valueDefinition,'::')){$className=substr($this->valueDefinition,0,$pos);$this->valueDefinition=ReflectionBase::resolveClassFQN($className,$parent->getNamespaceAliases(),$namespaceName).substr($this->valueDefinition,$pos);}elseif(ReflectionNamespace::NO_NAMESPACE_NAME
!==$namespaceName){$this->valueDefinition=$namespaceName.'\\'.$this->valueDefinition;}}}return$this;}public
function
getValueDefinition(){return$this->valueDefinition;}public
function
getValue(){if(null
===$this->value
&&'null'
!==
strtolower($this->valueDefinition)){if($position=strpos($this->valueDefinition,'::')){$className=substr($this->valueDefinition,0,$position);$constantName=substr($this->valueDefinition,$position+2);$this->value=$this->getBroker()->getClass($className)->getConstant($constantName);}else{$constant=$this->getBroker()->getConstant($this->valueDefinition);$this->value=$constant?$constant->getValue():null;}}return$this->value;}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getDeclaringClass(){if(null
===$this->declaringClassName){return
null;}return$this->getBroker()->getClass($this->declaringClassName);}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getNamespaceName(){return$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public
function
inNamespace(){return
null
!==$this->getNamespaceName();}public
function
getShortName(){$name=$this->getName();if(null
!==$this->namespaceName
&&$this->namespaceName
!==
ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionFileNamespace
extends
ReflectionBase{private$aliases=array();private$classes=array();private$functions=array();private$constants=array();public
function
getClasses(){return$this->classes;}public
function
getFunctions(){return$this->functions;}public
function
getConstants(){return$this->constants;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getAliases(){return$this->aliases;}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFile){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFile, %s given.',get_class($parent)));}return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseName($tokenStream)->parseAliases($tokenStream);}protected
function
parseChildren(Stream$tokenStream,IReflection$parent){static$skipped;if(null
===$skipped){$skipped=array_flip(array(T_WHITESPACE,T_COMMENT,T_DOC_COMMENT));}$level=1;while(true){switch($tokenStream->getType()){case
'{':$level++;$tokenStream->skipWhitespaces();break;case
'}':$level--;$tokenStream->skipWhitespaces();break$level>0?1:2;case
null:case
T_NAMESPACE:break
2;case
T_ABSTRACT:case
T_FINAL:case
T_CLASS:case
T_INTERFACE:$class=new
ReflectionClass($tokenStream,$this->getBroker(),$this);$this->classes[$class->getName()]=$class;break;case
T_CONST:$tokenStream->skipWhitespaces();while($tokenStream->is(T_STRING)){$constant=new
ReflectionConstant($tokenStream,$this->getBroker(),$this);$this->constants[$constant->getName()]=$constant;$tokenStream->skipWhitespaces();}break;case
T_FUNCTION:$position=$tokenStream->key()+1;while(isset($skipped[$type=$tokenStream->getType($position)])){$position++;}if('('
===$type){$tokenStream
->seek($position)->findMatchingBracket()->skipWhiteSpaces();if($tokenStream->is(T_USE)){$tokenStream
->skipWhitespaces()->findMatchingBracket()->skipWhitespaces();}$tokenStream
->findMatchingBracket()->skipWhitespaces();continue;}$function=new
ReflectionFunction($tokenStream,$this->getBroker(),$this);$this->functions[$function->getName()]=$function;break;default:$tokenStream->skipWhitespaces();}}return$this;}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_NAMESPACE)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;return$this;}$tokenStream->skipWhitespaces();$name='';while(true){switch($tokenStream->getType()){case
T_STRING:case
T_NS_SEPARATOR:$name
.=$tokenStream->getTokenValue();break;default:
break
2;}$tokenStream->next();}$name=ltrim($name,'\\');if(empty($name)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;}else{$this->name=$name;$tokenStream->skipWhitespaces();}return$this;}private
function
parseAliases(Stream$tokenStream){if(ReflectionNamespace::NO_NAMESPACE_NAME
===$this->name){return$this;}$aliases=array();while(true){if($tokenStream->is(T_USE)){while(true){$namespaceName='';$alias=null;$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case
T_STRING:case
T_NS_SEPARATOR:$namespaceName
.=$tokenStream->getTokenValue();break;default:break
2;}$tokenStream->next();}$namespaceName=ltrim($namespaceName,'\\');if(empty($namespaceName)){throw
new
RuntimeException('Imported namespace name could not be determined');}elseif('\\'
===
substr($namespaceName,-1)){throw
new
RuntimeException(sprintf('Invalid namespace name "%s"',$namespaceName));}$tokenStream->skipWhitespaces(false);if($tokenStream->is(T_AS)){$tokenStream->skipWhitespaces();if(!$tokenStream->is(T_STRING)){throw
new
RuntimeException(sprintf('The imported namespace "%s" seems aliased but the alias name could not be determined',$namespaceName));}$alias=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();}else{if(false
!==($pos=strrpos($namespaceName,'\\'))){$alias=substr($namespaceName,$pos+1);}else{$alias=$namespaceName;}}if(isset($aliases[$alias])){throw
new
RuntimeException(sprintf('Namespace alias "%s" already defined',$alias));}$aliases[$alias]=$namespaceName;$type=$tokenStream->getType();if(';'
===$type){$tokenStream->skipWhitespaces();continue
2;}elseif(','
===$type){continue;}throw
new
RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}else{break;}}$this->aliases=$aliases;return$this;}}}

namespace
TokenReflection{use
RuntimeException;abstract
class
ReflectionFunctionBase
extends
ReflectionBase
implements
IReflectionFunctionBase{protected$modifiers=0;private$staticVariables=array();protected$namespaceName;private$returnsReference=false;private$parameters=array();public
function
getModifiers(){return$this->modifiers;}public
function
inNamespace(){return
null
!==$this->getNamespaceName();}public
function
getNamespaceName(){return$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public
function
getNumberOfParameters(){return
count($this->parameters);}public
function
getNumberOfRequiredParameters(){$count=0;array_walk($this->parameters,function(ReflectionParameter$parameter)use(&$count){if(!$parameter->isOptional()){$count++;}});return$count;}public
function
getParameters(){return$this->parameters;}public
function
getParameter($parameter){if(is_numeric($parameter)){if(isset($this->parameters[$parameter])){return$this->parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($this->parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getStaticVariables(){return$this->staticVariables;}public
function
isClosure(){return
false;}public
function
returnsReference(){return$this->returnsReference;}public
function
getName(){if(null
!==$this->namespaceName
&&ReflectionNamespace::NO_NAMESPACE_NAME
!==$this->namespaceName){return$this->namespaceName.'\\'.$this->name;}return$this->name;}public
function
getShortName(){return$this->name;}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw
new
RuntimeException('Could not determine the method/function name');}$this->name=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();return$this;}final
protected
function
parseChildren(Stream$tokenStream,IReflection$parent){return$this
->parseParameters($tokenStream)->parseStaticVariables($tokenStream);}final
protected
function
parseParameters(Stream$tokenStream){if(!$tokenStream->is('(')){throw
new
RuntimeException('Could not determine parameters start');}static$accepted;if(null
===$accepted){$accepted=array_flip(array(T_NS_SEPARATOR,T_STRING,T_ARRAY,T_VARIABLE,'&'));}$tokenStream->skipWhitespaces();while(null
!==($type=$tokenStream->getType())&&')'
!==$type){if(isset($accepted[$type])){$parameter=new
ReflectionParameter($tokenStream,$this->getBroker(),$this);$this->parameters[]=$parameter;}if($tokenStream->is(')')){break;}$tokenStream->skipWhitespaces();}$tokenStream->skipWhitespaces();return$this;}final
protected
function
parseStaticVariables(Stream$tokenStream){$type=$tokenStream->getType();if('{'
===$type){$tokenStream->findMatchingBracket()->next();}elseif(';'
===$type){$tokenStream->next();}else{throw
new
RuntimeException(sprintf('Unexpected token found: %s',$type));}return$this;}final
protected
function
parseReturnsReference(Stream$tokenStream){if(!$tokenStream->is(T_FUNCTION)){throw
new
RuntimeException('Could not find the function keyword.');}$tokenStream->skipWhitespaces();$type=$tokenStream->getType();if('&'
===$type){$this->returnsReference=true;$tokenStream->skipWhitespaces();}elseif(T_STRING
!==$type){throw
new
RuntimeException(sprintf('Unexpected token type: %s',$tokenStream->getTokenName()));}return$this;}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionNamespace
implements
IReflectionNamespace{const
NO_NAMESPACE_NAME='no-namespace';private$broker;private$name;private$classes=array();private$functions=array();private$constants=array();public
function
__construct($name,Broker$broker){$this->name=$name;$this->broker=$broker;}public
function
getClass($className){$className=ltrim($className,'\\');if(false
===
strpos($className,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$className=$this->getName().'\\'.$className;}if(!isset($this->classes[$className])){throw
new
Exception(sprintf('Class %s does not exist',$className),Exception::DOES_NOT_EXIST);}return$this->classes[$className];}public
function
getClasses(){return$this->classes;}public
function
getClassNames(){return
array_keys($this->classes);}public
function
getClassShortNames(){return
array_map(function(IReflectionClass$class){return$class->getShortName();},$this->classes);}public
function
getFunction($functionName){$functionName=ltrim($functionName,'\\');if(false
===
strpos($functionName,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$functionName=$this->getName().'\\'.$functionName;}if(!isset($this->functions[$functionName])){throw
new
Exception(sprintf('Function %s does not exist',$functionName),Exception::DOES_NOT_EXIST);}return$this->functions[$functionName];}public
function
getFunctions(){return$this->functions;}public
function
getFunctionNames(){return
array_keys($this->functions);}public
function
getFunctionShortNames(){return
array_map(function(IReflectionFunction$function){return$function->getShortName();},$this->functions);}public
function
getConstant($constantName){$constantName=ltrim($constantName,'\\');if(false
===
strpos($constantName,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$constantName=$this->getName().'\\'.$constantName;}if(!isset($this->constants[$constantName])){throw
new
Exception(sprintf('Constant %s does not exist',$constantName),Exception::DOES_NOT_EXIST);}return$this->constants[$constantName];}public
function
getConstants(){return$this->constants;}public
function
getConstantNames(){return
array_keys($this->constants);}public
function
getConstantShortNames(){return
array_map(function(IReflectionConstant$constant){return$constant->getShortName();},$this->constants);}public
function
getName(){return$this->name;}public
function
getBroker(){return$this->broker;}public
function
isTokenized(){return
true;}public
function
isInternal(){return
false;}public
function
isUserDefined(){return
true;}public
function
addFileNamespace(ReflectionFileNamespace$namespace){$classes=$namespace->getClasses();foreach($this->classes
as$className
=>$reflection){if(isset($classes[$className])){throw
new
RuntimeException(sprintf('Class %s was defined multiple times',$className));}}$this->classes=array_merge($this->classes,$classes);$functions=$namespace->getFunctions();foreach($this->functions
as$functionName
=>$reflection){if(isset($functions[$functionName])){throw
new
RuntimeException(sprintf('Function %s was defined multiple times',$functionName));}}$this->functions=array_merge($this->functions,$functions);$constants=$namespace->getConstants();foreach($this->constants
as$constantName
=>$reflection){if(isset($constants[$constantName])){throw
new
RuntimeException(sprintf('Constant %s was defined multiple times',$constantName));}}$this->constants=array_merge($this->constants,$constants);}public
function
__toString(){return
'';}public
static
function
export($argument,$return=false){return
ReflectionBase::export($argument,$return);}final
public
function
__get($key){return
ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
ReflectionBase::exists($this,$key);}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionParameter
extends
ReflectionBase
implements
IReflectionParameter{CONST
ARRAY_CONSTRAINT='array';private
static$parseValueDefinitions=false;private$valueConstraint;private$originalValueConstraint;private$defaultValueDefinition;private$defaultValue;private$declaringClassName;private$declaringFunctionName;private$passedByReference=false;private$isOptional;private$position;public
function
allowsNull(){return
true;}public
function
getClass(){$name=$this->getClassName();if(null
===$name){return
null;}return$this->getBroker()->getClass($name);}public
function
getClassName(){if($this->isArray()){return
null;}if(null
===$this->valueConstraint
&&null
!==$this->originalValueConstraint){if(null
!==$this->declaringClassName){$parent=$this->getDeclaringClass();if(null
===$parent
||!$parent->isTokenized()){throw
new
Exception(sprintf('Could not load class %s reflection',$this->declaringClassName));}}else{$parent=$this->getDeclaringFunction();if(null
===$parent
||!$parent->isTokenized()){throw
new
Exception(sprintf('Could not load function %s reflection',$this->declaringFunctionName));}}$this->valueConstraint=self::resolveClassFQN($this->originalValueConstraint,$parent->getNamespaceAliases(),$parent->getNamespaceName());}return$this->valueConstraint;}public
function
getOriginalClassName(){return!$this->isArray()?ltrim($this->originalValueConstraint,'\\'):null;}public
function
getDeclaringClass(){return
null
===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getDeclaringFunction(){if(null
!==$this->declaringClassName){$class=$this->getBroker()->getClass($this->declaringClassName);if(null
!==$class){return$class->getMethod($this->declaringFunctionName);}}else{return$this->getBroker()->getFunction($this->declaringFunctionName);}}public
function
getDeclaringFunctionName(){return$this->declaringFunctionName;}public
function
getDefaultValue(){if(null
===$this->defaultValueDefinition){throw
new
Exception('Property has no default value',Exception::DOES_NOT_EXIST);}return$this->defaultValue;}public
function
getDefaultValueDefinition(){return$this->defaultValueDefinition;}public
function
getPosition(){return$this->position;}public
function
isArray(){return$this->valueConstraint
===
self::ARRAY_CONSTRAINT;}public
function
isDefaultValueAvailable(){return
null
!==$this->defaultValueDefinition;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
isOptional(){if(null
===$this->isOptional){$function=$this->getDeclaringFunction();if(null
===$function){throw
new
RuntimeException(sprintf('Could not get the declaring function %s reflection.',$this->declaringFunctionName));}$this->isOptional=true;foreach(array_slice($function->getParameters(),$this->position)as$reflectionParameter){if(!$reflectionParameter->isDefaultValueAvailable()){$this->isOptional=false;break;}}}return$this->isOptional;}public
function
isPassedByReference(){return$this->passedByReference;}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFunctionBase){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFunctionBase descendant class, %s given.',get_class($parent)));}$this->declaringFunctionName=$parent->getName();$this->position=count($parent->getParameters());if($parent
instanceof
ReflectionMethod){$this->declaringClassName=$parent->getDeclaringClassName();}return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseConstraint($tokenStream)->parsePassedByReference($tokenStream)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw
new
RuntimeException('Could not find the parameter variable definition');}$this->name=substr($tokenStream->getTokenValue(),1);$tokenStream->skipWhitespaces();return$this;}private
function
parseConstraint(Stream$tokenStream){$type=$tokenStream->getType();if(T_ARRAY
===$type){$this->valueConstraint=self::ARRAY_CONSTRAINT;$this->originalValueConstraint=self::ARRAY_CONSTRAINT;$tokenStream->skipWhitespaces();}elseif(T_STRING
===$type
||
T_NS_SEPARATOR
===$type){$className='';do{$className
.=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();$type=$tokenStream->getType();}while(T_STRING
===$type
||
T_NS_SEPARATOR
===$type);if(''
===
ltrim($className,'\\')){throw
new
RuntimeException('Invalid value constraint definition');}$this->originalValueConstraint=$className;}return$this;}private
function
parsePassedByReference(Stream$tokenStream){if($tokenStream->is('&')){$this->passedByReference=true;$tokenStream->skipWhitespaces();}return$this;}private
function
parseDefaultValue(Stream$tokenStream){if($tokenStream->is('=')){$tokenStream->skipWhitespaces();$level=0;while(null
!==($type=$tokenStream->getType())){switch($type){case
')':if(0
===$level){break
2;}case
'}':case
']':$level--;break;case
'(':case
'{':case
'[':$level++;break;case
',':if(0
===$level){break
2;}}$this->defaultValueDefinition
.=$tokenStream->getTokenValue();$tokenStream->next();}if(','
===$type){$tokenStream->next();}elseif(')'
!==$type){throw
new
RuntimeException('Parameter default value definition is not terminated properly');}if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}}return$this;}public
static
function
setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public
static
function
getParseValueDefinitions(){return
self::$parseValueDefinitions;}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionFunction
as
InternalReflectionFunction,ReflectionParameter
as
InternalReflectionParameter;use
RuntimeException;class
ReflectionFunction
extends
InternalReflectionFunction
implements
IReflection,TokenReflection\IReflectionFunction{private$broker;private$parameters;public
function
__construct($functionName,Broker$broker){parent::__construct($functionName);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getExtension(){return
ReflectionExtension::create(parent::getExtension(),$this->broker);}public
function
getParameters(){if(null
===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return
ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public
function
getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
isTokenized(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){if(!$internalReflection
instanceof
InternalReflectionFunction){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionFunction expected.',get_class($internalReflection)));}return$broker->getFunction($internalReflection->getName());}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionMethod
as
InternalReflectionMethod,ReflectionParameter
as
InternalReflectionParameter;use
RuntimeException;class
ReflectionMethod
extends
InternalReflectionMethod
implements
IReflection,TokenReflection\IReflectionMethod{private$broker;private$parameters;public
function
__construct($class,$methodName,Broker$broker){parent::__construct($class,$methodName);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getParameters(){if(null
===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return
ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if($parent
&&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return
false;}public
function
getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getDeclaringClass(){return
ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public
function
getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
getPrototype(){return
self::create(parent::getPrototype(),$this->broker);}public
function
isTokenized(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection
instanceof
InternalReflectionMethod){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionMethod expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new
self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionFunction
extends
ReflectionFunctionBase
implements
IReflectionFunction{private$aliases=array();public
function
isDisabled(){return$this->hasAnnotation('disabled');}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
invoke(){return$this->invokeArgs(func_get_args());}public
function
invokeArgs(array$args=array()){if(!function_exists($this->getName())){throw
new
RuntimeException('Function %s is not defined in the current scope.',$this->getName());}return
call_user_func_array($this->getName(),$args);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseReturnsReference($tokenStream)->parseName($tokenStream);}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFileNamespace){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return
parent::processParent($parent);}public
function
getNamespaceAliases(){return$this->aliases;}}}

namespace
TokenReflection{use
ReflectionMethod
as
InternalReflectionMethod,ReflectionClass
as
InternalReflectionClass;use
RuntimeException,InvalidArgumentException;class
ReflectionMethod
extends
ReflectionFunctionBase
implements
IReflectionMethod{const
IS_IMPLEMENTED_ABSTRACT=0x08;const
ACCESS_LEVEL_CHANGED=0x800;const
IS_CONSTRUCTOR=0x2000;const
IS_DESTRUCTOR=0x4000;const
IS_CLONE=0x8000;const
IS_ALLOWED_STATIC=0x10000;private$declaringClassName;private$accessible=false;public
function
getDeclaringClass(){return
null
===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())&&false
===
strpos($docComment,'@inheritdoc')){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null
!==$parent
&&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return
false;}public
function
getModifiers(){if(!($this->modifiers&(self::ACCESS_LEVEL_CHANGED|self::IS_IMPLEMENTED_ABSTRACT))){$declaringClass=$this->getDeclaringClass();if(null
===$declaringClass){throw
new
RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null
!==$parentClass){$parentClassMethods=$parentClass->getMethods();if($this->modifiers&InternalReflectionMethod::IS_PUBLIC){if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::ACCESS_LEVEL_CHANGED|InternalReflectionMethod::IS_PRIVATE))){$this->modifiers
|=
self::ACCESS_LEVEL_CHANGED;}}if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::IS_IMPLEMENTED_ABSTRACT|InternalReflectionMethod::IS_ABSTRACT))){$this->modifiers
|=
self::IS_IMPLEMENTED_ABSTRACT;}}}return$this->modifiers;}public
function
invoke($object,$args){$params=func_get_args();return$this->invokeArgs(array_shift($params),$params);}public
function
invokeArgs($object,array$args=array()){$declaringClass=$this->getDeclaringClass();if(!$declaringClass->isInstance($object)){throw
new
InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return
call_user_func_array(array($object,$this->getName()),$args);}elseif($this->isAccessible()){$refClass=new
InternalReflectionClass($object);$refMethod=$refClass->getMethod($this->name);$refMethod->setAccessible(true);$value=$refMethod->invokeArgs($object,$args);$refMethod->setAccessible(false);return$value;}throw
new
RuntimeException('Only public methods can be invoked.');}public
function
isAbstract(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_ABSTRACT);}public
function
isConstructor(){return
(bool)($this->modifiers&self::IS_CONSTRUCTOR);}public
function
isDestructor(){return
(bool)($this->modifiers&self::IS_DESTRUCTOR);}public
function
isFinal(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_FINAL);}public
function
isPrivate(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PRIVATE);}public
function
isProtected(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PROTECTED);}public
function
isPublic(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PUBLIC);}public
function
isStatic(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_STATIC);}public
function
setAccessible($accessible){$this->accessible=$accessible;}public
function
isAccessible(){return$this->accessible;}public
function
getPrototype(){$declaring=$this->getDeclaringClass();if($declaring->getParentClassName()){foreach($declaring->getParentClass()->getMethods()as$method){if($method->getName()===$this->name
&&!$method->isPrivate()){return$method;}}}foreach($declaring->getInterfaces()as$interface){if($interface->hasMethod($this->name)){return$interface->getMethod($this->name);}}throw
new
Exception('Method has no prototype',Exception::DOES_NOT_EXIST);}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionClass){throw
new
RuntimeException('The parent object has to be either an instance of TokenReflection\ReflectionClass or NULL, %s given.',get_class($parent));}$this->declaringClassName=$parent->getName();return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseBaseModifiers($tokenStream)->parseReturnsReference($tokenStream)->parseName($tokenStream)->parseInternalModifiers($parent);}private
function
parseBaseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case
T_ABSTRACT:$this->modifiers
|=
InternalReflectionMethod::IS_ABSTRACT;break;case
T_FINAL:$this->modifiers
|=
InternalReflectionMethod::IS_FINAL;break;case
T_PUBLIC:$this->modifiers
|=
InternalReflectionMethod::IS_PUBLIC;break;case
T_PRIVATE:$this->modifiers
|=
InternalReflectionMethod::IS_PRIVATE;break;case
T_PROTECTED:$this->modifiers
|=
InternalReflectionMethod::IS_PROTECTED;break;case
T_STATIC:$this->modifiers
|=
InternalReflectionMethod::IS_STATIC;break;case
T_FUNCTION:case
null:break
2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&(InternalReflectionMethod::IS_PRIVATE|InternalReflectionMethod::IS_PROTECTED))){$this->modifiers
|=
InternalReflectionMethod::IS_PUBLIC;}return$this;}private
function
parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct'
===$name
||($class
&&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers
|=
self::IS_CONSTRUCTOR;}elseif('__destruct'
===$name){$this->modifiers
|=
self::IS_DESTRUCTOR;}elseif('__clone'
===$name){$this->modifiers
|=
self::IS_CLONE;}static$notAllowed;if(null
===$notAllowed){$notAllowed=array_flip(array('__clone','__tostring','__get','__set','__isset','__unset'));}if(!$this->isConstructor()&&!$this->isDestructor()&&!isset($notAllowed[$name])){$this->modifiers
|=
self::IS_ALLOWED_STATIC;}return$this;}}}||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_CONST))))
            (
                (AST_RETURN
                    (AST_VAR)))))
    (AST_WHILE
        (AST_CONST)
        (
            (AST_ASSIGN
                (AST_VAR)
                (SCALAR))
            (AST_METHOD_CALL
                (AST_VAR))
            (AST_WHILE
                (AST_CONST)
                (
                    (AST_SWITCH
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_SWITCH_LIST
                            (AST_SWITCH_CASE
                                (AST_CONST))
                            (AST_SWITCH_CASE
                                (AST_CONST)
                                (
                                    (AST_ASSIGN_OP
                                        (AST_VAR)
                                        (AST_METHOD_CALL
                                            (AST_VAR)))
                                    (AST_BREAK
                                        (NULL))))
                            (AST_SWITCH_CASE
                                (NULL)
                                (
                                    (AST_BREAK
                                        (SCALAR))))))
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (NULL))
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_PROP
                            (AST_VAR))
                        (AST_PROP
                            (AST_VAR)))))
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_CONST)))
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_VAR))
                    (
                        (AST_BREAK
                            (NULL))))
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_VAR))
                    (
                        (AST_THROW
                            (AST_NEW
                                (
                                    (AST_CALL
                                        (
                                            (SCALAR)
                                            (AST_METHOD_CALL
                                                (AST_VAR))))))))))))
    (AST_RETURN
        (AST_VAR)))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (AST_CONST))))
            (
                (AST_RETURN
                    (AST_VAR)))))
    (AST_WHILE
        (AST_CONST)
        (
            (AST_ASSIGN
                (AST_VAR)
                (SCALAR))
            (AST_METHOD_CALL
                (AST_VAR))
            (AST_WHILE
                (AST_CONST)
                (
                    (AST_SWITCH
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (AST_SWITCH_LIST
                            (AST_SWITCH_CASE
                                (AST_CONST))
                            (AST_SWITCH_CASE
                                (AST_CONST)
                                (
                                    (AST_ASSIGN_OP
                                        (AST_VAR)
                                        (AST_METHOD_CALL
                                            (AST_VAR)))
                                    (AST_BREAK
                                        (NULL))))
                            (AST_SWITCH_CASE
                                (NULL)
                                (
                                    (AST_BREAK
                                        (SCALAR))))))
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (AST_ASSIGN
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (NULL))
                (AST_STATIC_CALL
                    (
                        (AST_VAR)
                        (AST_PROP
                            (AST_VAR))
                        (AST_PROP
                            (AST_VAR)))))
            (AST_ASSIGN
                (AST_VAR)
                (AST_METHOD_CALL
                    (AST_VAR)))
            (AST_IF
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_VAR))
                    (
                        (AST_BREAK
                            (NULL))))
                (AST_IF_ELEM
                    (AST_BINARY_OP
                        (SCALAR)
                        (AST_VAR))
                    (
                        (AST_THROW
                            (AST_NEW
                                (
                                    (AST_CALL
                                        (
                                            (SCALAR)
                                            (AST_METHOD_CALL
                                                (AST_VAR))))))))))))
    (AST_RETURN
        (AST_VAR)))