 namespace TokenReflection;use ArrayIterator;use InvalidArgumentException,RuntimeException;class Stream extends ArrayIterator{private$filename='unknown';public function __construct(array$stream,$filename){parent::__construct($stream);$this->filename=$filename;}public function getTokenValue(){$token=$this->current();return$token[1];}public function offsetUnset($offset){throw new Exception('Removing of tokens from the stream is not supported.',Exception::UNSUPPORTED);}public function offsetSet($offset,$value){throw new Exception('Setting token values is not supported.',Exception::UNSUPPORTED);}public function getFileName(){return$this->filename;}public function getClassStream(){$type=$this->getType();if(T_CLASS !==$type &&T_INTERFACE !==$type){throw new InvalidArgumentException(sprintf('There is no T_CLASS nor T_INTERFACE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}static$prefixes=array(T_COMMENT,T_WHITESPACE,T_ABSTRACT,T_FINAL,);$start=$this->key();while(in_array($this->getType($start-1),$prefixes,true)){$start--;}$start=$this->findPrecedingDocComment($ex=$start);if($ex ===$start){while($this->is(T_WHITESPACE,$start)){$start++;}}$this->next();while(null !==($type=$this->getType())&&'{' !==$type){$this->skipWhitespaces();}if('{' !==$type){throw new RuntimeException(sprintf('Could not find the beginning of the class/interface with keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$this->findMatchingBracket();return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getNamespaceStream(){if(!$this->is(T_NAMESPACE)){throw new InvalidArgumentException(sprintf('There is no T_NAMESPACE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->findPrecedingDocComment($this->key());while(null !==($type=$this->getType())&&';' !==$type &&'{' !==$type){$this->skipWhitespaces();}if(';' ===$type){while(null !==($key=$this->key())&&(!$this->is(T_NAMESPACE,$key+1)||$this->is(T_NS_SEPARATOR,$key+2))){$this->next();}}elseif('{' ===$type){$this->findMatchingBracket();}else{throw new RuntimeException(sprintf('Could not find the beginning of the namespace with keywords at position [%d] in file [%s]',$end,$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,($this->key()?:count($this)-1)-$start+1),$this->filename);}public function getFunctionStream(){if(!$this->is(T_FUNCTION)){throw new InvalidArgumentException(sprintf('There is no T_FUNCTION keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->findPrecedingDocComment($this->key());$this->next();while(null !==($type=$this->getType())&&';' !==$type &&'{' !==$type){$this->skipWhitespaces();}if('{' ===$type){$this->findMatchingBracket();}elseif(';' !==$type){throw new RuntimeException(sprintf('Could not find the beginning of the function body definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getConstantStream(){if(!$this->is(T_STRING)){throw new InvalidArgumentException(sprintf('There is no T_STRING keyword at position [%d] in file [%s]',$this->key(),$this->filename));}static$prefixes=array(T_COMMENT,T_WHITESPACE,);$start=$this->key();while(in_array($type=$this->getType($start-1),$prefixes,true)){$start--;}if(T_CONST ===$type){$start=$this->findPrecedingDocComment($start-1);}else{$start=$this->key();}while(null !==($type=$this->getType())&&';' !==$type &&',' !==$type){$this->next();}if(';' !==$type &&',' !==$type){throw new RuntimeException(sprintf('Could not find the end of constant definition at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getMethodStream(){if(!$this->is(T_FUNCTION)){throw new InvalidArgumentException(sprintf('There is no T_FUNCTION keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->key();static$acceptedPrevious=array(T_PUBLIC,T_PROTECTED,T_STATIC,T_PRIVATE,T_WHITESPACE,T_COMMENT,T_ABSTRACT,T_FINAL);while(null !==($type=$this->getType($start-1))&&in_array($type,$acceptedPrevious)){$start--;}$start=$this->findPrecedingDocComment($ex=$start);if($start ===$ex){while(null !==($type=$this->getType($start))&&(T_WHITESPACE ===$type || T_COMMENT ===$type)){$start++;}}$this->next();while(null !==($type=$this->getType())&&'{' !==$type &&';' !==$type){$this->next();}if('{' ===$type){$this->findMatchingBracket();}elseif(';' !==$type){throw new RuntimeException(sprintf('Could not find the beginning of the class method body definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getParameterStream(){if(!$this->is(T_VARIABLE)){throw new InvalidArgumentException(sprintf('There is no T_VARIABLE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->key();static$acceptedPrevious=array(T_WHITESPACE,T_COMMENT,T_ARRAY,T_STRING,T_NS_SEPARATOR,'&');while(null !==($type=$this->getType($start-1))&&in_array($type,$acceptedPrevious)){$start--;}while(null !==($type=$this->getType($start))&&T_WHITESPACE ===$type || T_COMMENT ===$type){$start++;}$this->next();while(null !==($type=$this->getType())&&',' !==$type &&')' !==$type){if('(' ===$type){$this->findMatchingBracket();}$this->next();}if(null ===$type){throw new RuntimeException(sprintf('Could not find the end of the parameter definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start),$this->filename);}public function getPropertyStream(){if(!$this->is(T_VARIABLE)){throw new InvalidArgumentException(sprintf('There is no T_VARIABLE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->key();static$acceptedPrevious=array(T_PUBLIC,T_PROTECTED,T_STATIC,T_PRIVATE,T_WHITESPACE,T_COMMENT,T_VAR);while(null !==($type=$this->getType($start-1))&&in_array($type,$acceptedPrevious)){$start--;}$start=$this->findPrecedingDocComment($ex=$start);if($ex ===$start){while(null !==($type=$this->getType($start))&&(T_WHITESPACE ===$type || T_COMMENT ===$type)){$start++;}}$this->next();while(null !==($type=$this->getType())&&';' !==$type &&',' !==$type){if(T_ARRAY ===$type){$this->skipWhitespaces();$this->findMatchingBracket();}else{$this->next();}}if(';' !==$type &&',' !==$type){throw new RuntimeException(sprintf('Could not find the end of the class property definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function findPrecedingDocComment($position){$prev=$this->getType($position-1);if(T_DOC_COMMENT ===$prev){$position--;}elseif(T_WHITESPACE ===$prev &&T_DOC_COMMENT ===$this->getType($position-2)){$position -= 2;}return$position;}public function findMatchingBracket(){static$brackets=array('(' => ')','{' => '}','[' => ']');$position=$this->key();$bracket=$this->getType();if(isset($brackets[$bracket])){$searching=$brackets[$bracket];}else{throw new InvalidArgumentException(sprintf('There is no usable bracket at position [%d] in file [%s]',$this->key(),$this->filename));}$level=0;while(null !==($type=$this->getType())){if($bracket ===$type ||($searching === '}' &&(T_CURLY_OPEN ===$type || T_DOLLAR_OPEN_CURLY_BRACES ===$type))){$level++;}elseif($searching ===$type){$level--;}if(0 ===$level){return$this;}$this->next();}throw new RuntimeException(sprintf('Could not find the matching bracket "%s" of the bracket at position [%d] in file [%s]',$searching,$position,$this->filename));}public function skipWhitespaces($startAtNext=true){if($this->valid()&&$startAtNext){$this->next();}while(true){$type=$this->getType();if($type === T_WHITESPACE ||$type === T_COMMENT){$this->next();continue;}break;}}public function is($type,$position=-1){return$type ===$this->getType($position);}public function getType($position=-1){if(-1 ===$position){$token=$this->current();return$token[0];}else{return isset($this[$position])?$this[$position][0]:null;}}public function getTokenName($position=-1){$type=$this->getType($position);return@token_name($type)?:$type;}public function __toString(){return self::tokensToCode($this->getArrayCopy());}public static function tokensToCode($tokens){if(!is_array($tokens)&&(!is_object($tokens)||!$tokens instanceof Traversable)){throw new InvalidArgumentException('You have to provide an array or an iterateable list of tokens');}$source='';foreach($tokens as$token){$source .=$token[1];}return$source;}}
 namespace TokenReflection\Broker\Backend;use TokenReflection\Broker\Backend as IBackend,TokenReflection\Broker as BrokerParent,TokenReflection\ReflectionFile,TokenReflection\ReflectionNamespace;use TokenReflection\Php\ReflectionFunction as ReflectionPhpFunction,TokenReflection\Php\ReflectionConstant as ReflectionPhpConstant;use TokenReflection\Php\ReflectionClass as ReflectionPhpClass,TokenReflection\Dummy\ReflectionClass as ReflectionDummyClass;use InvalidArgumentException,RuntimeException,TokenReflection\Exception;class Memory implements IBackend{private$namespaces=array();private$allClasses;private$tokenStreams=array();private$broker;private$storingTokenStreams;public function getNamespace($namespaceName){if(!isset($this->namespaces[ReflectionNamespace::NO_NAMESPACE_NAME])){$this->namespaces[ReflectionNamespace::NO_NAMESPACE_NAME]=new ReflectionNamespace(ReflectionNamespace::NO_NAMESPACE_NAME,$this->broker);}$namespaceName=ltrim($namespaceName,'\\');if(!isset($this->namespaces[$namespaceName])){throw new Exception(sprintf('Namespace %s does not exist.',$namespaceName),Exception::DOES_NOT_EXIST);}return$this->namespaces[$namespaceName];}public function getClass($className){static$declared=array();if(empty($declared)){$declared=array_flip(array_merge(get_declared_classes(),get_declared_interfaces()));}$className=ltrim($className,'\\');try{$ns=$this->getNamespace(($boundary=strrpos($className,'\\'))?substr($className,0,$boundary):ReflectionNamespace::NO_NAMESPACE_NAME);return$ns->getClass($className);}catch(Exception$e){if(isset($declared[$className])){$reflection=new ReflectionPhpClass($className,$this->broker);if($reflection->isInternal()){return$reflection;}}return new ReflectionDummyClass($className,$this->broker);}}public function getFunction($functionName){static$declared=array();if(empty($declared)){$functions=get_defined_functions();$declared=array_flip($functions['internal']);}$functionName=ltrim($functionName,'\\');try{$ns=$this->getNamespace(($boundary=strrpos($functionName,'\\'))?substr($functionName,0,$boundary):ReflectionNamespace::NO_NAMESPACE_NAME);return$ns->getFunction($functionName);}catch(Exception$e){return isset($declared[$functionName])?new ReflectionPhpFunction($functionName,$this->broker):null;}}public function getConstant($constantName){static$declared=array();if(empty($declared)){$declared=get_defined_constants();}if($boundary=strpos($constantName,'::')){$className=substr($constantName,0,$boundary);$constantName=substr($constantName,$boundary+2);try{return$this->getClass($className)->getConstantReflection($constantName);}catch(Exception$e){return null;}}try{$constantName=ltrim($constantName,'\\');if($boundary=strrpos($constantName,'\\')){$ns=$this->getNamespace(substr($constantName,0,$boundary));$constantName=substr($constantName,$boundary+1);}else{$ns=$this->getNamespace(ReflectionNamespace::NO_NAMESPACE_NAME);}return$ns->getConstant($constantName);}catch(Exception$e){$reflection=new ReflectionPhpConstant($constantName,$declared[$constantName],$this->broker);return$reflection->isInternal()?$reflection:null;}}public function isFileProcessed($fileName){return isset($this->tokenStreams[$fileName]);}public function getFileTokens($fileName){if(!$this->isFileProcessed($fileName)){throw new InvalidArgumentException(sprintf('File %s was not processed',$fileName));}return$this->tokenStreams[$fileName];}public function addFile(ReflectionFile$file,$storeTokenStream=true){foreach($file->getNamespaces()as$fileNamespace){$namespaceName=$fileNamespace->getName();if(!isset($this->namespaces[$namespaceName])){$this->namespaces[$namespaceName]=new ReflectionNamespace($namespaceName,$file->getBroker());}$this->namespaces[$namespaceName]->addFileNamespace($fileNamespace);}if($this->storingTokenStreams){$this->tokenStreams[$file->getName()]=$file->getTokenStream();}$this->allClasses=null;return$this;}public function setBroker(BrokerParent$broker){$this->broker=$broker;return$this;}public function getBroker(){return$this->broker;}public function setStoringTokenStreams($store){$this->storingTokenStreams=(bool)$store;return$this;}public function getStoringTokenStreams(){return$this->storingTokenStreams;}protected function parseClassLists(){$allClasses=array(IBackend::TOKENIZED_CLASSES => array(),IBackend::INTERNAL_CLASSES => array(),IBackend::NONEXISTENT_CLASSES => array());foreach($this->namespaces as$namespace){foreach($namespace->getClasses()as$class){$allClasses[IBackend::TOKENIZED_CLASSES][$class->getName()]=$class;}}foreach($allClasses[IBackend::TOKENIZED_CLASSES]as$className =>$class){foreach(array_merge($class->getParentClasses(),$class->getInterfaces())as$parent){if($parent->isTokenized()){if(!isset($allClasses[IBackend::TOKENIZED_CLASSES][$parent->getName()])){throw new RuntimeException(sprintf('Class %s should be tokenized',$parent->getName()));}}elseif($parent->isInternal()){$allClasses[IBackend::INTERNAL_CLASSES][$parent->getName()]=$parent;}else{$allClasses[IBackend::NONEXISTENT_CLASSES][$parent->getName()]=$parent;}}}return$allClasses;}public function getClasses($type=IBackend::TOKENIZED_CLASSES){if(null ===$this->allClasses){$this->allClasses=$this->parseClassLists();}$result=array();foreach($this->allClasses as$classType =>$classes){if($type&$classType){$result=array_merge($result,$classes);}}return$result;}}
||||||||function
getTokenValue($position=-1){if(-1
===$position){$position=$this->position;}return
isset($this->contents[$position])?$this->contents[$position]:null;}public
||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_RETURN
        (AST_DIM
            (AST_VAR)
            (SCALAR))))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_UNARY_OP
                    (SCALAR))
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_PROP
                        (AST_VAR))))))
    (AST_RETURN
        (AST_CONDITIONAL
            (AST_ISSET
                (AST_DIM
                    (AST_PROP
                        (AST_VAR))
                    (AST_VAR)))
            (AST_DIM
                (AST_PROP
                    (AST_VAR))
                (AST_VAR))
            (AST_CONST))))