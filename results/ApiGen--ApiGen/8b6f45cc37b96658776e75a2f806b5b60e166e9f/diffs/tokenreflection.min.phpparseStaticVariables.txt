 namespace TokenReflection;use RuntimeException;abstract class ReflectionFunctionBase extends ReflectionBase implements IReflectionFunctionBase{protected$modifiers=0;private$staticVariables=array();protected$namespaceName;private$returnsReference=false;private$parameters=array();public function getModifiers(){return$this->modifiers;}public function inNamespace(){return null !==$this->getNamespaceName();}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function getNumberOfParameters(){return count($this->parameters);}public function getNumberOfRequiredParameters(){$count=0;array_walk($this->parameters,function(ReflectionParameter$parameter)use(&$count){if(!$parameter->isOptional()){$count++;}});return$count;}public function getParameters(){return$this->parameters;}public function getParameter($parameter){if(is_numeric($parameter)){if(isset($this->parameters[$parameter])){return$this->parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($this->parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getStaticVariables(){return$this->staticVariables;}public function isClosure(){return false;}public function returnsReference(){return$this->returnsReference;}public function getName(){if(null !==$this->namespaceName &&ReflectionNamespace::NO_NAMESPACE_NAME !==$this->namespaceName){return$this->namespaceName.'\\'.$this->name;}return$this->name;}public function getShortName(){return$this->name;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw new RuntimeException('Could not determine the method/function name');}$this->name=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();return$this;}final protected function parseChildren(Stream$tokenStream){return$this ->parseParameters($tokenStream)->parseStaticVariables($tokenStream);}final protected function parseParameters(Stream$tokenStream){if(!$tokenStream->is('(')){throw new RuntimeException('Could not determine parameters start');}$tokenStream->skipWhitespaces();while(null !==($type=$tokenStream->getType())&&')' !==$type){if(T_VARIABLE ===$type){$parameter=new ReflectionParameter($tokenStream->getParameterStream(),$this->getBroker(),$this);$this->parameters[]=$parameter;}if($tokenStream->is(')')){break;}else{$tokenStream->skipWhitespaces();}}return$this;}final protected function parseStaticVariables(Stream$tokenStream){return$this;}final protected function parseReturnsReference(Stream$tokenStream){if(!$tokenStream->is(T_FUNCTION)){throw new RuntimeException('Could not find the function keyword.');}$tokenStream->skipWhitespaces();$type=$tokenStream->getType();if('&' ===$type){$this->returnsReference=true;$tokenStream->skipWhitespaces();}elseif(!T_STRING ===$type){throw new RuntimeException(sprintf('Unexpected token type: %s',$tokenStream->getTokenName()));}return$this;}}
 namespace TokenReflection;use RuntimeException;class ReflectionNamespace implements IReflectionNamespace{const NO_NAMESPACE_NAME='no-namespace';private$broker;private$name;private$classes=array();private$functions=array();private$constants=array();public function __construct($name,Broker$broker){$this->name=$name;$this->broker=$broker;}public function getClass($className){$className=ltrim($className,'\\');if(false === strpos($className,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$className=$this->getName().'\\'.$className;}if(!isset($this->classes[$className])){throw new Exception(sprintf('Class %s does not exist',$className),Exception::DOES_NOT_EXIST);}return$this->classes[$className];}public function getClasses(){return$this->classes;}public function getClassNames(){return array_keys($this->classes);}public function getClassShortNames(){return array_map(function(IReflectionClass$class){return$class->getShortName();},$this->classes);}public function getFunction($functionName){$functionName=ltrim($functionName,'\\');if(false === strpos($functionName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$functionName=$this->getName().'\\'.$functionName;}if(!isset($this->functions[$functionName])){throw new Exception(sprintf('Function %s does not exist',$functionName),Exception::DOES_NOT_EXIST);}return$this->functions[$functionName];}public function getFunctions(){return$this->functions;}public function getFunctionNames(){return array_keys($this->functions);}public function getFunctionShortNames(){return array_map(function(IReflectionFunction$function){return$function->getShortName();},$this->functions);}public function getConstant($constantName){$constantName=ltrim($constantName,'\\');if(false === strpos($constantName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$constantName=$this->getName().'\\'.$constantName;}if(!isset($this->constants[$constantName])){throw new Exception(sprintf('Constant %s does not exist',$constantName),Exception::DOES_NOT_EXIST);}return$this->constants[$constantName];}public function getConstants(){return$this->constants;}public function getConstantNames(){return array_keys($this->constants);}public function getConstantShortNames(){return array_map(function(IReflectionConstant$constant){return$constant->getShortName();},$this->constants);}public function getName(){return$this->name;}public function getBroker(){return$this->broker;}public function isTokenized(){return true;}public function isInternal(){return false;}public function isUserDefined(){return true;}public function addFileNamespace(ReflectionFileNamespace$namespace){$classes=$namespace->getClasses();foreach($this->classes as$className =>$reflection){if(isset($classes[$className])){throw new RuntimeException(sprintf('Class %s was defined multiple times',$className));}}$this->classes=array_merge($this->classes,$classes);$functions=$namespace->getFunctions();foreach($this->functions as$functionName =>$reflection){if(isset($functions[$functionName])){throw new RuntimeException(sprintf('Function %s was defined multiple times',$functionName));}}$this->functions=array_merge($this->functions,$functions);$constants=$namespace->getConstants();foreach($this->constants as$constantName =>$reflection){if(isset($constants[$constantName])){throw new RuntimeException(sprintf('Constant %s was defined multiple times',$constantName));}}$this->constants=array_merge($this->constants,$constants);}public function __toString(){return '';}public static function export($argument,$return=false){return ReflectionBase::export($argument,$return);}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}}
||||||||function
parseStaticVariables(Stream$tokenStream){$type=$tokenStream->getType();if('{'
===$type){$tokenStream->findMatchingBracket()->next();}elseif(';'
===$type){$tokenStream->next();}else{throw
new
RuntimeException(sprintf('Unexpected token found: %s',$type));}return$this;}final
protected
||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_RETURN
        (AST_VAR)))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_METHOD_CALL
                    (AST_METHOD_CALL
                        (AST_VAR)))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (
                (AST_METHOD_CALL
                    (AST_VAR))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_THROW
                    (AST_NEW
                        (
                            (AST_CALL
                                (
                                    (SCALAR)
                                    (AST_VAR)))))))))
    (AST_RETURN
        (AST_VAR)))