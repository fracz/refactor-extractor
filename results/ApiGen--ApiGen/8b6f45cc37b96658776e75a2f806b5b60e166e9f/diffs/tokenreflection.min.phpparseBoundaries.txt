 namespace TokenReflection;use RuntimeException;abstract class ReflectionBase implements IReflection{private static$methodCache=array();private$broker;private$startLine;private$endLine;private$docComment;private$parsedDocComment;protected$name;private$filename;public final function __construct(Stream$tokenStream,Broker$broker,IReflection$parent){if(0 === count($tokenStream)){throw new Exception('Reflection token stream must not be empty');}$this->broker=$broker;$this->filename=$tokenStream->getFileName();return$this ->processParent($parent)->parse($tokenStream,$parent)->parseChildren($tokenStream);}protected function processParent(IReflection$parent){return$this;}protected function parseChildren(Stream$tokenStream){return$this;}protected function parse(Stream$tokenStream,IReflection$parent){return$this ->parseDocComment($tokenStream)->parseBoundaries($tokenStream);}private function parseDocComment(Stream$tokenStream){if(!$tokenStream->is(T_DOC_COMMENT)){$this->docComment=false;}else{$this->docComment=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();}return$this;}private function parseBoundaries(Stream$tokenStream){$this->startLine=$tokenStream[0][2];if($this->docComment){$this->startLine += substr_count($this->docComment,"\n")+1;}if($last=count($tokenStream)){$this->endLine=$tokenStream[--$last][2]+substr_count($tokenStream[$last][1],"\n");}return$this;}abstract protected function parseName(Stream$tokenStream);public function getFileName(){return$this->filename;}public function getStartLine(){return$this->startLine;}public function getEndLine(){return$this->endLine;}public function getExtension(){return null;}public function getExtensionName(){return null;}public function isInternal(){return false;}public function isUserDefined(){return true;}public function isDeprecated(){return$this->hasAnnotation('deprecated');}public function getName(){return$this->name;}public function getSource(){$tokens=$this->broker->getFileTokens($this->filename);if(null !==$tokens &&$tokens instanceof Stream){$tokens=iterator_to_array($tokens);}else{return '';}return array_reduce($tokens,function($output,$token){return$output.$token[1];},'');}public function getDocComment(){return$this->docComment;}public function getBroker(){return$this->broker;}public function isTokenized(){return true;}public function __toString(){return '';}private function parseAnnotations(){$this->parsedDocComment=ReflectionAnnotation::parse($this);}public function getPackageName(){if($package=$this->getAnnotation('package')){return$package[0];}return ReflectionClass::PACKAGE_NONE;}final public function getAnnotation($name){$name=strtolower($name);$params=$this->getAnnotations();if(isset($params[$name])){return$params[$name];}return isset($this->parsedDocComment[$name])?$this->parsedDocComment[$name]:null;}final public function hasAnnotation($name){$name=strtolower($name);$params=$this->getAnnotations();if(isset($params[$name])){return true;}return isset($this->parsedDocComment[$name]);}final public function getAnnotations(){if(null ===$this->parsedDocComment){$this->parseAnnotations();}return isset($this->parsedDocComment['PARAMS'])?$this->parsedDocComment['PARAMS']:array();}final public function __get($key){return self::get($this,$key);}final public function __isset($key){return self::exists($this,$key);}public static function export($argument,$return=false){}final public static function get(IReflection$object,$key){if(!empty($key)){$className=get_class($object);if(!isset(self::$methodCache[$className])){self::$methodCache[$className]=array_flip(get_class_methods($className));}$methods=self::$methodCache[$className];$key2=ucfirst($key);if(isset($methods['get'.$key2])){return$object->{'get'.$key2}();}elseif(isset($methods['is'.$key2])){return$object->{'is'.$key2}();}}throw new RuntimeException(sprintf('Cannot read property %s',$key));}final public static function exists(IReflection$object,$key){try{self::get($object,$key);return true;}catch(RuntimeException$e){return false;}}final public static function resolveClassFQN($className,array$aliases,$namespaceName=null){if($className{0}== '\\'){return ltrim($className,'\\');}if(false ===($position=strpos($className,'\\'))){if(isset($aliases[$className])){return$aliases[$className];}}else{$alias=substr($className,0,$position);if(isset($aliases[$alias])){return$aliases[$alias].'\\'.substr($className,$position+1);}}return null ===$namespaceName ||$namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?$className:$namespaceName.'\\'.$className;}}
 namespace TokenReflection;use ArrayIterator;class ReflectionFile implements IReflection{private$namespaces=array();private$tokenStream=null;private$broker;public function __construct($filename,array$tokenStream,Broker$broker){$this->tokenStream=new Stream($tokenStream,$filename);$this->broker=$broker;$this->parse();}public function getNamespaces(){return$this->namespaces;}private function parse(){if(count($this->tokenStream)<= 1){return;}static$breakers=array(T_CLASS,T_INTERFACE,T_FUNCTION,T_CONST,T_IF);while(null !==($type=$this->tokenStream->getType())){if(in_array($type,$breakers)){break;}if(T_NAMESPACE ===$type){$namespace=new ReflectionFileNamespace($this->tokenStream->getNamespaceStream(),$this->broker,$this);$this->namespaces[]=$namespace;}$this->tokenStream->skipWhitespaces();}if(empty($this->namespaces)){for($nsStart=0;$nsStart <=$this->tokenStream->key();$nsStart++){if($this->tokenStream->is(T_OPEN_TAG,$nsStart)){break;}}while(null !==($this->tokenStream->getType($nsStart+1))&&T_DOC_COMMENT ===$this->tokenStream->getType($nsStart)&&T_WHITESPACE ===$type){$nsStart += 2;}$tokens=$this->tokenStream->getArrayCopy();$namespace=new ReflectionFileNamespace(new Stream(array_slice($tokens,$nsStart),$this->tokenStream->getFileName()),$this->broker,$this);$this->namespaces[]=$namespace;}}public function getTokenStream(){return$this->tokenStream;}public function getName(){return$this->tokenStream->getFileName();}public function getBroker(){return$this->broker;}public function __toString(){return '';}public function getSource(){return (string)$this->tokenStream;}public static function export($argument,$return=false){return ReflectionBase::export($argument,$return);}public function isTokenized(){return true;}public function isInternal(){return false;}public function isUserDefined(){return true;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}}
||||||||||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_DIM
            (AST_DIM
                (AST_VAR)
                (SCALAR))
            (SCALAR)))
    (AST_IF
        (AST_IF_ELEM
            (AST_PROP
                (AST_VAR))
            (
                (AST_ASSIGN_OP
                    (AST_PROP
                        (AST_VAR))
                    (AST_BINARY_OP
                        (AST_CALL
                            (
                                (AST_PROP
                                    (AST_VAR))
                                (SCALAR)))
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_ASSIGN
                (AST_VAR)
                (AST_CALL
                    (
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_BINARY_OP
                        (AST_DIM
                            (AST_DIM
                                (AST_VAR)
                                (AST_PRE_DEC
                                    (AST_VAR)))
                            (SCALAR))
                        (AST_CALL
                            (
                                (AST_DIM
                                    (AST_DIM
                                        (AST_VAR)
                                        (AST_VAR))
                                    (SCALAR))
                                (SCALAR))))))))
    (AST_RETURN
        (AST_VAR)))||||||||