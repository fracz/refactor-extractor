<?php
/**
 * PHP Token Reflection
 *
 * Pre-release testing version
 * Comming soon at https://github.com/Andrewsville/PHP-Token-Reflection
 *
 * LICENSE
 *
 * This source file is subject to the new BSD license that is bundled
 * with this library in the file license.txt.
 *
 * @author Ondřej Nešpor <andrew@andrewsville.cz>
 * @author Jaroslav Hanslík <kukulich@kukulich.cz>
 */
namespace
TokenReflection\Broker{use
TokenReflection;interface
Backend{const
TOKENIZED_CLASSES=1;const
INTERNAL_CLASSES=2;const
NONEXISTENT_CLASSES=4;public
function
getNamespace($namespaceName);public
function
getClass($className);public
function
getFunction($functionName);public
function
getConstant($constantName);public
function
isFileProcessed($fileName);public
function
getFileTokens($fileName);public
function
addFile(TokenReflection\ReflectionFile$file);public
function
setBroker(TokenReflection\Broker$broker);public
function
getBroker();public
function
setStoringTokenStreams($store);public
function
getStoringTokenStreams();public
function
getClasses($type=Backend::TOKENIZED_CLASSES);}}

namespace
TokenReflection{use
TokenReflection;use
TokenReflection\Broker,ArrayIterator,RecursiveDirectoryIterator,RecursiveIteratorIterator;use
RuntimeException;class
Broker{const
CACHE_CLASS='class';const
CACHE_FUNCTION='function';const
CACHE_CONSTANT='constant';const
CACHE_NAMESPACE='namespace';private$backend;private$cache;public
function
__construct(Broker\Backend$backend,$storingTokenStream=true){$this->cache=array(self::CACHE_CLASS
=>
array(),self::CACHE_CONSTANT
=>
array(),self::CACHE_FUNCTION
=>
array(),self::CACHE_NAMESPACE
=>
array());$this->backend=$backend
->setBroker($this)->setStoringTokenStreams($storingTokenStream);}public
function
processFile($filename){$realName=realpath($filename);if(false
===$realName){throw
new
Exception(sprintf('File %s does not exist',$filename),Exception::FILE_DOES_NOT_EXIST);}if($this->backend->isFileProcessed($realName)){$tokens=$this->backend->getFileTokens($realName);}else{$contents=@file_get_contents($filename);if(false
===$contents){throw
new
Exception('File is not readable',Exception::FILE_NOT_READABLE);}$tokens=@token_get_all(str_replace(array("\r\n","\r"),"\n",$contents));}$reflectionFile=new
ReflectionFile($realName,$tokens,$this);if(!$this->backend->isFileProcessed($realName)){$this->backend->addFile($reflectionFile);foreach($this->cache
as$type
=>$cached){if(!empty($cached)){$this->cache[$type]=array_filter($cached,function(IReflection$reflection){return$reflection->isTokenized();});}}}return$reflectionFile;}public
function
processDirectory($path){$realPath=realpath($path);if(false
===$realPath){throw
new
Exception(sprintf('Directory %s does not exist',$path),Exception::FILE_DOES_NOT_EXIST);}$result=array();foreach(new
RecursiveIteratorIterator(new
RecursiveDirectoryIterator($realPath))as$entry){if($entry->isFile()){$result[$entry->getPathName()]=$this->processFile($entry->getPathName());}}return$result;}public
function
getNamespace($namespaceName){$namespaceName=ltrim($namespaceName,'\\');if(isset($this->cache[self::CACHE_NAMESPACE][$namespaceName])){return$this->cache[self::CACHE_NAMESPACE][$namespaceName];}$namespace=$this->backend->getNamespace($namespaceName);if(null
!==$namespace){$this->cache[self::CACHE_NAMESPACE][$namespaceName]=$namespaceName;}return$namespace;}public
function
getClass($className){$className=ltrim($className,'\\');if(isset($this->cache[self::CACHE_CLASS][$className])){return$this->cache[self::CACHE_CLASS][$className];}$this->cache[self::CACHE_CLASS][$className]=$this->backend->getClass($className);return$this->cache[self::CACHE_CLASS][$className];}public
function
getFunction($functionName){$functionName=ltrim($functionName,'\\');if(isset($this->cache[self::CACHE_FUNCTION][$functionName])){return$this->cache[self::CACHE_FUNCTION][$functionName];}if($function=$this->backend->getFunction($functionName)){$this->cache[self::CACHE_FUNCTION][$functionName]=$function;}return$function;}public
function
getConstant($constantName){$constantName=ltrim($constantName,'\\');if(isset($this->cache[self::CACHE_CONSTANT][$constantName])){return$this->cache[self::CACHE_CONSTANT][$constantName];}if($constant=$this->backend->getConstant($constantName)){$this->cache[self::CACHE_CONSTANT][$constantName]=$constant;}return$constant;}public
function
getFileTokens($fileName){if(!$this->backend->getStoringTokenStreams){throw
new
RuntimeException('Token streams storing is turned off.');}return$this->backend->getFileTokens($fileName);}public
function
getClasses($types=Broker\Backend::TOKENIZED_CLASSES){return$this->backend->getClasses($types);}}}

namespace
TokenReflection{use
Exception
as
InternalException;class
Exception
extends
InternalException{const
UNSUPPORTED=-1;const
INVALID_SOURCE=0;const
FILE_DOES_NOT_EXIST=1;const
FILE_NOT_READABLE=2;const
DIR_DOES_NOT_EXIST=3;const
NO_BACKEND_SET=5;const
UNSERIALIZATION_ERROR=10;const
DOES_NOT_EXIST=15;}}

namespace
TokenReflection{interface
IReflection{public
function
getName();public
function
getBroker();public
function
isTokenized();public
function
isInternal();public
function
isUserDefined();public
function
__get($key);public
function
__isset($key);}}

namespace
TokenReflection{class
ReflectionAnnotation{const
SHORT_DESCRIPTION=' short_description';const
LONG_DESCRIPTION=' long_description';public
static
function
parse(ReflectionBase$reflection){static$emptyResult=array();$docblock=$reflection->getInheritedDocComment();if(false
===$docblock){return$emptyResult;}$result=$emptyResult;$name=self::SHORT_DESCRIPTION;$docblock=trim(preg_replace(array('~^/\\s*\\*\\*~','~\\*/$~'),'',$docblock));foreach(explode("\n",$docblock)as$line){$line=preg_replace('~^\\*\\s*~','',trim($line));if(''
===$line
&&self::SHORT_DESCRIPTION
===$name){$name=self::LONG_DESCRIPTION;continue;}if(preg_match('~^@([\\S]+)\\s*(.*)~',$line,$matches)){$name=$matches[1];$result[$name][]=$matches[2];continue;}if(self::SHORT_DESCRIPTION
===$name
||
self::LONG_DESCRIPTION
===$name){if(!isset($result[$name])){$result[$name]=$line;}else{$result[$name].=
"\n".$line;}}else{$result[$name][count($result[$name])-1].=
"\n".$line;}}array_walk_recursive($result,function(&$value){$value=trim($value);});return$result;}}}

namespace
TokenReflection{use
SeekableIterator,Countable,ArrayAccess,InvalidArgumentException,RuntimeException;class
Stream
implements
SeekableIterator,Countable,ArrayAccess{private$filename='unknown';private$types=array();private$contents=array();private$tokens=array();private$position=0;private$count=0;public
function
__construct(array$stream,$filename){$this->filename=$filename;static$checkLines;if(null
===$checkLines){$checkLines=array_flip(array(T_COMMENT,T_WHITESPACE,T_DOC_COMMENT,T_INLINE_HTML,T_ENCAPSED_AND_WHITESPACE,T_CONSTANT_ENCAPSED_STRING));}foreach($stream
as$position
=>$token){if(is_array($token)){list($this->types[],$this->contents[])=$token;$this->tokens[]=$token;}else{$this->types[]=$token;$this->contents[]=$token;$previous=$this->tokens[$position-1];$line=$previous[2];if(isset($checkLines[$previous[0]])){$line
+=
substr_count($previous[1],"\n");}$this->tokens[]=array($token,$token,$line);}}$this->count=count($stream);}public
function
offsetExists($offset){return
isset($this->tokens[$offset]);}public
function
offsetUnset($offset){throw
new
Exception('Removing of tokens from the stream is not supported.',Exception::UNSUPPORTED);}public
function
offsetGet($offset){return
isset($this->contents[$offset])?$this->contents[$offset]:null;}public
function
offsetSet($offset,$value){throw
new
Exception('Setting token values is not supported.',Exception::UNSUPPORTED);}public
function
key(){return$this->position;}public
function
next(){$this->position++;return$this;}public
function
rewind(){$this->position=0;return$this;}public
function
current(){return
isset($this->tokens[$this->position])?$this->tokens[$this->position]:null;}public
function
valid(){return
isset($this->tokens[$this->position]);}public
function
count(){return$this->count;}public
function
seek($position){$this->position=(int)$position;return$this;}public
function
getFileName(){return$this->filename;}public
function
findMatchingBracket(){static$brackets=array('('
=>
')','{'
=>
'}','['
=>
']');if(!$this->valid()){throw
new
InvalidArgumentException('Out of array');}$position=$this->position;$bracket=$this->contents[$this->position];if(isset($brackets[$bracket])){$searching=$brackets[$bracket];}else{throw
new
InvalidArgumentException(sprintf('There is no usable bracket at position [%d] in file [%s]',$this->key(),$this->filename));}$level=0;while(isset($this->tokens[$this->position])){$type=$this->types[$this->position];if($searching
===$type){$level--;}elseif($bracket
===$type
||($searching
===
'}'
&&(T_CURLY_OPEN
===$type
||
T_DOLLAR_OPEN_CURLY_BRACES
===$type))){$level++;}if(0
===$level){return$this;}$this->position++;}throw
new
RuntimeException(sprintf('Could not find the matching bracket "%s" of the bracket at position [%d] in file [%s]',$searching,$position,$this->filename));}public
function
skipWhitespaces($startAtNext=true){if($startAtNext
&&isset($this->tokens[$this->position])){$this->position++;}while(isset($this->types[$this->position])){if(T_WHITESPACE
===$this->types[$this->position]||
T_COMMENT
===$this->types[$this->position]){$this->position++;continue;}break;}return$this;}public
function
is($type,$position=-1){return$type
===$this->getType($position);}public
function
getType($position=-1){if(-1
===$position){$position=$this->position;}return
isset($this->types[$position])?$this->types[$position]:null;}public
function
getTokenValue($position=-1){if(-1
===$position){$position=$this->position;}return
isset($this->contents[$position])?$this->contents[$position]:null;}public
function
getTokenName($position=-1){$type=$this->getType($position);return
token_name($type)?:$type;}public
function
__toString(){return
self::tokensToCode($this->contents);}public
static
function
tokensToCode(array$tokens=array()){return
implode('',$tokens);}}}

namespace
TokenReflection\Broker\Backend{use
TokenReflection;use
TokenReflection\Broker,TokenReflection\Php,TokenReflection\Dummy;use
InvalidArgumentException,RuntimeException,TokenReflection\Exception;class
Memory
implements
Broker\Backend{private$namespaces=array();private$allClasses;private$tokenStreams=array();private$broker;private$storingTokenStreams;public
function
getNamespace($namespaceName){if(!isset($this->namespaces[TokenReflection\ReflectionNamespace::NO_NAMESPACE_NAME])){$this->namespaces[TokenReflection\ReflectionNamespace::NO_NAMESPACE_NAME]=new
TokenReflection\ReflectionNamespace(TokenReflection\ReflectionNamespace::NO_NAMESPACE_NAME,$this->broker);}$namespaceName=ltrim($namespaceName,'\\');if(!isset($this->namespaces[$namespaceName])){throw
new
Exception(sprintf('Namespace %s does not exist.',$namespaceName),Exception::DOES_NOT_EXIST);}return$this->namespaces[$namespaceName];}public
function
getClass($className){static$declared=array();if(empty($declared)){$declared=array_flip(array_merge(get_declared_classes(),get_declared_interfaces()));}$className=ltrim($className,'\\');try{$ns=$this->getNamespace(($boundary=strrpos($className,'\\'))?substr($className,0,$boundary):TokenReflection\ReflectionNamespace::NO_NAMESPACE_NAME);return$ns->getClass($className);}catch(Exception$e){if(isset($declared[$className])){$reflection=new
Php\ReflectionClass($className,$this->broker);if($reflection->isInternal()){return$reflection;}}return
new
Dummy\ReflectionClass($className,$this->broker);}}public
function
getFunction($functionName){static$declared=array();if(empty($declared)){$functions=get_defined_functions();$declared=array_flip($functions['internal']);}$functionName=ltrim($functionName,'\\');try{$ns=$this->getNamespace(($boundary=strrpos($functionName,'\\'))?substr($functionName,0,$boundary):TokenReflection\ReflectionNamespace::NO_NAMESPACE_NAME);return$ns->getFunction($functionName);}catch(Exception$e){return
isset($declared[$functionName])?new
Php\ReflectionFunction($functionName,$this->broker):null;}}public
function
getConstant($constantName){static$declared=array();if(empty($declared)){$declared=get_defined_constants();}if($boundary=strpos($constantName,'::')){$className=substr($constantName,0,$boundary);$constantName=substr($constantName,$boundary+2);try{return$this->getClass($className)->getConstantReflection($constantName);}catch(Exception$e){return
null;}}try{$constantName=ltrim($constantName,'\\');if($boundary=strrpos($constantName,'\\')){$ns=$this->getNamespace(substr($constantName,0,$boundary));$constantName=substr($constantName,$boundary+1);}else{$ns=$this->getNamespace(TokenReflection\ReflectionNamespace::NO_NAMESPACE_NAME);}return$ns->getConstant($constantName);}catch(Exception$e){$reflection=new
Php\ReflectionConstant($constantName,$declared[$constantName],$this->broker);return$reflection->isInternal()?$reflection:null;}}public
function
isFileProcessed($fileName){return
isset($this->tokenStreams[$fileName]);}public
function
getFileTokens($fileName){if(!$this->isFileProcessed($fileName)){throw
new
InvalidArgumentException(sprintf('File %s was not processed',$fileName));}return$this->tokenStreams[$fileName];}public
function
addFile(TokenReflection\ReflectionFile$file,$storeTokenStream=true){foreach($file->getNamespaces()as$fileNamespace){$namespaceName=$fileNamespace->getName();if(!isset($this->namespaces[$namespaceName])){$this->namespaces[$namespaceName]=new
TokenReflection\ReflectionNamespace($namespaceName,$file->getBroker());}$this->namespaces[$namespaceName]->addFileNamespace($fileNamespace);}if($this->storingTokenStreams){$this->tokenStreams[$file->getName()]=$file->getTokenStream();}$this->allClasses=null;return$this;}public
function
setBroker(Broker$broker){$this->broker=$broker;return$this;}public
function
getBroker(){return$this->broker;}public
function
setStoringTokenStreams($store){$this->storingTokenStreams=(bool)$store;return$this;}public
function
getStoringTokenStreams(){return$this->storingTokenStreams;}protected
function
parseClassLists(){$allClasses=array(self::TOKENIZED_CLASSES
=>
array(),self::INTERNAL_CLASSES
=>
array(),self::NONEXISTENT_CLASSES
=>
array());foreach($this->namespaces
as$namespace){foreach($namespace->getClasses()as$class){$allClasses[self::TOKENIZED_CLASSES][$class->getName()]=$class;}}foreach($allClasses[self::TOKENIZED_CLASSES]as$className
=>$class){foreach(array_merge($class->getParentClasses(),$class->getInterfaces())as$parent){if($parent->isTokenized()){if(!isset($allClasses[self::TOKENIZED_CLASSES][$parent->getName()])){throw
new
RuntimeException(sprintf('Class %s should be tokenized',$parent->getName()));}}elseif($parent->isInternal()){$allClasses[self::INTERNAL_CLASSES][$parent->getName()]=$parent;}else{$allClasses[self::NONEXISTENT_CLASSES][$parent->getName()]=$parent;}}}return$allClasses;}public
function
getClasses($type=self::TOKENIZED_CLASSES){if(null
===$this->allClasses){$this->allClasses=$this->parseClassLists();}$result=array();foreach($this->allClasses
as$classType
=>$classes){if($type&$classType){$result=array_merge($result,$classes);}}return$result;}}}

namespace
TokenReflection{interface
IReflectionClass
extends
IReflection{public
function
getConstant($name);public
function
getConstantReflection($name);public
function
getConstants();public
function
getOwnConstants();public
function
getConstantReflections();public
function
getOwnConstantReflections();public
function
getConstructor();public
function
getDestructor();public
function
getDefaultProperties();public
function
getDocComment();public
function
getInheritedDocComment();public
function
getStartLine();public
function
getEndLine();public
function
getExtension();public
function
getExtensionName();public
function
getFileName();public
function
getInterfaceNames();public
function
getOwnInterfaceNames();public
function
getInterfaces();public
function
getOwnInterfaces();public
function
getMethod($name);public
function
getMethods($filter=null);public
function
getOwnMethods($filter=null);public
function
getModifiers();public
function
getNamespaceName();public
function
getParentClass();public
function
getParentClasses();public
function
getParentClassName();public
function
getParentClassNameList();public
function
getProperties($filter=null);public
function
getOwnProperties($filter=null);public
function
getProperty($name);public
function
getShortName();public
function
getStaticProperties();public
function
getStaticPropertyValue($name,$default=null);public
function
hasConstant($name);public
function
hasOwnConstant($name);public
function
hasMethod($name);public
function
hasOwnMethod($name);public
function
hasProperty($name);public
function
hasOwnProperty($name);public
function
implementsInterface($interface);public
function
inNamespace();public
function
isAbstract();public
function
isFinal();public
function
isInstance($object);public
function
isInterface();public
function
isCloneable();public
function
isIterateable();public
function
isSubclassOf($class);public
function
getDirectSubclasses();public
function
getDirectSubclassNames();public
function
getIndirectSubclasses();public
function
getIndirectSubclassNames();public
function
getDirectImplementers();public
function
getDirectImplementerNames();public
function
getIndirectImplementers();public
function
getIndirectImplementerNames();public
function
newInstance($args);public
function
newInstanceArgs(array$args=array());public
function
setStaticPropertyValue($name,$value);}}

namespace
TokenReflection{interface
IReflectionConstant
extends
IReflection{public
function
getDeclaringClass();public
function
getDeclaringClassName();public
function
getNamespaceName();public
function
inNamespace();public
function
getValue();public
function
getValueDefinition();public
function
getDocComment();public
function
getInheritedDocComment();public
function
getStartLine();public
function
getEndLine();public
function
getFileName();public
function
getShortName();}}

namespace
TokenReflection{interface
IReflectionExtension
extends
IReflection{public
function
getClass($name);public
function
getClasses();public
function
getClassNames();public
function
getConstantReflection($name);public
function
getConstantReflections();public
function
getConstant($name);public
function
getConstants();public
function
getFunction($name);public
function
getFunctions();public
function
getFunctionNames();}}

namespace
TokenReflection{interface
IReflectionFunctionBase
extends
IReflection{public
function
getDocComment();public
function
getInheritedDocComment();public
function
getStartLine();public
function
getEndLine();public
function
getExtension();public
function
getExtensionName();public
function
getFileName();public
function
getNamespaceName();public
function
getNumberOfParameters();public
function
getNumberOfRequiredParameters();public
function
getParameters();public
function
getParameter($parameter);public
function
getStaticVariables();public
function
inNamespace();public
function
isClosure();public
function
isDeprecated();public
function
returnsReference();}}

namespace
TokenReflection{interface
IReflectionNamespace
extends
IReflection{public
function
getClass($className);public
function
getClasses();public
function
getClassNames();public
function
getClassShortNames();public
function
getFunction($functionName);public
function
getFunctions();public
function
getFunctionNames();public
function
getFunctionShortNames();public
function
getConstant($constantName);public
function
getConstants();public
function
getConstantNames();public
function
getConstantShortNames();}}

namespace
TokenReflection{interface
IReflectionParameter
extends
IReflection{public
function
getDeclaringClass();public
function
getDeclaringClassName();public
function
getDeclaringFunction();public
function
getDeclaringFunctionName();public
function
getDefaultValue();public
function
getDefaultValueDefinition();public
function
getPosition();public
function
isArray();public
function
allowsNull();public
function
getClass();public
function
getClassName();public
function
isDefaultValueAvailable();public
function
isOptional();public
function
isPassedByReference();public
function
getDocComment();public
function
getInheritedDocComment();public
function
getStartLine();public
function
getEndLine();}}

namespace
TokenReflection{interface
IReflectionProperty
extends
IReflection{public
function
getDeclaringClass();public
function
getClass();public
function
getDeclaringClassName();public
function
getDocComment();public
function
getInheritedDocComment();public
function
getStartLine();public
function
getEndLine();public
function
getModifiers();public
function
getValue($object);public
function
isDefault();public
function
getDefaultValue();public
function
getDefaultValueDefinition();public
function
isPrivate();public
function
isProtected();public
function
isPublic();public
function
isStatic();public
function
setAccessible($accessible);public
function
setValue($object,$value);}}

namespace
TokenReflection\Php{use
TokenReflection;use
Reflector;interface
IReflection
extends
TokenReflection\IReflection{public
static
function
create(Reflector$internalReflection,TokenReflection\Broker$broker);}}

namespace
TokenReflection{use
RuntimeException;abstract
class
ReflectionBase
implements
IReflection{private
static$methodCache=array();private$broker;private$startLine;private$endLine;protected$docComment;private$parsedDocComment;protected$name;private$filename;public
final
function
__construct(Stream$tokenStream,Broker$broker,IReflection$parent){if(0
===$tokenStream->count()){throw
new
Exception('Reflection token stream must not be empty');}$this->broker=$broker;$this->filename=$tokenStream->getFileName();if(!$this
instanceof
ReflectionParameter){$this->parseDocComment($tokenStream);}return$this
->processParent($parent)->parseStartLine($tokenStream)->parse($tokenStream,$parent)->parseChildren($tokenStream,$parent)->parseEndLine($tokenStream);}protected
function
processParent(IReflection$parent){return$this;}protected
function
parseChildren(Stream$tokenStream,IReflection$parent){return$this;}protected
abstract
function
parse(Stream$tokenStream,IReflection$parent);protected
function
parseDocComment(Stream$tokenStream){$position=$tokenStream->key();if($tokenStream->is(T_DOC_COMMENT,$position-2)){$this->docComment=$tokenStream->getTokenValue($position-2);}elseif($tokenStream->is(T_DOC_COMMENT,$position-1)){$this->docComment=$tokenStream->getTokenValue($position-1);}else{$this->docComment=false;}return$this;}private
final
function
parseStartLine(Stream$tokenStream){$token=$tokenStream->current();$this->startLine=$token[2];return$this;}private
final
function
parseEndLine(Stream$tokenStream){$token=$tokenStream->current();$this->endLine=$token[2];return$this;}abstract
protected
function
parseName(Stream$tokenStream);public
function
getFileName(){return$this->filename;}public
function
getStartLine(){return$this->startLine;}public
function
getEndLine(){return$this->endLine;}public
function
getExtension(){return
null;}public
function
getExtensionName(){return
null;}public
function
isInternal(){return
false;}public
function
isUserDefined(){return
true;}public
function
isDeprecated(){return$this->hasAnnotation('deprecated');}public
function
getName(){return$this->name;}public
function
getSource(){$tokens=$this->broker->getFileTokens($this->filename);if(null
!==$tokens
&&$tokens
instanceof
Stream){$tokens=iterator_to_array($tokens);}else{return
'';}return
array_reduce($tokens,function($output,$token){return$output.$token[1];},'');}public
function
getDocComment(){return$this->docComment;}public
function
getBroker(){return$this->broker;}public
function
isTokenized(){return
true;}public
function
__toString(){return
'';}public
function
getPackageName(){if($package=$this->getAnnotation('package')){return$package[0];}return
ReflectionClass::PACKAGE_NONE;}final
public
function
getAnnotation($name){$params=$this->getAnnotations();if(isset($params[$name])){return$params[$name];}return
null;}final
public
function
hasAnnotation($name){$params=$this->getAnnotations();return
isset($params[$name]);}final
public
function
getAnnotations(){if(null
===$this->parsedDocComment){$this->parsedDocComment=ReflectionAnnotation::parse($this);}return$this->parsedDocComment;}final
public
function
__get($key){return
self::get($this,$key);}final
public
function
__isset($key){return
self::exists($this,$key);}public
static
function
export($argument,$return=false){}final
public
static
function
get(IReflection$object,$key){if(!empty($key)){$className=get_class($object);if(!isset(self::$methodCache[$className])){self::$methodCache[$className]=array_flip(get_class_methods($className));}$methods=self::$methodCache[$className];$key2=ucfirst($key);if(isset($methods['get'.$key2])){return$object->{'get'.$key2}();}elseif(isset($methods['is'.$key2])){return$object->{'is'.$key2}();}}throw
new
RuntimeException(sprintf('Cannot read property %s',$key));}final
public
static
function
exists(IReflection$object,$key){try{self::get($object,$key);return
true;}catch(RuntimeException$e){return
false;}}final
public
static
function
resolveClassFQN($className,array$aliases,$namespaceName=null){if($className{0}==
'\\'){return
ltrim($className,'\\');}if(false
===($position=strpos($className,'\\'))){if(isset($aliases[$className])){return$aliases[$className];}}else{$alias=substr($className,0,$position);if(isset($aliases[$alias])){return$aliases[$alias].'\\'.substr($className,$position+1);}}return
null
===$namespaceName
||$namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME?$className:$namespaceName.'\\'.$className;}}}

namespace
TokenReflection{use
ArrayIterator;class
ReflectionFile
implements
IReflection{private$namespaces=array();private$tokenStream=null;private$broker;public
function
__construct($filename,array$tokenStream,Broker$broker){$this->tokenStream=new
Stream($tokenStream,$filename);$this->broker=$broker;$this->parse();}public
function
getNamespaces(){return$this->namespaces;}private
function
parse(){if($this->tokenStream->count()<=
1){return;}if(!$this->tokenStream->is(T_OPEN_TAG)){$this->namespaces[]=new
ReflectionFileNamespace($this->tokenStream,$this->broker,$this);}else{$this->tokenStream->skipWhitespaces();while(null
!==($type=$this->tokenStream->getType())){switch($type){case
T_WHITESPACE:case
T_DOC_COMMENT:case
T_COMMENT:break;case
T_DECLARE:$this->tokenStream
->skipWhitespaces()->findMatchingBracket()->skipWhitespaces()->skipWhitespaces();break;case
T_NAMESPACE:break
2;default:$this->namespaces[]=new
ReflectionFileNamespace($this->tokenStream,$this->broker,$this);return$this;}$this->tokenStream->skipWhitespaces();}while(null
!==($type=$this->tokenStream->getType())){if(T_NAMESPACE
===$type){$this->namespaces[]=new
ReflectionFileNamespace($this->tokenStream,$this->broker,$this);}else{$this->tokenStream->skipWhitespaces();}}}return$this;}public
function
getTokenStream(){return$this->tokenStream;}public
function
getName(){return$this->tokenStream->getFileName();}public
function
getBroker(){return$this->broker;}public
function
__toString(){return
'';}public
function
getSource(){return
(string)$this->tokenStream;}public
static
function
export($argument,$return=false){return
ReflectionBase::export($argument,$return);}public
function
isTokenized(){return
true;}public
function
isInternal(){return
false;}public
function
isUserDefined(){return
true;}final
public
function
__get($key){return
ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
ReflectionBase::exists($this,$key);}}}

namespace
TokenReflection{use
ReflectionProperty
as
InternalReflectionProperty,ReflectionClass
as
InternalReflectionClass;use
RuntimeException,InvalidArgumentException;class
ReflectionProperty
extends
ReflectionBase
implements
IReflectionProperty{const
IS_SHADOW=0x20000;private
static$parseValueDefinitions=false;private$declaringClassName;private$defaultValue;private$defaultValueDefinition;private$modifiers=0;private$accessible=false;public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getDeclaringClass(){return$this->getBroker()->getClass($this->declaringClassName);}public
function
getModifiers(){if(!($this->modifiers&self::IS_SHADOW)){$declaringClass=$this->getDeclaringClass();if(null
===$declaringClass){throw
new
RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null
!==$parentClass){$parentClassProperties=$parentClass->getProperties(InternalReflectionProperty::IS_PRIVATE);if(isset($parentClassProperties[$this->name])){$this->modifiers
|=
self::IS_SHADOW;}}}return$this->modifiers;}public
function
isDefault(){return
null
!==$this->defaultValueDefinition;}public
function
getDefaultValue(){return$this->defaultValue;}public
function
getValue($object){$declaringClass=$this->getDeclaringClass();if(null
===$declaringClass){throw
new
RuntimeException('No declaring class defined.');}if(!$declaringClass->isInstance($object)){throw
new
InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return$object->{$this->name};}elseif($this->isAccessible()){$refClass=new
InternalReflectionClass($object);$refProperty=$refClass->getProperty($this->name);$refProperty->setAccessible(true);$value=$refProperty->getValue($object);$refProperty->setAccessible(false);return$value;}throw
new
Exception('Only public or accessible properties can return thier values');}public
function
getDefaultValueDefinition(){return$this->defaultValueDefinition;}public
function
isPrivate(){return
(bool)($this->modifiers&InternalReflectionProperty::IS_PRIVATE);}public
function
isProtected(){return
(bool)($this->modifiers&InternalReflectionProperty::IS_PROTECTED);}public
function
isPublic(){return
(bool)($this->modifiers&InternalReflectionProperty::IS_PUBLIC);}public
function
isStatic(){return
(bool)($this->modifiers&InternalReflectionProperty::IS_STATIC);}public
function
setAccessible($accessible){$this->accessible=(bool)$accessible;}public
function
isAccessible(){return$this->accessible;}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())&&false
===
strpos($docComment,'@inheritdoc')){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null
!==$parent
&&$parent->hasProperty($this->getName())){return$parent->getProperty($this->getName())->getInheritedDocComment();}return
false;}public
function
setValue($object,$value){$declaringClass=$this->getDeclaringClass();if(null
===$declaringClass){throw
new
RuntimeException('No declaring class defined.');}if(!$declaringClass->isInstance($object)){throw
new
InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){$object->{$this->name}=$value;}elseif($this->isAccessible()){$refClass=new
InternalReflectionClass($object);$refProperty=$refClass->getProperty($this->name);$refProperty->setAccessible(true);$refProperty->setValue($object,$value);$refProperty->setAccessible(false);if($this->isStatic()){$this->defaultValue=$value;$this->defaultValueDefinition=null;}}else{throw
new
Exception('Only public or accessible properties can set');}}public
function
setDefaultValue($value){$this->defaultValue=$value;}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionClass){throw
new
InvalidArgumentException(sprintf('The parent reflection object has to be a TokenReflection\ReflectionClass instance, %s given',get_class($parent)));}$this->declaringClassName=$parent->getName();return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseModifiers($tokenStream,$parent)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw
new
RuntimeException(sprintf('Unexpected token %s; T_VARIABLE expected',$tokenStream->getTokenName()));}$this->name=substr($tokenStream->getTokenValue(),1);$tokenStream->skipWhitespaces();return$this;}private
function
parseDefaultValue(Stream$tokenStream){$type=$tokenStream->getType();if(';'
===$type
||
','
===$type){return$this;}if('='
===$type){$tokenStream->skipWhitespaces();}$level=0;while(null
!==($type=$tokenStream->getType())){switch($type){case
',':if(0
!==$level){break;}case
';':break
2;case
')':case
']':case
'}':$level--;break;case
'(':case
'{':case
'[':$level++;}$this->defaultValueDefinition
.=$tokenStream->getTokenValue();$tokenStream->next();}if(','
===$type){$tokenStream->next();}elseif(';'
!==$type){throw
new
RuntimeException('Property definition is not terminated properly');}if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}return$this;}private
function
parseModifiers(Stream$tokenStream,ReflectionClass$class){while(true){switch($tokenStream->getType()){case
T_PUBLIC:case
T_VAR:$this->modifiers
|=
InternalReflectionProperty::IS_PUBLIC;break;case
T_PROTECTED:$this->modifiers
|=
InternalReflectionProperty::IS_PROTECTED;break;case
T_PRIVATE:$this->modifiers
|=
InternalReflectionProperty::IS_PRIVATE;break;case
T_STATIC:$this->modifiers
|=
InternalReflectionProperty::IS_STATIC;break;default:break
2;}$tokenStream->skipWhitespaces();}if(InternalReflectionProperty::IS_STATIC
===$this->modifiers){$this->modifiers
|=
InternalReflectionProperty::IS_PUBLIC;}elseif(0
===$this->modifiers){$parentProperties=$class->getOwnProperties();if(empty($parentProperties)){throw
new
RuntimeException('No access level defined and no previous defining class property present.');}$sibling=array_pop($parentProperties);if($sibling->isPublic()){$this->modifiers=InternalReflectionProperty::IS_PUBLIC;}elseif($sibling->isPrivate()){$this->modifiers=InternalReflectionProperty::IS_PRIVATE;}elseif($sibling->isProtected()){$this->modifiers=InternalReflectionProperty::IS_PROTECTED;}else{throw
new
RuntimeException(sprintf('Property sibling %s has no access level defined.',$sibling->getName()));}if($sibling->isStatic()){$this->modifiers
|=
InternalReflectionProperty::IS_STATIC;}}return$this;}public
static
function
setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public
static
function
getParseValueDefinitions(){return
self::$parseValueDefinitions;}}}

namespace
TokenReflection\Dummy{use
TokenReflection;use
TokenReflection\Broker,TokenReflection\IReflectionClass,TokenReflection\ReflectionBase;use
ReflectionClass
as
InternalReflectionClass,TokenReflection\Exception;class
ReflectionClass
implements
IReflectionClass{const
PACKAGE_NONE='None';private$broker;private$name;public
function
__construct($className,Broker$broker){$this->name=$className;$this->broker=$broker;}public
function
getName(){return$this->name;}public
function
getShortName(){$pos=strrpos($this->name,'\\');return
false
===$pos?$this->name:substr($this->name,$pos+1);}public
function
getBroker(){return$this->broker;}public
function
getPackageName(){return
self::PACKAGE_NONE;}final
public
function
__get($key){return
ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
ReflectionBase::exists($this,$key);}public
function
getFileName(){return
null;}public
function
getStartLine(){return
null;}public
function
getEndLine(){return
null;}public
function
getExtension(){return
null;}public
function
getExtensionName(){return
null;}public
function
isInternal(){return
false;}public
function
isUserDefined(){return
false;}public
function
getSource(){return
'';}public
function
getDocComment(){return
false;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
__toString(){return
'';}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
getConstant($name){throw
new
Exception(sprintf('Constant "%s" is not defined in class "%s"',$name,$this->name),Exception::DOES_NOT_EXIST);}public
function
getConstantReflection($name){return
array();}public
function
getConstants(){return
array();}public
function
getConstantReflections(){return
array();}public
function
getOwnConstantReflections(){return
array();}public
function
getConstructor(){return
null;}public
function
getDestructor(){return
null;}public
function
getDefaultProperties(){return
array();}public
function
getInterfaceNames(){return
array();}public
function
getInterfaces(){return
array();}public
function
getMethod($name){throw
new
Exception(sprintf('There is no method %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public
function
getMethods($filter=null){return
array();}public
function
getModifiers(){return
0;}public
function
getNamespaceName(){return
null;}public
function
getParentClass(){return
null;}public
function
getParentClasses(){return
array();}public
function
getParentClassNameList(){return
array();}public
function
getParentClassName(){return
null;}public
function
getProperties($filter=null){return
array();}public
function
getProperty($name){throw
new
Exception(sprintf('There is no property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public
function
getStaticProperties(){return
array();}public
function
getStaticPropertyValue($name,$default=null){throw
new
Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public
function
getOwnInterfaces(){return
array();}public
function
getOwnInterfaceNames(){return
array();}public
function
getOwnMethods($filter=null){return
array();}public
function
getOwnProperties($filter=null){return
array();}public
function
getOwnConstants(){return
array();}public
function
hasConstant($name){return
false;}public
function
hasOwnConstant($name){return
false;}public
function
hasMethod($name){return
false;}public
function
hasOwnMethod($name){return
false;}public
function
hasProperty($name){return
false;}public
function
hasOwnProperty($name){return
false;}public
function
implementsInterface($interface){if(is_object($interface)){if(!$interface
instanceof
IReflectionClass){throw
new
InvalidArgumentException('Parameter must be a string or an instance of class reflection');}$interfaceName=$interface->getName();if(!$interface->isInterface()){throw
new
RuntimeException(sprintf('%s is not an interface.',$interfaceName));}}return
false;}public
function
inNamespace(){return
false;}public
function
isAbstract(){return
false;}public
function
isFinal(){return
false;}public
function
isTokenized(){return
false;}public
function
isInstance($object){if(!is_object($object)){throw
new
Exception(sprintf('A class instance must be provided (%s set)',gettype($object)));}return$this->name
===
get_class($object)||
is_subclass_of($object,$this->name);}public
function
isInstantiable(){return
false;}public
function
isCloneable(){return
false;}public
function
isInterface(){return
false;}public
function
isException(){return
false;}public
function
isIterateable(){return
false;}public
function
isSubclassOf($class){return
false;}public
function
getDirectSubclasses(){$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return
false;}return
null
===$class->getParentClassName()||!$class->getParentClass()->isSubClassOf($that);});}public
function
getDirectSubclassNames(){return
array_keys($this->getDirectSubclasses());}public
function
getIndirectSubclasses(){$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return
false;}return
null
!==$class->getParentClassName()&&$class->getParentClass()->isSubClassOf($that);});}public
function
getIndirectSubclassNames(){return
array_keys($this->getIndirectSubclasses());}public
function
getDirectImplementers(){if(!$this->isInterface()){return
array();}$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return
false;}return
null
===$class->getParentClassName()||!$class->getParentClass()->implementsInterface($that);});}public
function
getDirectImplementerNames(){return
array_keys($this->getDirectImplementers());}public
function
getIndirectImplementers(){if(!$this->isInterface()){return
array();}$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return
false;}return
null
!==$class->getParentClassName()&&$class->getParentClass()->implementsInterface($this);});}public
function
getIndirectImplementerNames(){return
array_keys($this->getIndirectImplementers());}public
function
newInstance($args){return$this->newInstanceArgs(func_get_args());}public
function
newInstanceArgs(array$args=array()){if(!class_exists($this->name,true)){throw
new
Exception(sprintf('Could not create an instance of class %s; class not found',$this->name));}$reflection=new
InternalReflectionClass($this->name);return$reflection->newInstanceArgs($args);}public
function
setStaticPropertyValue($name,$value){throw
new
Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}}}

namespace
TokenReflection{interface
IReflectionFunction
extends
IReflectionFunctionBase{public
function
isDisabled();public
function
invoke();public
function
invokeArgs(array$args);}}

namespace
TokenReflection{interface
IReflectionMethod
extends
IReflectionFunctionBase{public
function
getDeclaringClass();public
function
getClass();public
function
getDeclaringClassName();public
function
getModifiers();public
function
getPrototype();public
function
invoke($object,$args);public
function
invokeArgs($object,array$args);public
function
isAbstract();public
function
isConstructor();public
function
isDestructor();public
function
isFinal();public
function
isPrivate();public
function
isProtected();public
function
isPublic();public
function
isStatic();public
function
setAccessible($accessible);}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionClass
as
InternalReflectionClass,ReflectionProperty
as
InternalReflectionProperty,ReflectionMethod
as
InternalReflectionMethod;use
RuntimeException,TokenReflection\Exception;class
ReflectionClass
extends
InternalReflectionClass
implements
IReflection,TokenReflection\IReflectionClass{const
PACKAGE_INTERNAL='PHP';private$broker;private$contants;private$methods;private$interfaces;private$properties;public
function
__construct($className,Broker$broker){parent::__construct($className);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}public
function
getParentClass(){$parent=parent::getParentClass();return$parent?self::create($parent,$this->broker):null;}public
function
getParentClassName(){$parent=$this->getParentClass();return$parent?$parent->getName():null;}public
function
getParentClasses(){$broker=$this->broker;return
array_map(function($className)use($broker){return$broker->getClass($className);},$this->getParentClassNameList());}public
function
getConstantReflection($name){if($this->hasConstant($name)){return
new
ReflectionConstant($name,$this->getConstant($name),$this->broker,$this);}throw
new
Exception(sprintf('Constant "%s" is not defined in class "%s"',$name,$this->getName()),Exception::DOES_NOT_EXIST);}public
function
getConstantReflections(){if(null
===$this->contants){$this->contants=array();foreach($this->getConstants()as$name
=>$value){$this->contants[$name]=$this->getConstantReflection($name);}}return$this->contants;}public
function
getOwnConstantReflections(){if(null
===$this->contants){$this->contants=array();foreach($this->getOwnConstants()as$name
=>$value){$this->contants[$name]=$this->getConstantReflection($name);}}return$this->contants;}public
function
getParentClassNameList(){return
class_parents($this->getName());}public
function
getPackageName(){return$this->isInternal()?self::PACKAGE_INTERNAL:TokenReflection\ReflectionClass::PACKAGE_NONE;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getOwnInterfaces(){$parent=$this->getParentClass();return$parent?array_diff_key($this->getInterfaces(),$parent->getInterfaces()):$this->getInterfaces();}public
function
getOwnInterfaceNames(){return
array_keys($this->getOwnInterfaces());}public
function
getOwnMethods($filter=null){$me=$this->getName();return
array_filter($this->getMethods($filter),function(ReflectionMethod$method)use($me){return$method->declaringClass->name
===$me;});}public
function
hasOwnMethod($name){$methods=$this->getOwnMethods();return
isset($methods[$name]);}public
function
getOwnProperties($filter=null){$me=$this->getName();return
array_filter($this->getProperties($filter),function(ReflectionProperty$property)use($me){return$property->declaringClass->name
===$me;});}public
function
hasOwnProperty($name){$properties=$this->getOwnProperties();return
isset($properties[$name]);}public
function
getOwnConstants(){return
array_diff_assoc($this->getConstants(),$this->getParentClass()?$this->getParentClass()->getConstants():array());}public
function
hasOwnConstant($name){$constants=$this->getOwnConstants();return
isset($constants[$name]);}public
function
getProperties($filter=null){if(null
===$this->properties){$broker=$this->broker;$this->properties=array_map(function(InternalReflectionProperty$property)use($broker){return
ReflectionProperty::create($property,$broker);},parent::getProperties());}if(null
===$filter){return$this->properties;}else{return
array_filter($this->properties,function(ReflectionProperty$property)use($filter){return
(bool)($property->getModifiers()&$filter);});}}public
function
getMethods($filter=null){if(null
===$this->methods){$broker=$this->broker;$this->methods=array_map(function(InternalReflectionMethod$method)use($broker){return
ReflectionMethod::create($method,$broker);},parent::getMethods());}if(null
===$filter){return$this->methods;}else{return
array_filter($this->methods,function(ReflectionMethod$method)use($filter){return
(bool)($method->getModifiers()&$filter);});}}public
function
getConstructor(){return
ReflectionMethod::create(parent::getConstructor(),$this->broker);}public
function
getDestructor(){foreach($this->getMethods()as$method){if($method->isDestructor()){return$method;}}}public
function
getExtension(){return
ReflectionExtension::create(parent::getExtension(),$this->broker);}public
function
isCloneable(){if(!$this->isInstantiable()){return
false;}$methods=$this->getMethods();return
isset($methods['__clone'])?$methods['__clone']->isPublic():true;}public
function
isException(){return
'Exception'
===$this->getName()||$this->isSubclassOf('Exception');}public
function
getInterfaces(){if(null
===$this->interfaces){$broker=$this->broker;$this->interfaces=array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$this->getInterfaceNames());}return$this->interfaces;}public
function
implementsInterface($interface){if(is_object($interface)){if($interface
instanceof
InternalReflectionClass
||$interface
instanceof
IReflectionClass){$interfaceName=$interface->getName();}else{throw
new
InvalidArgumentException('Parameter must be a string or an instance of class reflection');}}else{$interfaceName=$interface;}$interfaces=$this->getInterfaces();return
isset($interfaces[$interfaceName]);}public
function
getMethod($name){foreach($this->getMethods()as$method){if($method->getName()===$name){return$method;}}throw
new
Exception(sprintf('There is no method %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public
function
getProperty($name){foreach($this->getProperties()as$property){if($name
===$property->getName()){return$property;}}throw
new
Exception(sprintf('There is no property %s in class %s',$name,$this->getName()),Exception::DOES_NOT_EXIST);}public
function
getStaticProperties(){return$this->getProperties(InternalReflectionProperty::IS_STATIC);}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())&&false
===
strpos($docComment,'@inheritdoc')){return$docComment;}if($parent=$this->getParentClass()){return$parent->getInheritedDocComment();}return
false;}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
isSubclassOf($class){return
in_array($class,$this->getParentClassNameList());}public
function
isTokenized(){return
false;}public
function
isDeprecated(){return
false;}public
function
getDirectSubclasses(){$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return
false;}return
null
===$class->getParentClassName()||!$class->getParentClass()->isSubClassOf($that);});}public
function
getDirectSubclassNames(){return
array_keys($this->getDirectSubclasses());}public
function
getIndirectSubclasses(){$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return
false;}return
null
!==$class->getParentClassName()&&$class->getParentClass()->isSubClassOf($that);});}public
function
getIndirectSubclassNames(){return
array_keys($this->getIndirectSubclasses());}public
function
getDirectImplementers(){if(!$this->isInterface()){return
array();}$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return
false;}return
null
===$class->getParentClassName()||!$class->getParentClass()->implementsInterface($that);});}public
function
getDirectImplementerNames(){return
array_keys($this->getDirectImplementers());}public
function
getIndirectImplementers(){if(!$this->isInterface()){return
array();}$that=$this->name;return
array_filter($this->getBroker()->getClasses(Broker\Backend::INTERNAL_CLASSES|Broker\Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return
false;}return
null
!==$class->getParentClassName()&&$class->getParentClass()->implementsInterface($that);});}public
function
getIndirectImplementerNames(){return
array_keys($this->getIndirectImplementers());}public
static
function
create(Reflector$internalReflection,Broker$broker){if(!$internalReflection
instanceof
InternalReflectionClass){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionClass expected.',get_class($internalReflection)));}return$broker->getClass($internalReflection->getName());}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker,Reflector,TokenReflection\Exception;class
ReflectionConstant
implements
IReflection,TokenReflection\IReflectionConstant{private$broker;private$declaringClassName;private$namespaceName;private$value;private$name;private$userDefined;public
function
__construct($name,$value,Broker$broker,ReflectionClass$parent=null){$this->name=$name;$this->value=$value;$this->broker=$broker;if(null
!==$parent){$this->declaringClassName=$parent->getName();$this->userDefined=$parent->isUserDefined();}else{$declared=get_defined_constants(false);if(!isset($declared[$name])){$this->userDefined=true;}else{$declared=get_defined_constants(true);$this->userDefined=isset($declared['user'][$name]);}}}public
function
isInternal(){return!$this->userDefined;}public
function
isUserDefined(){return$this->userDefined;}public
function
getName(){return$this->name;}public
function
getValue(){return$this->value;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
getDeclaringClass(){if(null
===$this->declaringClassName){return
null;}return$this->getBroker()->getClass($this->declaringClassName);}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getNamespaceName(){return$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public
function
inNamespace(){return
null
!==$this->getNamespaceName();}public
function
getValueDefinition(){return
var_export($this->value,true);}public
function
getDocComment(){return
false;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getStartLine(){return
false;}public
function
getEndLine(){return
false;}public
function
getFileName(){return
false;}public
function
getShortName(){$name=$this->getName();if(null
!==$this->namespaceName
&&$this->namespaceName
!==
ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}public
function
isTokenized(){return
false;}public
function
isDeprecated(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){return
null;}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker,Reflector,ReflectionExtension
as
InternalReflectionExtension;use
RuntimeException;class
ReflectionExtension
extends
InternalReflectionExtension
implements
IReflection,TokenReflection\IReflectionExtension{private$broker;private$classes;private$constants;private$functions;public
function
__construct($name,Broker$broker){parent::__construct($name);$this->broker=$broker;}public
function
isInternal(){return
true;}public
function
isUserDefined(){return
false;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getClasses(){if(null
===$this->classes){$broker=$this->broker;$this->classes=array_map(function($className)use($broker){return$broker->getClass($className);},$this->getClassNames());}return$this->classes;}public
function
getClass($name){$classes=$this->getClasses();return
isset($classes[$name])?$classes[$name]:null;}public
function
getConstantReflections(){if(null
===$this->constants){$broker=$this->broker;$this->constants=array_map(function($constantName)use($broker){return$broker->getConstant($constantName);},array_keys($this->getConstants()));}return$this->constants;}public
function
getConstant($name){$constants=$this->getConstants();return
isset($constants[$name])?$constants[$name]:false;}public
function
getConstantReflection($name){$constants=$this->getConstantReflections();return
isset($constants[$name])?$constants[$name]:null;}public
function
getFunctions(){if(null
===$this->functions){$broker=$this->broker;$this->classes=array_map(function($functionName)use($broker){return$broker->getFunction($functionName);},array_keys(parent::getFunctions()));}return$this->functions;}public
function
getFunctionNames(){return
array_keys($this->getFunctions());}public
function
getFunction($name){$functions=$this->getFunctions();return
isset($functions[$name])?$functions[$name]:null;}public
function
isTokenized(){return
false;}public
function
isDeprecated(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection
instanceof
InternalReflectionExtension){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionExtension expected.',get_class($internalReflection)));}if(!isset($cache[$internalReflection->getName()])){$cache[$internalReflection->getName()]=new
self($internalReflection->getName(),$broker);}return$cache[$internalReflection->getName()];}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionParameter
as
InternalReflectionParameter,ReflectionFunctionAbstract
as
InternalReflectionFunctionAbstract;use
RuntimeException;class
ReflectionParameter
extends
InternalReflectionParameter
implements
IReflection,TokenReflection\IReflectionParameter{private$broker;private$userDefined;public
function
__construct($function,$paramName,Broker$broker,InternalReflectionFunctionAbstract$parent){parent::__construct($function,$paramName);$this->broker=$broker;$this->userDefined=$parent->isUserDefined();}public
function
isInternal(){return!$this->userDefined;}public
function
isUserDefined(){return$this->userDefined;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getDeclaringClass(){$class=parent::getDeclaringClass();return$class?ReflectionClass::create($class,$this->broker):null;}public
function
getDeclaringClassName(){$class=parent::getDeclaringClass();return$class?$class->getName():null;}public
function
getClassName(){return$this->getClass()?$this->getClass()->getName():null;}public
function
getDeclaringFunction(){$class=$this->getDeclaringClass();$function=parent::getDeclaringFunction();if($class){return$class->getMethod($function->getName());}else{return
ReflectionFunction::create($function,$this->broker);}}public
function
getDeclaringFunctionName(){$function=parent::getDeclaringFunction();return$function?$function->getName():$function;}public
function
getDefaultValueDefinition(){$value=$this->getDefaultValue();return
null
===$value?null:var_export($value,true);}public
function
getDocComment(){return
false;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getStartLine(){return
false;}public
function
getEndLine(){return
false;}public
function
isTokenized(){return
false;}public
function
isDeprecated(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection
instanceof
InternalReflectionParameter){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionParameter expected.',get_class($internalReflection)));}$class=$internalReflection->getDeclaringClass();$function=$internalReflection->getDeclaringFunction();$key=$class?$class->getName().'::':'';$key
.=$function->getName().'('.$internalReflection->getName().')';if(!isset($cache[$key])){$cache[$key]=new
self($class?array($class->getName(),$function->getName()):$function->getName(),$internalReflection->getName(),$broker,$function);}return$cache[$key];}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker,Reflector,ReflectionProperty
as
InternalReflectionProperty;use
RuntimeException;class
ReflectionProperty
extends
InternalReflectionProperty
implements
IReflection,TokenReflection\IReflectionProperty{private$broker;public
function
__construct($class,$propertyName,Broker$broker){parent::__construct($class,$propertyName);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getDeclaringClass(){return
ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public
function
getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getDocComment(){return
false;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getStartLine(){return
false;}public
function
getEndLine(){return
false;}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
isInternal(){return$this->getDeclaringClass()->isInternal();}public
function
isUserDefined(){return$this->getDeclaringClass()->isUserDefined();}public
function
getDefaultValue(){$values=$this->getDeclaringClass()->getDefaultProperties();return$values[$this->getName()];}public
function
getDefaultValueDefinition(){$value=$this->getDefaultValue();return
null
===$value?null:var_export($value,true);}public
function
isTokenized(){return
false;}public
function
isDeprecated(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection
instanceof
InternalReflectionProperty){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionProperty expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new
self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}}

namespace
TokenReflection{use
ReflectionClass
as
InternalReflectionClass,ReflectionProperty
as
InternalReflectionProperty;use
RuntimeException,InvalidArgumentException;class
ReflectionClass
extends
ReflectionBase
implements
IReflectionClass{const
PACKAGE_NONE='None';const
IS_INTERFACE=128;const
IMPLEMENTS_INTERFACES=0x80000;private$namespaceName;private$constants=array();private$properties=array();private$methods=array();private$aliases=array();private$modifiers=0;private$parentClassName;private$interfaces=array();protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFileNamespace){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseModifiers($tokenStream)->parseName($tokenStream)->parseParent($tokenStream,$parent)->parseInterfaces($tokenStream,$parent);}protected
function
parseChildren(Stream$tokenStream,IReflection$parent){while(true){switch($tokenStream->getType()){case
'}':$tokenStream->next();break
2;case
null:break
2;case
T_PUBLIC:case
T_PRIVATE:case
T_PROTECTED:case
T_STATIC:case
T_VARIABLE:static$searching=array(T_VARIABLE,T_FUNCTION);$position=$tokenStream->key();while(null
!==($type=$tokenStream->getType($position++))&&!in_array($type,$searching)){$position++;}if(T_VARIABLE
===$type){$property=new
ReflectionProperty($tokenStream,$this->getBroker(),$this);$this->properties[$property->getName()]=$property;break;}case
T_FINAL:case
T_ABSTRACT:case
T_FUNCTION:$method=new
ReflectionMethod($tokenStream,$this->getBroker(),$this);$this->methods[$method->getName()]=$method;break;case
T_CONST:$tokenStream->skipWhitespaces();while($tokenStream->is(T_STRING)){$constant=new
ReflectionConstant($tokenStream,$this->getBroker(),$this);$this->constants[$constant->getName()]=$constant;$tokenStream->skipWhitespaces();}break;case
T_VAR:case
T_VARIABLE:$property=new
ReflectionProperty($tokenStream,$this->getBroker(),$this);$this->properties[$property->getName()]=$property;break;default:$tokenStream->skipWhitespaces();}}return$this;}public
function
getConstant($name){try{return$this->getConstantReflection($name)->getValue();}catch(Exception$e){if($e->getCode()===
Exception::DOES_NOT_EXIST){return
false;}throw$e;}}public
function
getConstantReflection($name){$constants=$this->getConstantReflections();if(isset($constants[$name])){return$constants[$name];}throw
new
Exception(sprintf('Constant "%s" is not defined in class "%s"',$name,$this->name),Exception::DOES_NOT_EXIST);}public
function
getConstants(){return
array_map(function(IReflectionConstant$constant){return$constant->getValue();},$this->getConstantReflections());}public
function
getConstantReflections(){if(null
===$this->parentClassName){return$this->constants;}else{return
array_merge($this->constants,$this->getParentClass()->getConstantReflections());}}public
function
getConstructor(){$methods=$this->getMethods();foreach($methods
as$reflectionMethod){if($reflectionMethod->isConstructor()){return$reflectionMethod;}}return
null;}public
function
getDestructor(){$methods=$this->getMethods();foreach($methods
as$reflectionMethod){if($reflectionMethod->isDestructor()){return$reflectionMethod;}}return
null;}public
function
getDefaultProperties(){$defaults=array();foreach($this->getProperties()as$name
=>$property){if($property
instanceof
ReflectionProperty){$defaults[$name]=$property->getDefaultValue();}}return$defaults;}public
function
getInterfaceNames(){$parentClass=$this->getParentClass();$names=$parentClass?$parentClass->getInterfaceNames():array();foreach(array_reverse($this->interfaces)as$interfaceName){$names=array_merge($names,$this->getBroker()->getClass($interfaceName)->getInterfaceNames());$names[]=$interfaceName;}return
array_unique($names);}public
function
getOwnInterfaceNames(){return
array_reverse($this->interfaces);}public
function
getInterfaces(){$interfaceNames=$this->getInterfaceNames();if(empty($interfaceNames)){return
array();}$broker=$this->getBroker();return
array_combine($interfaceNames,array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$interfaceNames));}public
function
getMethod($name){$methods=$this->getMethods();if(!isset($methods[$name])){throw
new
Exception(sprintf('There is no method %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}return$methods[$name];}public
function
getMethods($filter=null){$methods=$this->getOwnMethods($filter);if(null
!==$this->parentClassName){$methods=array_merge($this->getParentClass()->getMethods($filter),$methods);}return$methods;}public
function
getModifiers(){if(($this->modifiers&InternalReflectionClass::IS_EXPLICIT_ABSTRACT)&&!($this->modifiers&InternalReflectionClass::IS_IMPLICIT_ABSTRACT)){foreach($this->getMethods()as$reflectionMethod){if($reflectionMethod->isAbstract()){$this->modifiers
|=
InternalReflectionClass::IS_IMPLICIT_ABSTRACT;}}}if(count($this->getInterfaceNames())){$this->modifiers
|=
self::IMPLEMENTS_INTERFACES;}return$this->modifiers;}public
function
getNamespaceName(){return$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public
function
getParentClass(){$className=$this->getParentClassName();if(null
===$className){return
null;}return$this->getBroker()->getClass($className);}public
function
getParentClasses(){$parent=$this->getParentClass();if(null
===$parent){return
array();}return
array_merge(array($parent->getName()=>$parent),$parent->getParentClasses());}public
function
getParentClassNameList(){$parent=$this->getParentClass();if(null
===$parent){return
array();}return
array_merge(array($parent->getName()),$parent->getParentClassNameList());}public
function
getParentClassName(){return$this->parentClassName;}public
function
getProperties($filter=null){$properties=$this->getOwnProperties($filter);if(null
!==$this->parentClassName){$properties=array_merge($this->getParentClass()->getProperties($filter),$properties);}return$properties;}public
function
getProperty($name){$properties=$this->getProperties();if(!isset($properties[$name])){throw
new
Exception(sprintf('There is no property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}return$properties[$name];}public
function
getShortName(){$name=$this->getName();if($this->namespaceName
!==
ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}public
function
getStaticProperties(){$defaults=array();foreach($this->getProperties(InternalReflectionProperty::IS_STATIC)as$name
=>$property){if($property
instanceof
ReflectionProperty){$defaults[$name]=$property->getDefaultValue();}}return$defaults;}public
function
getStaticPropertyValue($name,$default=null){$properties=$this->getProperties(InternalReflectionProperty::IS_STATIC);if(!isset($properties[$name])){throw
new
Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}$property=$properties[$name];if(!$property
instanceof
ReflectionProperty){return$property->getDeclaringClass()->getStaticPropertyValue($name,$default);}if(!$property->isPublic()&&!$property->isAccessible()){throw
new
Exception('Only public or accessible properties can return thier values');}return$property->getDefaultValue();}public
function
getOwnInterfaces(){$interfaceNames=$this->getOwnInterfaceNames();if(empty($interfaceNames)){return
array();}$broker=$this->getBroker();return
array_combine($interfaceNames,array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$interfaceNames));}public
function
getOwnMethods($filter=null){$methods=$this->methods;if(null
!==$filter){$methods=array_filter($methods,function(ReflectionMethod$method)use($filter){return
(bool)($method->getModifiers()&$filter);});}return$methods;}public
function
getOwnProperties($filter=null){$properties=$this->properties;if(null
!==$filter){$properties=array_filter($properties,function(ReflectionProperty$property)use($filter){return
(bool)($property->getModifiers()&$filter);});}return$properties;}public
function
getOwnConstants(){return
array_map(function(ReflectionConstant$constant){return$constant->getValue();},$this->constants);}public
function
getOwnConstantReflections(){return$this->constants;}public
function
hasConstant($name){$constants=$this->getConstants();return
isset($constants[$name]);}public
function
hasOwnConstant($name){return
isset($this->constants[$name]);}public
function
hasMethod($name){$methods=$this->getMethods();return
isset($methods[$name]);}public
function
hasOwnMethod($name){return
isset($this->methods[$name]);}public
function
hasProperty($name){$properties=$this->getProperties();return
isset($properties[$name]);}public
function
hasOwnProperty($name){return
isset($this->properties[$name]);}public
function
implementsInterface($interface){if(is_object($interface)){if($interface
instanceof
InternalReflectionClass
||$interface
instanceof
IReflectionClass){$interfaceName=$interface->getName();}else{throw
new
InvalidArgumentException('Parameter must be a string or an instance of class reflection');}if(!$interface->isInterface()){throw
new
RuntimeException(sprintf('%s is not an interface.',$interfaceName));}}else{$reflection=$this->getBroker()->getClass($interface);if(!$reflection->isInterface()){throw
new
RuntimeException(sprintf('%s is not an interface.',$interface));}$interfaceName=$interface;}return
in_array($interfaceName,$this->getInterfaceNames());}public
function
inNamespace(){return
null
!==$this->namespaceName
&&ReflectionNamespace::NO_NAMESPACE_NAME
!==$this->namespaceName;}public
function
isAbstract(){return
(bool)($this->modifiers&InternalReflectionClass::IS_EXPLICIT_ABSTRACT);}public
function
isFinal(){return$this->modifiers
===
InternalReflectionClass::IS_FINAL;}public
function
isInstance($object){if(!is_object($object)){throw
new
Exception(sprintf('A class instance must be provided (%s set)',gettype($object)));}return$this->name
===
get_class($object)||
is_subclass_of($object,$this->name);}public
function
isInstantiable(){if($this->isInterface()||$this->isAbstract()){return
false;}if(null
===($constructor=$this->getConstructor())){return
true;}return$constructor->isPublic();}public
function
isCloneable(){if(!$this->isInstantiable()){return
false;}$methods=$this->getMethods();return
isset($methods['__clone'])?$methods['__clone']->isPublic():true;}public
function
isInterface(){return
self::IS_INTERFACE
===$this->modifiers;}public
function
isException(){return
'Exception'
===$this->name
||$this->isSubclassOf('Exception');}public
function
isIterateable(){return$this->implementsInterface('Traversable');}public
function
isSubclassOf($class){if(is_object($class)){if(!$class
instanceof
InternalReflectionClass
&&!$class
instanceof
IReflectionClass){throw
new
InvalidArgumentException('Parameter must be a string or an instance of class reflection');}$class=$class->getName();}if($class
===$this->parentClassName){return
true;}$parent=$this->getParentClass();return
null
===$parent?false:$parent->isSubclassOf($class);}public
function
getDirectSubclasses(){$that=$this->name;return
array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return
false;}return
null
===$class->getParentClassName()||!$class->getParentClass()->isSubClassOf($that);});}public
function
getDirectSubclassNames(){return
array_keys($this->getDirectSubclasses());}public
function
getIndirectSubclasses(){$that=$this->name;return
array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return
false;}return
null
!==$class->getParentClassName()&&$class->getParentClass()->isSubClassOf($that);});}public
function
getIndirectSubclassNames(){return
array_keys($this->getIndirectSubclasses());}public
function
getDirectImplementers(){if(!$this->isInterface()){return
array();}$that=$this->name;return
array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return
false;}return
null
===$class->getParentClassName()||!$class->getParentClass()->implementsInterface($that);});}public
function
getDirectImplementerNames(){return
array_keys($this->getDirectImplementers());}public
function
getIndirectImplementers(){if(!$this->isInterface()){return
array();}$that=$this->name;return
array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return
false;}return
null
!==$class->getParentClassName()&&$class->getParentClass()->implementsInterface($that);});}public
function
getIndirectImplementerNames(){return
array_keys($this->getIndirectImplementers());}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())&&false
===
strpos($docComment,'@inheritdoc')){return$docComment;}return
null
===$this->parentClassName?false:$this->getParentClass()->getInheritedDocComment();}public
function
newInstance($args){return$this->newInstanceArgs(func_get_args());}public
function
newInstanceArgs(array$args=array()){if(!class_exists($this->name,true)){throw
new
Exception(sprintf('Could not create an instance of class %s; class not found',$this->name));}$reflection=new
InternalReflectionClass($this->name);return$reflection->newInstanceArgs($args);}public
function
setStaticPropertyValue($name,$value){$properties=$this->getProperties(InternalReflectionProperty::IS_STATIC);if(!isset($properties[$name])){throw
new
Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}$reflectionProperty=$properties[$name];if(!$reflectionProperty->isPublic()&&!$reflectionProperty->isAccessible()){throw
new
Exception(sprintf('Cannot set property value; property %s is not public nor set accessible.',$name));}$reflectionProperty->setDefaultValue($value);}private
function
parseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case
null:break
2;case
T_ABSTRACT:$this->modifiers=InternalReflectionClass::IS_EXPLICIT_ABSTRACT;break;case
T_FINAL:$this->modifiers=InternalReflectionClass::IS_FINAL;break;case
T_INTERFACE:$this->modifiers=self::IS_INTERFACE;case
T_CLASS:$tokenStream->skipWhitespaces();break
2;}$tokenStream->skipWhitespaces();}return$this;}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw
new
RuntimeException('The class name could not be determined');}if($this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME){$this->name=$tokenStream->getTokenValue();}else{$this->name=$this->namespaceName.'\\'.$tokenStream->getTokenValue();}$tokenStream->skipWhitespaces();return$this;}private
function
parseParent(Stream$tokenStream,ReflectionBase$parent=null){if(!$tokenStream->is(T_EXTENDS)){return$this;}$tokenStream->skipWhitespaces();$parentClassName='';while(true){switch($tokenStream->getType()){case
T_STRING:case
T_NS_SEPARATOR:$parentClassName
.=$tokenStream->getTokenValue();break;default:break
2;}$tokenStream->next();}$tokenStream->skipWhitespaces();$this->parentClassName=self::resolveClassFQN($parentClassName,$this->aliases,$this->namespaceName);return$this;}public
function
getNamespaceAliases(){return$this->aliases;}private
function
parseInterfaces(Stream$tokenStream,ReflectionBase$parent=null){if(!$tokenStream->is(T_IMPLEMENTS)){return$this;}while(true){$interfaceName='';$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case
T_STRING:case
T_NS_SEPARATOR:$interfaceName
.=$tokenStream->getTokenValue();break;default:break
2;}$tokenStream->skipWhitespaces();}$this->interfaces[]=self::resolveClassFQN($interfaceName,$this->aliases,$this->namespaceName);$type=$tokenStream->getType();if('{'
===$type){break;}elseif(','
!==$type){throw
new
RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}return$this;}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionConstant
extends
ReflectionBase
implements
IReflectionConstant{private$declaringClassName;private$namespaceName;private$value;private$valueDefinition='';protected
function
processParent(IReflection$parent){if($parent
instanceof
ReflectionFileNamespace){$this->namespaceName=$parent->getName();}elseif($parent
instanceof
ReflectionClass){$this->declaringClassName=$parent->getName();}else{throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace or TokenReflection\ReflectionClass, %s given.',get_class($parent)));}return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseName($tokenStream)->parseValue($tokenStream,$parent);}protected
function
parseName(Stream$tokenStream){if($tokenStream->is(T_CONST)){$tokenStream->skipWhitespaces();}if(!$tokenStream->is(T_STRING)){throw
new
RuntimeException('Could not determine the constant name');}if(null
===$this->namespaceName
||$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME){$this->name=$tokenStream->getTokenValue();}else{$this->name=$this->namespaceName.'\\'.$tokenStream->getTokenValue();}$tokenStream->skipWhitespaces();return$this;}protected
function
parseDocComment(Stream$tokenStream){static$skipped=array(T_WHITESPACE,T_COMMENT,T_CONST);$position=$tokenStream->key()-1;while($position>0
&&in_array($tokenStream->getType($position),$skipped)){$position--;}if($tokenStream->is(T_DOC_COMMENT,$position)){$this->docComment=$tokenStream->getTokenValue($position);}else{$this->docComment=false;}return$this;}private
function
parseValue(Stream$tokenStream,IReflection$parent){if(!$tokenStream->is('=')){throw
new
RuntimeException('Could not find the value definition start');}$tokenStream->skipWhitespaces();static$acceptedStrings,$acceptedTokens;if(null
===$acceptedStrings){$acceptedStrings=array_flip(array('true','false','null'));$acceptedTokens=array_flip(array('-','+',T_STRING,T_CONSTANT_ENCAPSED_STRING,T_DNUMBER,T_LNUMBER,T_DOUBLE_COLON));}$evalValue=true;while(null
!==($type=$tokenStream->getType())){$value=$tokenStream->getTokenValue();if(!isset($acceptedTokens[$type])){break;}elseif($tokenStream->is(T_STRING)&&!isset($acceptedStrings[strtolower($value)])){$evalValue=false;}$this->valueDefinition
.=$value;$tokenStream->next();}if(null
!==$type
&&(','
===$value
||
';'
===$value)){$this->valueDefinition=trim($this->valueDefinition);}else{throw
new
RuntimeException(sprintf('Invalid value definition: "%s".',$this->valueDefinition));}if($evalValue){$this->value=eval(sprintf('return %s;',$this->valueDefinition));}else{if('\\'
!==$this->valueDefinition{0}){$namespaceName=$this->namespaceName?:$parent->getNamespaceName();if($pos=strpos($this->valueDefinition,'::')){$className=substr($this->valueDefinition,0,$pos);$this->valueDefinition=ReflectionBase::resolveClassFQN($className,$parent->getNamespaceAliases(),$namespaceName).substr($this->valueDefinition,$pos);}elseif(ReflectionNamespace::NO_NAMESPACE_NAME
!==$namespaceName){$this->valueDefinition=$namespaceName.'\\'.$this->valueDefinition;}}}return$this;}public
function
getValueDefinition(){return$this->valueDefinition;}public
function
getValue(){if(null
===$this->value
&&'null'
!==
strtolower($this->valueDefinition)){if($position=strpos($this->valueDefinition,'::')){$className=substr($this->valueDefinition,0,$position);$constantName=substr($this->valueDefinition,$position+2);$this->value=$this->getBroker()->getClass($className)->getConstant($constantName);}else{$constant=$this->getBroker()->getConstant($this->valueDefinition);$this->value=$constant?$constant->getValue():null;}}return$this->value;}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getDeclaringClass(){if(null
===$this->declaringClassName){return
null;}return$this->getBroker()->getClass($this->declaringClassName);}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getNamespaceName(){return$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public
function
inNamespace(){return
null
!==$this->getNamespaceName();}public
function
getShortName(){$name=$this->getName();if(null
!==$this->namespaceName
&&$this->namespaceName
!==
ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionFileNamespace
extends
ReflectionBase{private$aliases=array();private$classes=array();private$functions=array();private$constants=array();public
function
getClasses(){return$this->classes;}public
function
getFunctions(){return$this->functions;}public
function
getConstants(){return$this->constants;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getAliases(){return$this->aliases;}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFile){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFile, %s given.',get_class($parent)));}return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseName($tokenStream)->parseAliases($tokenStream);}protected
function
parseChildren(Stream$tokenStream,IReflection$parent){static$skipped;if(null
===$skipped){$skipped=array_flip(array(T_WHITESPACE,T_COMMENT,T_DOC_COMMENT));}$level=1;while(true){switch($tokenStream->getType()){case
'{':$level++;$tokenStream->skipWhitespaces();break;case
'}':$level--;$tokenStream->skipWhitespaces();break$level>0?1:2;case
null:case
T_NAMESPACE:break
2;case
T_ABSTRACT:case
T_FINAL:case
T_CLASS:case
T_INTERFACE:$class=new
ReflectionClass($tokenStream,$this->getBroker(),$this);$this->classes[$class->getName()]=$class;break;case
T_CONST:$tokenStream->skipWhitespaces();while($tokenStream->is(T_STRING)){$constant=new
ReflectionConstant($tokenStream,$this->getBroker(),$this);$this->constants[$constant->getName()]=$constant;$tokenStream->skipWhitespaces();}break;case
T_FUNCTION:$position=$tokenStream->key()+1;while(isset($skipped[$type=$tokenStream->getType($position)])){$position++;}if('('
===$type){$tokenStream
->seek($position)->findMatchingBracket()->skipWhiteSpaces();if($tokenStream->is(T_USE)){$tokenStream
->skipWhitespaces()->findMatchingBracket()->skipWhitespaces();}$tokenStream
->findMatchingBracket()->skipWhitespaces();continue;}$function=new
ReflectionFunction($tokenStream,$this->getBroker(),$this);$this->functions[$function->getName()]=$function;break;default:$tokenStream->skipWhitespaces();}}return$this;}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_NAMESPACE)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;return$this;}$tokenStream->skipWhitespaces();$name='';while(true){switch($tokenStream->getType()){case
T_STRING:case
T_NS_SEPARATOR:$name
.=$tokenStream->getTokenValue();break;default:
break
2;}$tokenStream->next();}$name=ltrim($name,'\\');if(empty($name)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;}else{$this->name=$name;$tokenStream->skipWhitespaces();}return$this;}private
function
parseAliases(Stream$tokenStream){if(ReflectionNamespace::NO_NAMESPACE_NAME
===$this->name){return$this;}$aliases=array();while(true){if($tokenStream->is(T_USE)){while(true){$namespaceName='';$alias=null;$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case
T_STRING:case
T_NS_SEPARATOR:$namespaceName
.=$tokenStream->getTokenValue();break;default:break
2;}$tokenStream->next();}$namespaceName=ltrim($namespaceName,'\\');if(empty($namespaceName)){throw
new
RuntimeException('Imported namespace name could not be determined');}elseif('\\'
===
substr($namespaceName,-1)){throw
new
RuntimeException(sprintf('Invalid namespace name "%s"',$namespaceName));}$tokenStream->skipWhitespaces(false);if($tokenStream->is(T_AS)){$tokenStream->skipWhitespaces();if(!$tokenStream->is(T_STRING)){throw
new
RuntimeException(sprintf('The imported namespace "%s" seems aliased but the alias name could not be determined',$namespaceName));}$alias=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();}else{if(false
!==($pos=strrpos($namespaceName,'\\'))){$alias=substr($namespaceName,$pos+1);}else{$alias=$namespaceName;}}if(isset($aliases[$alias])){throw
new
RuntimeException(sprintf('Namespace alias "%s" already defined',$alias));}$aliases[$alias]=$namespaceName;$type=$tokenStream->getType();if(';'
===$type){$tokenStream->skipWhitespaces();continue
2;}elseif(','
===$type){continue;}throw
new
RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}else{break;}}$this->aliases=$aliases;return$this;}}}

namespace
TokenReflection{use
RuntimeException;abstract
class
ReflectionFunctionBase
extends
ReflectionBase
implements
IReflectionFunctionBase{protected$modifiers=0;private$staticVariables=array();protected$namespaceName;private$returnsReference=false;private$parameters=array();public
function
getModifiers(){return$this->modifiers;}public
function
inNamespace(){return
null
!==$this->getNamespaceName();}public
function
getNamespaceName(){return$this->namespaceName
===
ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public
function
getNumberOfParameters(){return
count($this->parameters);}public
function
getNumberOfRequiredParameters(){$count=0;array_walk($this->parameters,function(ReflectionParameter$parameter)use(&$count){if(!$parameter->isOptional()){$count++;}});return$count;}public
function
getParameters(){return$this->parameters;}public
function
getParameter($parameter){if(is_numeric($parameter)){if(isset($this->parameters[$parameter])){return$this->parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($this->parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getStaticVariables(){return$this->staticVariables;}public
function
isClosure(){return
false;}public
function
returnsReference(){return$this->returnsReference;}public
function
getName(){if(null
!==$this->namespaceName
&&ReflectionNamespace::NO_NAMESPACE_NAME
!==$this->namespaceName){return$this->namespaceName.'\\'.$this->name;}return$this->name;}public
function
getShortName(){return$this->name;}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw
new
RuntimeException('Could not determine the method/function name');}$this->name=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();return$this;}final
protected
function
parseChildren(Stream$tokenStream,IReflection$parent){return$this
->parseParameters($tokenStream)->parseStaticVariables($tokenStream);}final
protected
function
parseParameters(Stream$tokenStream){if(!$tokenStream->is('(')){throw
new
RuntimeException('Could not determine parameters start');}static$accepted;if(null
===$accepted){$accepted=array_flip(array(T_NS_SEPARATOR,T_STRING,T_ARRAY,T_VARIABLE,'&'));}$tokenStream->skipWhitespaces();while(null
!==($type=$tokenStream->getType())&&')'
!==$type){if(isset($accepted[$type])){$parameter=new
ReflectionParameter($tokenStream,$this->getBroker(),$this);$this->parameters[]=$parameter;}if($tokenStream->is(')')){break;}$tokenStream->skipWhitespaces();}$tokenStream->skipWhitespaces();return$this;}final
protected
function
parseStaticVariables(Stream$tokenStream){$type=$tokenStream->getType();if('{'
===$type){$tokenStream->findMatchingBracket()->next();}elseif(';'
===$type){$tokenStream->next();}else{throw
new
RuntimeException(sprintf('Unexpected token found: %s',$type));}return$this;}final
protected
function
parseReturnsReference(Stream$tokenStream){if(!$tokenStream->is(T_FUNCTION)){throw
new
RuntimeException('Could not find the function keyword.');}$tokenStream->skipWhitespaces();$type=$tokenStream->getType();if('&'
===$type){$this->returnsReference=true;$tokenStream->skipWhitespaces();}elseif(T_STRING
!==$type){throw
new
RuntimeException(sprintf('Unexpected token type: %s',$tokenStream->getTokenName()));}return$this;}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionNamespace
implements
IReflectionNamespace{const
NO_NAMESPACE_NAME='no-namespace';private$broker;private$name;private$classes=array();private$functions=array();private$constants=array();public
function
__construct($name,Broker$broker){$this->name=$name;$this->broker=$broker;}public
function
getClass($className){$className=ltrim($className,'\\');if(false
===
strpos($className,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$className=$this->getName().'\\'.$className;}if(!isset($this->classes[$className])){throw
new
Exception(sprintf('Class %s does not exist',$className),Exception::DOES_NOT_EXIST);}return$this->classes[$className];}public
function
getClasses(){return$this->classes;}public
function
getClassNames(){return
array_keys($this->classes);}public
function
getClassShortNames(){return
array_map(function(IReflectionClass$class){return$class->getShortName();},$this->classes);}public
function
getFunction($functionName){$functionName=ltrim($functionName,'\\');if(false
===
strpos($functionName,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$functionName=$this->getName().'\\'.$functionName;}if(!isset($this->functions[$functionName])){throw
new
Exception(sprintf('Function %s does not exist',$functionName),Exception::DOES_NOT_EXIST);}return$this->functions[$functionName];}public
function
getFunctions(){return$this->functions;}public
function
getFunctionNames(){return
array_keys($this->functions);}public
function
getFunctionShortNames(){return
array_map(function(IReflectionFunction$function){return$function->getShortName();},$this->functions);}public
function
getConstant($constantName){$constantName=ltrim($constantName,'\\');if(false
===
strpos($constantName,'\\')&&self::NO_NAMESPACE_NAME
!==$this->getName()){$constantName=$this->getName().'\\'.$constantName;}if(!isset($this->constants[$constantName])){throw
new
Exception(sprintf('Constant %s does not exist',$constantName),Exception::DOES_NOT_EXIST);}return$this->constants[$constantName];}public
function
getConstants(){return$this->constants;}public
function
getConstantNames(){return
array_keys($this->constants);}public
function
getConstantShortNames(){return
array_map(function(IReflectionConstant$constant){return$constant->getShortName();},$this->constants);}public
function
getName(){return$this->name;}public
function
getBroker(){return$this->broker;}public
function
isTokenized(){return
true;}public
function
isInternal(){return
false;}public
function
isUserDefined(){return
true;}public
function
addFileNamespace(ReflectionFileNamespace$namespace){$classes=$namespace->getClasses();foreach($this->classes
as$className
=>$reflection){if(isset($classes[$className])){throw
new
RuntimeException(sprintf('Class %s was defined multiple times',$className));}}$this->classes=array_merge($this->classes,$classes);$functions=$namespace->getFunctions();foreach($this->functions
as$functionName
=>$reflection){if(isset($functions[$functionName])){throw
new
RuntimeException(sprintf('Function %s was defined multiple times',$functionName));}}$this->functions=array_merge($this->functions,$functions);$constants=$namespace->getConstants();foreach($this->constants
as$constantName
=>$reflection){if(isset($constants[$constantName])){throw
new
RuntimeException(sprintf('Constant %s was defined multiple times',$constantName));}}$this->constants=array_merge($this->constants,$constants);}public
function
__toString(){return
'';}public
static
function
export($argument,$return=false){return
ReflectionBase::export($argument,$return);}final
public
function
__get($key){return
ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
ReflectionBase::exists($this,$key);}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionParameter
extends
ReflectionBase
implements
IReflectionParameter{CONST
ARRAY_CONSTRAINT='array';private
static$parseValueDefinitions=false;private$valueConstraint;private$originalValueConstraint;private$defaultValueDefinition;private$defaultValue;private$declaringClassName;private$declaringFunctionName;private$passedByReference=false;private$isOptional;private$position;public
function
allowsNull(){return
true;}public
function
getClass(){$name=$this->getClassName();if(null
===$name){return
null;}return$this->getBroker()->getClass($name);}public
function
getClassName(){if($this->isArray()){return
null;}if(null
===$this->valueConstraint
&&null
!==$this->originalValueConstraint){if(null
!==$this->declaringClassName){$parent=$this->getDeclaringClass();if(null
===$parent
||!$parent->isTokenized()){throw
new
Exception(sprintf('Could not load class %s reflection',$this->declaringClassName));}}else{$parent=$this->getDeclaringFunction();if(null
===$parent
||!$parent->isTokenized()){throw
new
Exception(sprintf('Could not load function %s reflection',$this->declaringFunctionName));}}$this->valueConstraint=self::resolveClassFQN($this->originalValueConstraint,$parent->getNamespaceAliases(),$parent->getNamespaceName());}return$this->valueConstraint;}public
function
getOriginalClassName(){return!$this->isArray()?ltrim($this->originalValueConstraint,'\\'):null;}public
function
getDeclaringClass(){return
null
===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getDeclaringFunction(){if(null
!==$this->declaringClassName){$class=$this->getBroker()->getClass($this->declaringClassName);if(null
!==$class){return$class->getMethod($this->declaringFunctionName);}}else{return$this->getBroker()->getFunction($this->declaringFunctionName);}}public
function
getDeclaringFunctionName(){return$this->declaringFunctionName;}public
function
getDefaultValue(){if(null
===$this->defaultValueDefinition){throw
new
Exception('Property has no default value',Exception::DOES_NOT_EXIST);}return$this->defaultValue;}public
function
getDefaultValueDefinition(){return$this->defaultValueDefinition;}public
function
getPosition(){return$this->position;}public
function
isArray(){return$this->valueConstraint
===
self::ARRAY_CONSTRAINT;}public
function
isDefaultValueAvailable(){return
null
!==$this->defaultValueDefinition;}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
isOptional(){if(null
===$this->isOptional){$function=$this->getDeclaringFunction();if(null
===$function){throw
new
RuntimeException(sprintf('Could not get the declaring function %s reflection.',$this->declaringFunctionName));}$this->isOptional=true;foreach(array_slice($function->getParameters(),$this->position)as$reflectionParameter){if(!$reflectionParameter->isDefaultValueAvailable()){$this->isOptional=false;break;}}}return$this->isOptional;}public
function
isPassedByReference(){return$this->passedByReference;}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFunctionBase){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFunctionBase descendant class, %s given.',get_class($parent)));}$this->declaringFunctionName=$parent->getName();$this->position=count($parent->getParameters());if($parent
instanceof
ReflectionMethod){$this->declaringClassName=$parent->getDeclaringClassName();}return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseConstraint($tokenStream)->parsePassedByReference($tokenStream)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected
function
parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw
new
RuntimeException('Could not find the parameter variable definition');}$this->name=substr($tokenStream->getTokenValue(),1);$tokenStream->skipWhitespaces();return$this;}private
function
parseConstraint(Stream$tokenStream){$type=$tokenStream->getType();if(T_ARRAY
===$type){$this->valueConstraint=self::ARRAY_CONSTRAINT;$this->originalValueConstraint=self::ARRAY_CONSTRAINT;$tokenStream->skipWhitespaces();}elseif(T_STRING
===$type
||
T_NS_SEPARATOR
===$type){$className='';do{$className
.=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();$type=$tokenStream->getType();}while(T_STRING
===$type
||
T_NS_SEPARATOR
===$type);if(''
===
ltrim($className,'\\')){throw
new
RuntimeException('Invalid value constraint definition');}$this->originalValueConstraint=$className;}return$this;}private
function
parsePassedByReference(Stream$tokenStream){if($tokenStream->is('&')){$this->passedByReference=true;$tokenStream->skipWhitespaces();}return$this;}private
function
parseDefaultValue(Stream$tokenStream){if($tokenStream->is('=')){$tokenStream->skipWhitespaces();$level=0;while(null
!==($type=$tokenStream->getType())){switch($type){case
')':if(0
===$level){break
2;}case
'}':case
']':$level--;break;case
'(':case
'{':case
'[':$level++;break;case
',':if(0
===$level){break
2;}}$this->defaultValueDefinition
.=$tokenStream->getTokenValue();$tokenStream->next();}if(','
===$type){$tokenStream->next();}elseif(')'
!==$type){throw
new
RuntimeException('Parameter default value definition is not terminated properly');}if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}}return$this;}public
static
function
setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public
static
function
getParseValueDefinitions(){return
self::$parseValueDefinitions;}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionFunction
as
InternalReflectionFunction,ReflectionParameter
as
InternalReflectionParameter;use
RuntimeException;class
ReflectionFunction
extends
InternalReflectionFunction
implements
IReflection,TokenReflection\IReflectionFunction{private$broker;private$parameters;public
function
__construct($functionName,Broker$broker){parent::__construct($functionName);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getExtension(){return
ReflectionExtension::create(parent::getExtension(),$this->broker);}public
function
getParameters(){if(null
===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return
ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public
function
getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
isTokenized(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){if(!$internalReflection
instanceof
InternalReflectionFunction){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionFunction expected.',get_class($internalReflection)));}return$broker->getFunction($internalReflection->getName());}}}

namespace
TokenReflection\Php{use
TokenReflection;use
TokenReflection\Broker;use
Reflector,ReflectionMethod
as
InternalReflectionMethod,ReflectionParameter
as
InternalReflectionParameter;use
RuntimeException;class
ReflectionMethod
extends
InternalReflectionMethod
implements
IReflection,TokenReflection\IReflectionMethod{private$broker;private$parameters;public
function
__construct($class,$methodName,Broker$broker){parent::__construct($class,$methodName);$this->broker=$broker;}public
function
getBroker(){return$this->broker;}final
public
function
__get($key){return
TokenReflection\ReflectionBase::get($this,$key);}final
public
function
__isset($key){return
TokenReflection\ReflectionBase::exists($this,$key);}public
function
getParameters(){if(null
===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return
ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if($parent
&&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return
false;}public
function
getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw
new
Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters
as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw
new
Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public
function
getDeclaringClass(){return
ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public
function
getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getAnnotations(){return
array();}public
function
getAnnotation($name){return
null;}public
function
hasAnnotation($name){return
false;}public
function
getPrototype(){return
self::create(parent::getPrototype(),$this->broker);}public
function
isTokenized(){return
false;}public
static
function
create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection
instanceof
InternalReflectionMethod){throw
new
RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionMethod expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new
self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}}

namespace
TokenReflection{use
RuntimeException;class
ReflectionFunction
extends
ReflectionFunctionBase
implements
IReflectionFunction{private$aliases=array();public
function
isDisabled(){return$this->hasAnnotation('disabled');}public
function
getInheritedDocComment(){return$this->getDocComment();}public
function
invoke(){return$this->invokeArgs(func_get_args());}public
function
invokeArgs(array$args=array()){if(!function_exists($this->getName())){throw
new
RuntimeException('Function %s is not defined in the current scope.',$this->getName());}return
call_user_func_array($this->getName(),$args);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseReturnsReference($tokenStream)->parseName($tokenStream);}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionFileNamespace){throw
new
RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return
parent::processParent($parent);}public
function
getNamespaceAliases(){return$this->aliases;}}}

namespace
TokenReflection{use
ReflectionMethod
as
InternalReflectionMethod,ReflectionClass
as
InternalReflectionClass;use
RuntimeException,InvalidArgumentException;class
ReflectionMethod
extends
ReflectionFunctionBase
implements
IReflectionMethod{const
IS_IMPLEMENTED_ABSTRACT=0x08;const
ACCESS_LEVEL_CHANGED=0x800;const
IS_CONSTRUCTOR=0x2000;const
IS_DESTRUCTOR=0x4000;const
IS_CLONE=0x8000;const
IS_ALLOWED_STATIC=0x10000;private$declaringClassName;private$accessible=false;public
function
getDeclaringClass(){return
null
===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public
function
getDeclaringClassName(){return$this->declaringClassName;}public
function
getClass(){return$this->getDeclaringClassName();}public
function
getInheritedDocComment(){if(false
!==($docComment=$this->getDocComment())&&false
===
strpos($docComment,'@inheritdoc')){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null
!==$parent
&&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return
false;}public
function
getModifiers(){if(!($this->modifiers&(self::ACCESS_LEVEL_CHANGED|self::IS_IMPLEMENTED_ABSTRACT))){$declaringClass=$this->getDeclaringClass();if(null
===$declaringClass){throw
new
RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null
!==$parentClass){$parentClassMethods=$parentClass->getMethods();if($this->modifiers&InternalReflectionMethod::IS_PUBLIC){if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::ACCESS_LEVEL_CHANGED|InternalReflectionMethod::IS_PRIVATE))){$this->modifiers
|=
self::ACCESS_LEVEL_CHANGED;}}if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::IS_IMPLEMENTED_ABSTRACT|InternalReflectionMethod::IS_ABSTRACT))){$this->modifiers
|=
self::IS_IMPLEMENTED_ABSTRACT;}}}return$this->modifiers;}public
function
invoke($object,$args){$params=func_get_args();return$this->invokeArgs(array_shift($params),$params);}public
function
invokeArgs($object,array$args=array()){$declaringClass=$this->getDeclaringClass();if(!$declaringClass->isInstance($object)){throw
new
InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return
call_user_func_array(array($object,$this->getName()),$args);}elseif($this->isAccessible()){$refClass=new
InternalReflectionClass($object);$refMethod=$refClass->getMethod($this->name);$refMethod->setAccessible(true);$value=$refMethod->invokeArgs($object,$args);$refMethod->setAccessible(false);return$value;}throw
new
RuntimeException('Only public methods can be invoked.');}public
function
isAbstract(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_ABSTRACT);}public
function
isConstructor(){return
(bool)($this->modifiers&self::IS_CONSTRUCTOR);}public
function
isDestructor(){return
(bool)($this->modifiers&self::IS_DESTRUCTOR);}public
function
isFinal(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_FINAL);}public
function
isPrivate(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PRIVATE);}public
function
isProtected(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PROTECTED);}public
function
isPublic(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_PUBLIC);}public
function
isStatic(){return
(bool)($this->modifiers&InternalReflectionMethod::IS_STATIC);}public
function
setAccessible($accessible){$this->accessible=$accessible;}public
function
isAccessible(){return$this->accessible;}public
function
getPrototype(){$declaring=$this->getDeclaringClass();if($declaring->getParentClassName()){foreach($declaring->getParentClass()->getMethods()as$method){if($method->getName()===$this->name
&&!$method->isPrivate()){return$method;}}}foreach($declaring->getInterfaces()as$interface){if($interface->hasMethod($this->name)){return$interface->getMethod($this->name);}}throw
new
Exception('Method has no prototype',Exception::DOES_NOT_EXIST);}protected
function
processParent(IReflection$parent){if(!$parent
instanceof
ReflectionClass){throw
new
RuntimeException('The parent object has to be either an instance of TokenReflection\ReflectionClass or NULL, %s given.',get_class($parent));}$this->declaringClassName=$parent->getName();return
parent::processParent($parent);}protected
function
parse(Stream$tokenStream,IReflection$parent){return$this
->parseBaseModifiers($tokenStream)->parseReturnsReference($tokenStream)->parseName($tokenStream)->parseInternalModifiers($parent);}private
function
parseBaseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case
T_ABSTRACT:$this->modifiers
|=
InternalReflectionMethod::IS_ABSTRACT;break;case
T_FINAL:$this->modifiers
|=
InternalReflectionMethod::IS_FINAL;break;case
T_PUBLIC:$this->modifiers
|=
InternalReflectionMethod::IS_PUBLIC;break;case
T_PRIVATE:$this->modifiers
|=
InternalReflectionMethod::IS_PRIVATE;break;case
T_PROTECTED:$this->modifiers
|=
InternalReflectionMethod::IS_PROTECTED;break;case
T_STATIC:$this->modifiers
|=
InternalReflectionMethod::IS_STATIC;break;case
T_FUNCTION:case
null:break
2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&(InternalReflectionMethod::IS_PRIVATE|InternalReflectionMethod::IS_PROTECTED))){$this->modifiers
|=
InternalReflectionMethod::IS_PUBLIC;}return$this;}private
function
parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct'
===$name
||($class
&&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers
|=
self::IS_CONSTRUCTOR;}elseif('__destruct'
===$name){$this->modifiers
|=
self::IS_DESTRUCTOR;}elseif('__clone'
===$name){$this->modifiers
|=
self::IS_CLONE;}static$notAllowed;if(null
===$notAllowed){$notAllowed=array_flip(array('__clone','__tostring','__get','__set','__isset','__unset'));}if(!$this->isConstructor()&&!$this->isDestructor()&&!isset($notAllowed[$name])){$this->modifiers
|=
self::IS_ALLOWED_STATIC;}return$this;}}}