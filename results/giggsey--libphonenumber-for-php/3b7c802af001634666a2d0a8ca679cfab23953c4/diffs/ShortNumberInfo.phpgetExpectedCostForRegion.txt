    public function getExpectedCostForRegion($shortNumber, $regionDialingFrom)
    {
        // Note that regionDialingFrom may be null, in which case phoneMetadata will also be null.
        $phoneMetadata = $this->getMetadataForRegion($regionDialingFrom);
        if ($phoneMetadata === null) {
            return ShortNumberCost::UNKNOWN_COST;
        }

        // The cost categories are tested in order of decreasing expense, since if for some reason the
        // patterns overlap the most expensive matching cost category should be returned.
        if ($this->phoneUtil->isNumberMatchingDesc($shortNumber, $phoneMetadata->getPremiumRate())) {
            return ShortNumberCost::PREMIUM_RATE;
        }

        if ($this->phoneUtil->isNumberMatchingDesc($shortNumber, $phoneMetadata->getStandardRate())) {
            return ShortNumberCost::STANDARD_RATE;
        }

        if ($this->phoneUtil->isNumberMatchingDesc($shortNumber, $phoneMetadata->getTollFree())) {
            return ShortNumberCost::TOLL_FREE;
        }

        if ($this->isEmergencyNumber($shortNumber, $regionDialingFrom)) {
            // Emergency numbers are implicitly toll-free.
            return ShortNumberCost::TOLL_FREE;
        }

        return ShortNumberCost::UNKNOWN_COST;
    }

    /**
     * Gets the expected cost category of a short number (however, nothing is implied about its
     * validity). If the country calling code is unique to a region, this method behaves exactly the
     * same as {@link #getExpectedCostForRegion(String, String)}. However, if the country calling
     * code is shared by multiple regions, then it returns the highest cost in the sequence
     * PREMIUM_RATE, UNKNOWN_COST, STANDARD_RATE, TOLL_FREE. The reason for the position of
     * UNKNOWN_COST in this order is that if a number is UNKNOWN_COST in one region but STANDARD_RATE
     * or TOLL_FREE in another, its expected cost cannot be estimated as one of the latter since it
     * might be a PREMIUM_RATE number.
     *
     * For example, if a number is STANDARD_RATE in the US, but TOLL_FREE in Canada, the expected cost
     * returned by this method will be STANDARD_RATE, since the NANPA countries share the same country
     * calling code.
     *
     * Note: If the region from which the number is dialed is known, it is highly preferable to call
     * {@link #getExpectedCostForRegion(String, String)} instead.
     *
     * @param $number PhoneNumber the short number for which we want to know the expected cost category
     * @return int the highest expected cost category of the short number in the region(s) with the given
     *     country calling code
     */
||||||||    public function getExpectedCostForRegion($number, $regionDialingFrom)
    {
        // Note that regionDialingFrom may be null, in which case phoneMetadata will also be null.
        $phoneMetadata = $this->getMetadataForRegion($regionDialingFrom);
        if ($phoneMetadata === null) {
            return ShortNumberCost::UNKNOWN_COST;
        }

        if ($number instanceof PhoneNumber) {
            $shortNumber = $this->getNationalSignificantNumber($number);
        } else {
            /**
             * @deprecated Anyone who was using it and passing in a string with whitespace (or other
             *             formatting characters) would have been getting the wrong result. You should parse
             *             the string to PhoneNumber and use the method
             *             {@code #getExpectedCostForRegion(PhoneNumber, String)}. This method will be
             *             removed in the next release.
             */
            $shortNumber = $number;
        }

        // The cost categories are tested in order of decreasing expense, since if for some reason the
        // patterns overlap the most expensive matching cost category should be returned.
        if ($this->matchesPossibleNumberAndNationalNumber($shortNumber, $phoneMetadata->getPremiumRate())) {
            return ShortNumberCost::PREMIUM_RATE;
        }

        if ($this->matchesPossibleNumberAndNationalNumber($shortNumber, $phoneMetadata->getStandardRate())) {
            return ShortNumberCost::STANDARD_RATE;
        }

        if ($this->matchesPossibleNumberAndNationalNumber($shortNumber, $phoneMetadata->getTollFree())) {
            return ShortNumberCost::TOLL_FREE;
        }

        if ($this->isEmergencyNumber($shortNumber, $regionDialingFrom)) {
            // Emergency numbers are implicitly toll-free.
            return ShortNumberCost::TOLL_FREE;
        }

        return ShortNumberCost::UNKNOWN_COST;
    }

    /**
     * Gets the expected cost category of a short number (however, nothing is implied about its
     * validity). If the country calling code is unique to a region, this method behaves exactly the
     * same as {@link #getExpectedCostForRegion(PhoneNumber, String)}. However, if the country calling
     * code is shared by multiple regions, then it returns the highest cost in the sequence
     * PREMIUM_RATE, UNKNOWN_COST, STANDARD_RATE, TOLL_FREE. The reason for the position of
     * UNKNOWN_COST in this order is that if a number is UNKNOWN_COST in one region but STANDARD_RATE
     * or TOLL_FREE in another, its expected cost cannot be estimated as one of the latter since it
     * might be a PREMIUM_RATE number.
     *
     * <p>
     * For example, if a number is STANDARD_RATE in the US, but TOLL_FREE in Canada, the expected
     * cost returned by this method will be STANDARD_RATE, since the NANPA countries share the same
     * country calling code.
     * </p>
     *
     * Note: If the region from which the number is dialed is known, it is highly preferable to call
     * {@link #getExpectedCostForRegion(PhoneNumber, String)} instead.
     *
     * @param PhoneNumber $number the short number for which we want to know the expected cost category
     * @return int the highest expected cost category of the short number in the region(s) with the given
     *     country calling code
     */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_CONST))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_PROP
                    (AST_VAR))
                (
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_PROP
                    (AST_VAR))
                (
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_PROP
                    (AST_VAR))
                (
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_RETURN
        (AST_CLASS_CONST
            (SCALAR))))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULTNO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_CONST))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_INSTANCEOF
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR))))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_VAR)))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR))))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_IF
        (AST_IF_ELEM
            (AST_METHOD_CALL
                (AST_VAR)
                (
                    (AST_VAR)
                    (AST_VAR)))
            (
                (AST_RETURN
                    (AST_CLASS_CONST
                        (SCALAR))))))
    (AST_RETURN
        (AST_CLASS_CONST
            (SCALAR))))