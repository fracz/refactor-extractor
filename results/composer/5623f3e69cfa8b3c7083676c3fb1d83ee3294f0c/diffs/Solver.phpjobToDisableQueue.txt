    protected function jobToDisableQueue(array $job, array $disableQueue)
    {
        switch ($job['cmd']) {
            case 'install':
                foreach ($job['packages'] as $package) {
                    if ($this->installed === $package->getRepository()) {
                        $disableQueue[] = array('type' => 'update', 'package' => $package);
                    }

      /* all job packages obsolete * /
      qstart = q->count;
      pass = 0;
      memset(&omap, 0, sizeof(omap));
      FOR_JOB_SELECT(p, pp, select, what)
    {
      Id p2, pp2;

      if (pass == 1)
        map_grow(&omap, installed->end - installed->start);
      s = pool->solvables + p;
      if (s->obsoletes)
        {
          Id obs, *obsp;
          obsp = s->repo->idarraydata + s->obsoletes;
          while ((obs = *obsp++) != 0)
        FOR_PROVIDES(p2, pp2, obs)
          {
            Solvable *ps = pool->solvables + p2;
            if (ps->repo != installed)
              continue;
            if (!pool->obsoleteusesprovides && !pool_match_nevr(pool, ps, obs))
              continue;
            if (pool->obsoleteusescolors && !pool_colormatch(pool, s, ps))
              continue;
            if (pass)
              MAPSET(&omap, p2 - installed->start);
            else
              queue_push2(q, DISABLE_UPDATE, p2);
          }
        }
      FOR_PROVIDES(p2, pp2, s->name)
        {
          Solvable *ps = pool->solvables + p2;
          if (ps->repo != installed)
        continue;
          if (!pool->implicitobsoleteusesprovides && ps->name != s->name)
        continue;
          if (pool->obsoleteusescolors && !pool_colormatch(pool, s, ps))
        continue;
          if (pass)
            MAPSET(&omap, p2 - installed->start);
              else
            queue_push2(q, DISABLE_UPDATE, p2);
        }
      if (pass)
        {
          for (i = j = qstart; i < q->count; i += 2)
        {
          if (MAPTST(&omap, q->elements[i + 1] - installed->start))
            {
              MAPCLR(&omap, q->elements[i + 1] - installed->start);
              q->elements[j + 1] = q->elements[i + 1];
              j += 2;
            }
        }
          queue_truncate(q, j);
        }
      if (q->count == qstart)
        break;
      pass++;
    }
      if (omap.size)
        map_free(&omap);

      if (qstart == q->count)
    return;     /* nothing to prune * /
      if ((set & (SOLVER_SETEVR | SOLVER_SETARCH | SOLVER_SETVENDOR)) == (SOLVER_SETEVR | SOLVER_SETARCH | SOLVER_SETVENDOR))
    return;     /* all is set */

      /* now that we know which installed packages are obsoleted check each of them * /
      for (i = j = qstart; i < q->count; i += 2)
    {
      Solvable *is = pool->solvables + q->elements[i + 1];
      FOR_JOB_SELECT(p, pp, select, what)
        {
          int illegal = 0;
          s = pool->solvables + p;
          if ((set & SOLVER_SETEVR) != 0)
        illegal |= POLICY_ILLEGAL_DOWNGRADE;    /* ignore * /
          if ((set & SOLVER_SETARCH) != 0)
        illegal |= POLICY_ILLEGAL_ARCHCHANGE;   /* ignore * /
          if ((set & SOLVER_SETVENDOR) != 0)
        illegal |= POLICY_ILLEGAL_VENDORCHANGE; /* ignore * /
          illegal = policy_is_illegal(solv, is, s, illegal);
          if (illegal && illegal == POLICY_ILLEGAL_DOWNGRADE && (set & SOLVER_SETEV) != 0)
        {
          /* it's ok if the EV is different * /
          if (evrcmp(pool, is->evr, s->evr, EVRCMP_COMPARE_EVONLY) != 0)
            illegal = 0;
        }
          if (illegal)
        break;
        }
      if (!p)
        {
          /* no package conflicts with the update rule * /
          /* thus keep the DISABLE_UPDATE * /
          q->elements[j + 1] = q->elements[i + 1];
          j += 2;
        }
    }
      queue_truncate(q, j);
      return;*/
                }
            break;

            case 'remove':
                foreach ($job['packages'] as $package) {
                    if ($this->installed === $package->getRepository()) {
                        $disableQueue[] = array('type' => 'update', 'package' => $package);
                    }
                }
            break;
        }

        return $disableQueue;
    }

||||||||    protected function jobToDisableQueue(array $job, array $disableQueue)
    {
        switch ($job['cmd']) {
            case 'install':
                foreach ($job['packages'] as $package) {
                    if (isset($this->installedPackageMap[$package->getId()])) {
                        $disableQueue[] = array('type' => 'update', 'package' => $package);
                    }

      /* all job packages obsolete * /
      qstart = q->count;
      pass = 0;
      memset(&omap, 0, sizeof(omap));
      FOR_JOB_SELECT(p, pp, select, what)
    {
      Id p2, pp2;

      if (pass == 1)
        map_grow(&omap, installed->end - installed->start);
      s = pool->solvables + p;
      if (s->obsoletes)
        {
          Id obs, *obsp;
          obsp = s->repo->idarraydata + s->obsoletes;
          while ((obs = *obsp++) != 0)
        FOR_PROVIDES(p2, pp2, obs)
          {
            Solvable *ps = pool->solvables + p2;
            if (ps->repo != installed)
              continue;
            if (!pool->obsoleteusesprovides && !pool_match_nevr(pool, ps, obs))
              continue;
            if (pool->obsoleteusescolors && !pool_colormatch(pool, s, ps))
              continue;
            if (pass)
              MAPSET(&omap, p2 - installed->start);
            else
              queue_push2(q, DISABLE_UPDATE, p2);
          }
        }
      FOR_PROVIDES(p2, pp2, s->name)
        {
          Solvable *ps = pool->solvables + p2;
          if (ps->repo != installed)
        continue;
          if (!pool->implicitobsoleteusesprovides && ps->name != s->name)
        continue;
          if (pool->obsoleteusescolors && !pool_colormatch(pool, s, ps))
        continue;
          if (pass)
            MAPSET(&omap, p2 - installed->start);
              else
            queue_push2(q, DISABLE_UPDATE, p2);
        }
      if (pass)
        {
          for (i = j = qstart; i < q->count; i += 2)
        {
          if (MAPTST(&omap, q->elements[i + 1] - installed->start))
            {
              MAPCLR(&omap, q->elements[i + 1] - installed->start);
              q->elements[j + 1] = q->elements[i + 1];
              j += 2;
            }
        }
          queue_truncate(q, j);
        }
      if (q->count == qstart)
        break;
      pass++;
    }
      if (omap.size)
        map_free(&omap);

      if (qstart == q->count)
    return;     /* nothing to prune * /
      if ((set & (SOLVER_SETEVR | SOLVER_SETARCH | SOLVER_SETVENDOR)) == (SOLVER_SETEVR | SOLVER_SETARCH | SOLVER_SETVENDOR))
    return;     /* all is set */

      /* now that we know which installed packages are obsoleted check each of them * /
      for (i = j = qstart; i < q->count; i += 2)
    {
      Solvable *is = pool->solvables + q->elements[i + 1];
      FOR_JOB_SELECT(p, pp, select, what)
        {
          int illegal = 0;
          s = pool->solvables + p;
          if ((set & SOLVER_SETEVR) != 0)
        illegal |= POLICY_ILLEGAL_DOWNGRADE;    /* ignore * /
          if ((set & SOLVER_SETARCH) != 0)
        illegal |= POLICY_ILLEGAL_ARCHCHANGE;   /* ignore * /
          if ((set & SOLVER_SETVENDOR) != 0)
        illegal |= POLICY_ILLEGAL_VENDORCHANGE; /* ignore * /
          illegal = policy_is_illegal(solv, is, s, illegal);
          if (illegal && illegal == POLICY_ILLEGAL_DOWNGRADE && (set & SOLVER_SETEV) != 0)
        {
          /* it's ok if the EV is different * /
          if (evrcmp(pool, is->evr, s->evr, EVRCMP_COMPARE_EVONLY) != 0)
            illegal = 0;
        }
          if (illegal)
        break;
        }
      if (!p)
        {
          /* no package conflicts with the update rule * /
          /* thus keep the DISABLE_UPDATE * /
          q->elements[j + 1] = q->elements[i + 1];
          j += 2;
        }
    }
      queue_truncate(q, j);
      return;*/
                }
            break;

            case 'remove':
                foreach ($job['packages'] as $package) {
                    if (isset($this->installedPackageMap[$package->getId()])) {
                        $disableQueue[] = array('type' => 'update', 'package' => $package);
                    }
                }
            break;
        }

        return $disableQueue;
    }

||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_SWITCH
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_FOREACH
                        (AST_DIM
                            (AST_VAR)
                            (SCALAR))
                        (AST_VAR)
                        (NULL)
                        (
                            (AST_IF
                                (AST_IF_ELEM
                                    (AST_BINARY_OP
                                        (AST_PROP
                                            (AST_VAR))
                                        (AST_METHOD_CALL
                                            (AST_VAR)))
                                    (
                                        (AST_ASSIGN
                                            (AST_DIM
                                                (AST_VAR)
                                                (NULL))
                                            (AST_ARRAY
                                                (AST_ARRAY_ELEM
                                                    (SCALAR)
                                                    (SCALAR))
                                                (AST_ARRAY_ELEM
                                                    (AST_VAR)
                                                    (SCALAR)))))))))
                    (AST_BREAK
                        (NULL))))
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_FOREACH
                        (AST_DIM
                            (AST_VAR)
                            (SCALAR))
                        (AST_VAR)
                        (NULL)
                        (
                            (AST_IF
                                (AST_IF_ELEM
                                    (AST_BINARY_OP
                                        (AST_PROP
                                            (AST_VAR))
                                        (AST_METHOD_CALL
                                            (AST_VAR)))
                                    (
                                        (AST_ASSIGN
                                            (AST_DIM
                                                (AST_VAR)
                                                (NULL))
                                            (AST_ARRAY
                                                (AST_ARRAY_ELEM
                                                    (SCALAR)
                                                    (SCALAR))
                                                (AST_ARRAY_ELEM
                                                    (AST_VAR)
                                                    (SCALAR)))))))))
                    (AST_BREAK
                        (NULL))))))
    (AST_RETURN
        (AST_VAR)))||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(PARAM_TYPENO_PARAM_DEFAULTPARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_SWITCH
        (AST_DIM
            (AST_VAR)
            (SCALAR))
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_FOREACH
                        (AST_DIM
                            (AST_VAR)
                            (SCALAR))
                        (AST_VAR)
                        (NULL)
                        (
                            (AST_IF
                                (AST_IF_ELEM
                                    (AST_ISSET
                                        (AST_DIM
                                            (AST_PROP
                                                (AST_VAR))
                                            (AST_METHOD_CALL
                                                (AST_VAR))))
                                    (
                                        (AST_ASSIGN
                                            (AST_DIM
                                                (AST_VAR)
                                                (NULL))
                                            (AST_ARRAY
                                                (AST_ARRAY_ELEM
                                                    (SCALAR)
                                                    (SCALAR))
                                                (AST_ARRAY_ELEM
                                                    (AST_VAR)
                                                    (SCALAR)))))))))
                    (AST_BREAK
                        (NULL))))
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_FOREACH
                        (AST_DIM
                            (AST_VAR)
                            (SCALAR))
                        (AST_VAR)
                        (NULL)
                        (
                            (AST_IF
                                (AST_IF_ELEM
                                    (AST_ISSET
                                        (AST_DIM
                                            (AST_PROP
                                                (AST_VAR))
                                            (AST_METHOD_CALL
                                                (AST_VAR))))
                                    (
                                        (AST_ASSIGN
                                            (AST_DIM
                                                (AST_VAR)
                                                (NULL))
                                            (AST_ARRAY
                                                (AST_ARRAY_ELEM
                                                    (SCALAR)
                                                    (SCALAR))
                                                (AST_ARRAY_ELEM
                                                    (AST_VAR)
                                                    (SCALAR)))))))))
                    (AST_BREAK
                        (NULL))))))
    (AST_RETURN
        (AST_VAR)))