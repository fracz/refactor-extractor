    public function getMinTimeArchivedProcessed()
    {
        $startTimestampUTC = $this->getDateStart()->getTimestamp();
        $endTimestampUTC = strtotime($this->getEndDatetimeUTC());
        $now = time();

        $this->temporaryArchive = false;
        // if the current archive is a DAY and if it's today,
        // we set this minDatetimeArchiveProcessedUTC that defines the lifetime value of today's archive
        if ($this->getPeriod()->getNumberOfSubperiods() == 0
            && ($startTimestampUTC <= $now && $endTimestampUTC > $now)
        ) {
            $this->temporaryArchive = true;
            $minDatetimeArchiveProcessedUTC = $now - self::getTodayArchiveTimeToLive();
            // see #1150; if new archives are not triggered from the browser,
            // we still want to try and return the latest archive available for today (rather than return nothing)
            if ($this->isArchivingDisabled()) {
                return false;
            }
        } // - if the period we are looking for is finished, we look for a ts_archived that
        //   is greater than the last day of the archive
        elseif ($endTimestampUTC <= $now) {
            $minDatetimeArchiveProcessedUTC = $endTimestampUTC;
        } // - if the period we're looking for is not finished, we look for a recent enough archive
        else {
            $this->temporaryArchive = true;

            // We choose to only look at archives that are newer than the specified timeout
            $minDatetimeArchiveProcessedUTC = $now - self::getTodayArchiveTimeToLive();

            // However, if archiving is disabled for this request, we shall
            // accept any archive that was processed today after 00:00:01 this morning
            if ($this->isArchivingDisabled()) {
                $timezone = $this->getSite()->getTimezone();
                $minDatetimeArchiveProcessedUTC = Piwik_Date::factory(Piwik_Date::factory('now', $timezone)->getDateStartUTC())->setTimezone($timezone)->getTimestamp();
            }
        }
        return $minDatetimeArchiveProcessedUTC;
    }

    /**
     * This method returns the idArchive ; if necessary, it triggers the archiving process.
     *
     * If the archive was not processed yet, it will launch the archiving process.
     * If the current archive needs sub-archives (eg. a month archive needs all the days archive)
     *  it will recursively launch the archiving (using this loadArchive() on the sub-periods)
     *
     * @return int|false The idarchive of the archive, false if the archive is not archived yet
     */
||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_METHOD_CALL
                (AST_VAR))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_METHOD_CALL
                    (AST_VAR)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL))
    (AST_ASSIGN
        (AST_PROP
            (AST_VAR))
        (AST_CONST))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (AST_METHOD_CALL
                        (AST_METHOD_CALL
                            (AST_VAR)))
                    (SCALAR))
                (AST_BINARY_OP
                    (AST_BINARY_OP
                        (AST_VAR)
                        (AST_VAR))
                    (AST_BINARY_OP
                        (AST_VAR)
                        (AST_VAR))))
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_CONST))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (AST_VAR)
                        (AST_STATIC_CALL)))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (
                            (AST_RETURN
                                (AST_CONST)))))))
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_VAR)
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_VAR))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (AST_CONST))
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_BINARY_OP
                        (AST_VAR)
                        (AST_STATIC_CALL)))
                (AST_IF
                    (AST_IF_ELEM
                        (AST_METHOD_CALL
                            (AST_VAR))
                        (
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_METHOD_CALL
                                    (AST_METHOD_CALL
                                        (AST_VAR))))
                            (AST_ASSIGN
                                (AST_VAR)
                                (AST_METHOD_CALL
                                    (AST_METHOD_CALL
                                        (AST_STATIC_CALL
                                            (
                                                (AST_METHOD_CALL
                                                    (AST_STATIC_CALL
                                                        (
                                                            (SCALAR)
                                                            (AST_VAR))))))
                                        (
                                            (AST_VAR)))))))))))
    (AST_RETURN
        (AST_VAR)))||||||||