    public static function getCacheGeneral()
    {
        $cache = self::getInstance();
        $cacheId = 'general';

        if (($cacheContent = $cache->get($cacheId)) !== false) {
            return $cacheContent;
        }

        Tracker::initCorePiwikInTrackerMode();
        $cacheContent = array(
            'isBrowserTriggerEnabled' => Rules::isBrowserTriggerEnabled(),
            'lastTrackerCronRun'      => Option::get('lastTrackerCronRun'),
        );

        /**
         * Triggered before the [general tracker cache](/guides/all-about-tracking#the-tracker-cache)
         * is saved to disk. This event can be used to add extra content to the cache.
         *
         * Data that is used during tracking but is expensive to compute/query should be
         * cached to keep tracking efficient. One example of such data are options
         * that are stored in the piwik_option table. Querying data for each tracking
         * request means an extra unnecessary database query for each visitor action. Using
         * a cache solves this problem.
         *
         * **Example**
         *
         *     public function setTrackerCacheGeneral(&$cacheContent)
         *     {
         *         $cacheContent['MyPlugin.myCacheKey'] = Option::get('MyPlugin_myOption');
         *     }
         *
         * @param array &$cacheContent Array of cached data. Each piece of data must be
         *                             mapped by name.
         */
        Piwik::postEvent('Tracker.setTrackerCacheGeneral', array(&$cacheContent));
        self::setCacheGeneral($cacheContent);
        Common::printDebug("General tracker cache was re-created.");
        return $cacheContent;
    }

    /**
     * Store data in general (global cache)
     *
     * @param mixed $value
     * @return bool
     */
||||||||    public static function getCacheGeneral()
    {
        $cache   = self::getInstance();
        $cacheId = 'general';

        $cacheContent = $cache->get($cacheId);

        if (false !== $cacheContent) {
            return $cacheContent;
        }

        Tracker::initCorePiwikInTrackerMode();
        $cacheContent = array(
            'isBrowserTriggerEnabled' => Rules::isBrowserTriggerEnabled(),
            'lastTrackerCronRun'      => Option::get('lastTrackerCronRun'),
        );

        /**
         * Triggered before the [general tracker cache](/guides/all-about-tracking#the-tracker-cache)
         * is saved to disk. This event can be used to add extra content to the cache.
         *
         * Data that is used during tracking but is expensive to compute/query should be
         * cached to keep tracking efficient. One example of such data are options
         * that are stored in the piwik_option table. Querying data for each tracking
         * request means an extra unnecessary database query for each visitor action. Using
         * a cache solves this problem.
         *
         * **Example**
         *
         *     public function setTrackerCacheGeneral(&$cacheContent)
         *     {
         *         $cacheContent['MyPlugin.myCacheKey'] = Option::get('MyPlugin_myOption');
         *     }
         *
         * @param array &$cacheContent Array of cached data. Each piece of data must be
         *                             mapped by name.
         */
        Piwik::postEvent('Tracker.setTrackerCacheGeneral', array(&$cacheContent));
        self::setCacheGeneral($cacheContent);
        Common::printDebug("General tracker cache was re-created.");
        return $cacheContent;
    }

    /**
     * Store data in general (global cache)
     *
     * @param mixed $value
     * @return bool
     */
||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL))
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_VAR))))
                (AST_CONST))
            (
                (AST_RETURN
                    (AST_VAR)))))
    (AST_STATIC_CALL)
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_STATIC_CALL)
                (SCALAR))
            (AST_ARRAY_ELEM
                (AST_STATIC_CALL
                    (
                        (SCALAR)))
                (SCALAR))))
    (AST_STATIC_CALL
        (
            (SCALAR)
            (AST_ARRAY
                (AST_ARRAY_ELEM
                    (AST_VAR)
                    (NULL)))))
    (AST_STATIC_CALL
        (
            (AST_VAR)))
    (AST_STATIC_CALL
        (
            (SCALAR)))
    (AST_RETURN
        (AST_VAR)))||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_ASSIGN
        (AST_VAR)
        (AST_STATIC_CALL))
    (AST_ASSIGN
        (AST_VAR)
        (SCALAR))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (AST_VAR))
            (
                (AST_RETURN
                    (AST_VAR)))))
    (AST_STATIC_CALL)
    (AST_ASSIGN
        (AST_VAR)
        (AST_ARRAY
            (AST_ARRAY_ELEM
                (AST_STATIC_CALL)
                (SCALAR))
            (AST_ARRAY_ELEM
                (AST_STATIC_CALL
                    (
                        (SCALAR)))
                (SCALAR))))
    (AST_STATIC_CALL
        (
            (SCALAR)
            (AST_ARRAY
                (AST_ARRAY_ELEM
                    (AST_VAR)
                    (NULL)))))
    (AST_STATIC_CALL
        (
            (AST_VAR)))
    (AST_STATIC_CALL
        (
            (SCALAR)))
    (AST_RETURN
        (AST_VAR)))