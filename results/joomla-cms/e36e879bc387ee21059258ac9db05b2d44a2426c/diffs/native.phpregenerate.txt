||||||||	public function regenerate($destroy = false, $lifetime = null)
	{
		if (null !== $lifetime)
		{
			ini_set('session.cookie_lifetime', $lifetime);
		}

		$return = session_regenerate_id($destroy);

		// Workaround for https://bugs.php.net/bug.php?id=61470 as suggested by David Grudl
		session_write_close();

		if (isset($_SESSION))
		{
			$backup = $_SESSION;
			session_start();
			$_SESSION = $backup;
		}
		else
		{
			session_start();
		}

		return $return;
	}

	/**
	 * Force the session to be saved and closed.
	 *
	 * This method must invoke session_write_close() unless this interface is used for a storage object design for unit or functional testing where
	 * a real PHP session would interfere with testing, in which case it should actually persist the session data if required.
	 *
	 * @return  void
	 *
	 * @see     session_write_close()
	 * @since   3.5
	 * @throws  RuntimeException  If the session is saved without being started, or if the session is already closed.
	 */
||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPEPARAM_DEFAULTNO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (AST_VAR))
            (
                (AST_CALL
                    (
                        (SCALAR)
                        (AST_VAR))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_CALL
            (
                (AST_VAR))))
    (AST_CALL)
    (AST_IF
        (AST_IF_ELEM
            (AST_ISSET
                (AST_VAR))
            (
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_VAR))
                (AST_CALL)
                (AST_ASSIGN
                    (AST_VAR)
                    (AST_VAR))))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_CALL))))
    (AST_RETURN
        (AST_VAR)))