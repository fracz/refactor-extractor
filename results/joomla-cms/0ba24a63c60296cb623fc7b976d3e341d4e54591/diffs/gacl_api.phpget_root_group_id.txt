||||||||	function get_root_group_id($group_type='ARO') {

		$this->debug_text('get_root_group_id(): Group Type: '. $group_type);

		switch (strtolower($group_type)) {
			case 'axo':
				$table = $this->_db_table_prefix .'axo_groups';
				break;
			case 'aro':
				$table = $this->_db_table_prefix .'aro_groups';
				break;
			default:
				$this->debug_text('get_root_group_id(): Invalid Group Type: '. $group_type);
				return FALSE;
		}

		$query = 'SELECT id FROM '. $table .' WHERE parent_id=0';
		$rs = $this->db->Execute($query);

		if (!is_object($rs)) {
			$this->debug_db('get_root_group_id');
			return FALSE;
		}

		$row_count = $rs->RecordCount();

		switch ($row_count) {
			case 1:
				$row = $rs->FetchRow();
				// Return the ID.
				return $row[0];
			case 0:
				$this->debug_text('get_root_group_id(): Returned 0 rows, you do not have a root group defined yet.');
				return FALSE;
		}

		$this->debug_text('get_root_group_id(): Returned '. $row_count .' rows, can only return one. Your tree is very broken.');
		return FALSE;
	}

	/*======================================================================*\
		Function:	map_path_to_root()
		Purpose:	Maps a unique path to root to a specific group. Each group can only have
						one path to root.
	\*======================================================================*/
	/** REMOVED **/
	/*======================================================================*\
		Function:	put_path_to_root()
		Purpose:	Writes the unique path to root to the database. There should really only be
						one path to root for each level "deep" the groups go. If the groups are branched
						10 levels deep, there should only be 10 unique path to roots. These of course
						overlap each other more and more the closer to the root/trunk they get.
	\*======================================================================*/
	/** REMOVED **/
	/*======================================================================*\
		Function:	clean_path_to_root()
		Purpose:	Cleans up any paths that are not being used.
	\*======================================================================*/
	/** REMOVED **/
	/*======================================================================*\
		Function:	get_path_to_root()
		Purpose:	Generates the path to root for a given group.
	\*======================================================================*/
	/** REMOVED **/

	/**
	 * add_group()
	 *
	 * Inserts a group, defaults to be on the "root" branch.
	 *
	 * Since v3.3.x you can only create one group with Parent_ID=0
	 * So, its a good idea to create a "Virtual Root" group with Parent_ID=0
	 * Then assign other groups to that.
	 *
	 * @return int New Group ID # if successful, FALSE if otherwise.
	 *
	 * @param string Group Value
	 * @param string Group Name
	 * @param int Parent Group ID #
	 * @param string Group Type, either 'ARO' or 'AXO'
	 */
||||||||||||||||HAS_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPEPARAM_DEFAULT)
(
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))))
    (AST_SWITCH
        (AST_CALL
            (
                (AST_VAR)))
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_ASSIGN
                        (AST_VAR)
                        (AST_BINARY_OP
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR)))
                    (AST_BREAK
                        (NULL))))
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_ASSIGN
                        (AST_VAR)
                        (AST_BINARY_OP
                            (AST_PROP
                                (AST_VAR))
                            (SCALAR)))
                    (AST_BREAK
                        (NULL))))
            (AST_SWITCH_CASE
                (NULL)
                (
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (AST_BINARY_OP
                                (SCALAR)
                                (AST_VAR))))
                    (AST_RETURN
                        (AST_CONST))))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_BINARY_OP
            (AST_BINARY_OP
                (SCALAR)
                (AST_VAR))
            (SCALAR)))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_PROP
                (AST_VAR))
            (
                (AST_VAR))))
    (AST_IF
        (AST_IF_ELEM
            (AST_UNARY_OP
                (AST_CALL
                    (
                        (AST_VAR))))
            (
                (AST_METHOD_CALL
                    (AST_VAR)
                    (
                        (SCALAR)))
                (AST_RETURN
                    (AST_CONST)))))
    (AST_ASSIGN
        (AST_VAR)
        (AST_METHOD_CALL
            (AST_VAR)))
    (AST_SWITCH
        (AST_VAR)
        (AST_SWITCH_LIST
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_ASSIGN
                        (AST_VAR)
                        (AST_METHOD_CALL
                            (AST_VAR)))
                    (AST_RETURN
                        (AST_DIM
                            (AST_VAR)
                            (SCALAR)))))
            (AST_SWITCH_CASE
                (SCALAR)
                (
                    (AST_METHOD_CALL
                        (AST_VAR)
                        (
                            (SCALAR)))
                    (AST_RETURN
                        (AST_CONST))))))
    (AST_METHOD_CALL
        (AST_VAR)
        (
            (AST_BINARY_OP
                (AST_BINARY_OP
                    (SCALAR)
                    (AST_VAR))
                (SCALAR))))
    (AST_RETURN
        (AST_CONST)))