||||||||  function privErrorReset()
  {
if (PCLZIP_ERROR_EXTERNAL == 1) {
  PclErrorReset();
}
else {
  $this->error_code = 1;
  $this->error_string = '';
}
  }
  // --------------------------------------------------------------------------------

  }
  // End of class
  // --------------------------------------------------------------------------------

  // --------------------------------------------------------------------------------
  // Function : PclZipUtilPathReduction()
  // Description :
  // Parameters :
  // Return Values :
  // --------------------------------------------------------------------------------
  function PclZipUtilPathReduction($p_dir)
  {
//--(MAGIC-PclTrace)--//PclTraceFctStart(__FILE__, __LINE__, "PclZipUtilPathReduction", "dir='$p_dir'");
$v_result = "";

// ----- Look for not empty path
if ($p_dir != "")
{
  // ----- Explode path by directory names
  $v_list = explode("/", $p_dir);

  // ----- Study directories from last to first
  for ($i=sizeof($v_list)-1; $i>=0; $i--)
  {
// ----- Look for current path
if ($v_list[$i] == ".")
{
  // ----- Ignore this directory
  // Should be the first $i=0, but no check is done
}
else if ($v_list[$i] == "..")
{
  // ----- Ignore it and ignore the $i-1
  $i--;
}
else if (($v_list[$i] == "") && ($i!=(sizeof($v_list)-1)) && ($i!=0))
{
  // ----- Ignore only the double '//' in path,
  // but not the first and last '/'
}
else
{
  $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?"/".$v_result:"");
}
  }
}

// ----- Return
//--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, $v_result);
return $v_result;
  }
  // --------------------------------------------------------------------------------

  // --------------------------------------------------------------------------------
  // Function : PclZipUtilPathInclusion()
  // Description :
  //	This function indicates if the path $p_path is under the $p_dir tree. Or,
  //	said in an other way, if the file or sub-dir $p_path is inside the dir
  //	$p_dir.
  //	The function indicates also if the path is exactly the same as the dir.
  //	This function supports path with duplicated '/' like '//', but does not
  //	support '.' or '..' statements.
  // Parameters :
  // Return Values :
  //	0 if $p_path is not inside directory $p_dir
  //	1 if $p_path is inside directory $p_dir
  //	2 if $p_path is exactly the same as $p_dir
  // --------------------------------------------------------------------------------
  function PclZipUtilPathInclusion($p_dir, $p_path)
  {
//--(MAGIC-PclTrace)--//PclTraceFctStart(__FILE__, __LINE__, "PclZipUtilPathInclusion", "dir='$p_dir', path='$p_path'");
$v_result = 1;

// ----- Explode dir and path by directory separator
$v_list_dir = explode("/", $p_dir);
$v_list_dir_size = sizeof($v_list_dir);
$v_list_path = explode("/", $p_path);
$v_list_path_size = sizeof($v_list_path);

// ----- Study directories paths
$i = 0;
$j = 0;
while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Working on dir($i)='".$v_list_dir[$i]."' and path($j)='".$v_list_path[$j]."'");

  // ----- Look for empty dir (path reduction)
  if ($v_list_dir[$i] == '') {
$i++;
continue;
  }
  if ($v_list_path[$j] == '') {
$j++;
continue;
  }

  // ----- Compare the items
  if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {
//--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Items ($i,$j) are different");
$v_result = 0;
  }

  // ----- Next items
  $i++;
  $j++;
}

// ----- Look if everything seems to be the same
if ($v_result) {
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Look for tie break");
  // ----- Skip all the empty items
  while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;
  while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Looking on dir($i)='".($i < $v_list_dir_size?$v_list_dir[$i]:'')."' and path($j)='".($j < $v_list_path_size?$v_list_path[$j]:'')."'");

  if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {
// ----- There are exactly the same
$v_result = 2;
  }
  else if ($i < $v_list_dir_size) {
// ----- The path is shorter than the dir
$v_result = 0;
  }
}

// ----- Return
//--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, $v_result);
return $v_result;
  }
  // --------------------------------------------------------------------------------

  // --------------------------------------------------------------------------------
  // Function : PclZipUtilCopyBlock()
  // Description :
  // Parameters :
  //	$p_mode : read/write compression mode
  // 0 : src & dest normal
  // 1 : src gzip, dest normal
  // 2 : src normal, dest gzip
  // 3 : src & dest gzip
  // Return Values :
  // --------------------------------------------------------------------------------
  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)
  {
//--(MAGIC-PclTrace)--//PclTraceFctStart(__FILE__, __LINE__, "PclZipUtilCopyBlock", "size=$p_size, mode=$p_mode");
$v_result = 1;

if ($p_mode==0)
{
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Src offset before read :".(@ftell($p_src)));
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Dest offset before write :".(@ftell($p_dest)));
  while ($p_size != 0)
  {
$v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
//--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 4, "Read $v_read_size bytes");
$v_buffer = @fread($p_src, $v_read_size);
@fwrite($p_dest, $v_buffer, $v_read_size);
$p_size -= $v_read_size;
  }
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Src offset after read :".(@ftell($p_src)));
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Dest offset after write :".(@ftell($p_dest)));
}
else if ($p_mode==1)
{
  while ($p_size != 0)
  {
$v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
//--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 4, "Read $v_read_size bytes");
$v_buffer = @gzread($p_src, $v_read_size);
@fwrite($p_dest, $v_buffer, $v_read_size);
$p_size -= $v_read_size;
  }
}
else if ($p_mode==2)
{
  while ($p_size != 0)
  {
$v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
//--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 4, "Read $v_read_size bytes");
$v_buffer = @fread($p_src, $v_read_size);
@gzwrite($p_dest, $v_buffer, $v_read_size);
$p_size -= $v_read_size;
  }
}
else if ($p_mode==3)
{
  while ($p_size != 0)
  {
$v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
//--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 4, "Read $v_read_size bytes");
$v_buffer = @gzread($p_src, $v_read_size);
@gzwrite($p_dest, $v_buffer, $v_read_size);
$p_size -= $v_read_size;
  }
}

// ----- Return
//--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, $v_result);
return $v_result;
  }
  // --------------------------------------------------------------------------------

  // --------------------------------------------------------------------------------
  // Function : PclZipUtilRename()
  // Description :
  //	This function tries to do a simple rename() function. If it fails, it
  //	tries to copy the $p_src file in a new $p_dest file and then unlink the
  //	first one.
  // Parameters :
  //	$p_src : Old filename
  //	$p_dest : New filename
  // Return Values :
  //	1 on success, 0 on failure.
  // --------------------------------------------------------------------------------
  function PclZipUtilRename($p_src, $p_dest)
  {
//--(MAGIC-PclTrace)--//PclTraceFctStart(__FILE__, __LINE__, "PclZipUtilRename", "source=$p_src, destination=$p_dest");
$v_result = 1;

// ----- Try to rename the files
if (!@rename($p_src, $p_dest)) {
  //--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Fail to rename file, try copy+unlink");

  // ----- Try to copy & unlink the src
  if (!@copy($p_src, $p_dest)) {
//--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Fail to copy file");
$v_result = 0;
  }
  else if (!@unlink($p_src)) {
//--(MAGIC-PclTrace)--//PclTraceFctMessage(__FILE__, __LINE__, 5, "Fail to unlink old filename");
$v_result = 0;
  }
}

// ----- Return
//--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, $v_result);
return $v_result;
  }
  // --------------------------------------------------------------------------------

  // --------------------------------------------------------------------------------
  // Function : PclZipUtilOptionText()
  // Description :
  //	Translate option value in text. Mainly for debug purpose.
  // Parameters :
  //	$p_option : the option value.
  // Return Values :
  //	The option text value.
  // --------------------------------------------------------------------------------
  function PclZipUtilOptionText($p_option)
  {
//--(MAGIC-PclTrace)--//PclTraceFctStart(__FILE__, __LINE__, "PclZipUtilOptionText", "option='".$p_option."'");

switch ($p_option) {
  case PCLZIP_OPT_PATH :
$v_result = 'PCLZIP_OPT_PATH';
  break;
  case PCLZIP_OPT_ADD_PATH :
$v_result = 'PCLZIP_OPT_ADD_PATH';
  break;
  case PCLZIP_OPT_REMOVE_PATH :
$v_result = 'PCLZIP_OPT_REMOVE_PATH';
  break;
  case PCLZIP_OPT_REMOVE_ALL_PATH :
$v_result = 'PCLZIP_OPT_REMOVE_ALL_PATH';
  break;
  case PCLZIP_OPT_EXTRACT_AS_STRING :
$v_result = 'PCLZIP_OPT_EXTRACT_AS_STRING';
  break;
  case PCLZIP_OPT_SET_CHMOD :
$v_result = 'PCLZIP_OPT_SET_CHMOD';
  break;
  case PCLZIP_OPT_BY_NAME :
$v_result = 'PCLZIP_OPT_BY_NAME';
  break;
  case PCLZIP_OPT_BY_INDEX :
$v_result = 'PCLZIP_OPT_BY_INDEX';
  break;
  case PCLZIP_OPT_BY_EREG :
$v_result = 'PCLZIP_OPT_BY_EREG';
  break;
  case PCLZIP_OPT_BY_PREG :
$v_result = 'PCLZIP_OPT_BY_PREG';
  break;


  case PCLZIP_CB_PRE_EXTRACT :
$v_result = 'PCLZIP_CB_PRE_EXTRACT';
  break;
  case PCLZIP_CB_POST_EXTRACT :
$v_result = 'PCLZIP_CB_POST_EXTRACT';
  break;
  case PCLZIP_CB_PRE_ADD :
$v_result = 'PCLZIP_CB_PRE_ADD';
  break;
  case PCLZIP_CB_POST_ADD :
$v_result = 'PCLZIP_CB_POST_ADD';
  break;

  default :
$v_result = 'Unknown';
}

// ----- Return
//--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, $v_result);
return $v_result;
  }
  // --------------------------------------------------------------------------------

  // --------------------------------------------------------------------------------
  // Function : PclZipUtilTranslateWinPath()
  // Description :
  //	Translate windows path by replacing '\' by '/' and optionally removing
  //	drive letter.
  // Parameters :
  //	$p_path : path to translate.
  //	$p_remove_disk_letter : true | false
  // Return Values :
  //	The path translated.
  // --------------------------------------------------------------------------------
  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)
  {
if (stristr(php_uname(), 'windows')) {
  // ----- Look for potential disk letter
  if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {
  $p_path = substr($p_path, $v_position+1);
  }
  // ----- Change potential windows directory separator
  if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0,1) == '\\')) {
  $p_path = strtr($p_path, '\\', '/');
  }
}
return $p_path;
  }
  // --------------------------------------------------------------------------------

?>||||||||||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(
    (AST_IF
        (AST_IF_ELEM
            (AST_BINARY_OP
                (AST_CONST)
                (SCALAR))
            (
                (AST_CALL)))
        (AST_IF_ELEM
            (NULL)
            (
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR))
                (AST_ASSIGN
                    (AST_PROP
                        (AST_VAR))
                    (SCALAR))))))