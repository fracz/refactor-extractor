    public function __get($collection) {

        return $this->selectCollection($collection);
    }
}


class UtilArrayQuery {

    public static function buildCondition($criteria, $concat = " && ") {

        $fn = array();

        foreach ($criteria as $key => $value) {

            switch($key) {

                case '$and':
                    $fn[] = '('.self::buildCondition($value, ' && ').')';
                    break;
                case '$or':
                    $fn[] = '('.self::buildCondition($value, ' || ').')';
                    break;
                default:

                    $d = '$document';

                    if(strpos($key, ".") !== false) {
                        $keys = explode('.', $key);

                        foreach ($keys as &$k) {
                            $d .= '["'.$k.'"]';
                        }

                    } else {
                        $d .= '["'.$key.'"]';
                    }

                    $fn[] = is_array($value) ? "\\MongoLite\\UtilArrayQuery::check((isset({$d}) ? {$d} : null), ".var_export($value, true).")": "(isset({$d}) && {$d}==".(is_string($value) ? "'{$value}'": var_export($value, true)).")";
            }
        }

        return count($fn) ? trim(implode($concat, $fn)) : 'true';
    }


    public static function check($value, $condition) {

        if(is_null($value)) return false;

        $keys  = array_keys($condition);

        foreach ($keys as &$key) {
            if(!self::evaluate($key, $value, $condition[$key])) {
                return false;
            }
        }

        return true;
    }

    private static function evaluate($func, $a, $b) {

        $r = false;

        switch ($func) {
            case '$eq' :
                $r = $a == $b;
                break;
            case '$not' :
                $r = $a != $b;
                break;
            case '$gte' :
            case '$gt' :
                if (is_numeric($a) && is_numeric($b)) {
                    $r = $a > $b;
                }
                break;

            case '$lte' :
            case '$lt' :
                if (is_numeric($a) && is_numeric($b)) {
                    $r = $a < $b;
                }
                break;
            case '$in' :
                if (! is_array($b))
                    throw new \InvalidArgumentException('Invalid argument for $in option must be array');
                $r = in_array($a, $b);
                break;

            case '$has' :
                if (is_array($b))
                    throw new \InvalidArgumentException('Invalid argument for $has array not supported');
                $a = @json_decode($a, true) ?  : array();
                $r = in_array($b, $a);
                break;

            case '$all' :
                $a = @json_decode($a, true) ?  : array();
                if (! is_array($b))
                    throw new \InvalidArgumentException('Invalid argument for $all option must be array');
                $r = count(array_intersect_key($a, $b)) == count($b);
                break;

            case '$regex' :
            case '$preg' :
            case '$match' :
                $r = (boolean) @preg_match('/'.$b.'/', $a, $match);
                break;

            case '$size' :
                $a = @json_decode($a, true) ?  : array();
                $r = (int) $b == count($a);
                break;

            case '$mod' :
                if (! is_array($b))
                    throw new \InvalidArgumentException('Invalid argument for $mod option must be array');
                list($x, $y) = each($b);
                $r = $a % $x == 0;
                break;

            case '$func' :
            case '$fn' :
            case '$f' :
                if (! is_callable($b))
                    throw new \InvalidArgumentException('Function should be callable');
                $r = $b($a);
                break;

            default :
                throw new \ErrorException("Condition not valid ... Use {$func} for custom operations");
                break;
        }

        return $r;
    }
}||||||||||||||||NO_DOC_COMMENTNO_RETURN_TYPE
(NO_PARAM_TYPENO_PARAM_DEFAULT)
(
    (AST_RETURN
        (AST_METHOD_CALL
            (AST_VAR)
            (
                (AST_VAR)))))||||||||